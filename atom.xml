<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>jack110530的博客</title>
  
  <subtitle>路漫漫其修远兮，吾将上下而求索。</subtitle>
  <link href="https://jack110530.github.io/atom.xml" rel="self"/>
  
  <link href="https://jack110530.github.io/"/>
  <updated>2020-10-28T03:50:50.070Z</updated>
  <id>https://jack110530.github.io/</id>
  
  <author>
    <name>jack110530</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RunTimer(8)-面试题二</title>
    <link href="https://jack110530.github.io/runtimer-8-%E9%9D%A2%E8%AF%95%E9%A2%98%E4%BA%8C/"/>
    <id>https://jack110530.github.io/runtimer-8-%E9%9D%A2%E8%AF%95%E9%A2%98%E4%BA%8C/</id>
    <published>2020-10-28T03:42:03.000Z</published>
    <updated>2020-10-28T03:50:50.070Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>关键词：RunTime</p></blockquote><a id="more"></a><p>RunTime系列文章:<br></p><ul><li><a href="https://jack110530.github.io/runtimer-1-oc%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9C%AC%E8%B4%A8/">RunTimer(1)-OC对象的本质</a></li><li><a href="https://jack110530.github.io/runtimer-2-class%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/">RunTimer(2)-Class结构分析</a></li><li><a href="https://jack110530.github.io/runtimer-3-cache%E6%96%B9%E6%B3%95%E7%BC%93%E5%AD%98/">RunTimer(3)-Cache方法缓存</a></li><li><a href="https://jack110530.github.io/runtimer-4-%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/">RunTimer(4)-消息机制</a></li><li><a href="https://jack110530.github.io/runtimer-5-super%E7%9A%84%E6%9C%AC%E8%B4%A8/">RunTimer(5)-super的本质</a></li><li><a href="https://jack110530.github.io/runtimer-6-%E5%AE%9E%E9%99%85%E8%BF%90%E7%94%A8/">RunTimer(6)-实际运用</a></li><li><a href="https://jack110530.github.io/runtimer-7-%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%80/">RunTimer(7)-面试题一</a></li><li><a href="https://jack110530.github.io/runtimer-8-%E9%9D%A2%E8%AF%95%E9%A2%98%E4%BA%8C/">RunTimer(8)-面试题二</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;关键词：RunTime&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>RunTimer(7)-面试题一</title>
    <link href="https://jack110530.github.io/runtimer-7-%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%80/"/>
    <id>https://jack110530.github.io/runtimer-7-%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%80/</id>
    <published>2020-10-28T03:41:54.000Z</published>
    <updated>2020-10-28T03:50:50.070Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>关键词：RunTime</p></blockquote><a id="more"></a><p>RunTime系列文章:<br></p><ul><li><a href="https://jack110530.github.io/runtimer-1-oc%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9C%AC%E8%B4%A8/">RunTimer(1)-OC对象的本质</a></li><li><a href="https://jack110530.github.io/runtimer-2-class%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/">RunTimer(2)-Class结构分析</a></li><li><a href="https://jack110530.github.io/runtimer-3-cache%E6%96%B9%E6%B3%95%E7%BC%93%E5%AD%98/">RunTimer(3)-Cache方法缓存</a></li><li><a href="https://jack110530.github.io/runtimer-4-%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/">RunTimer(4)-消息机制</a></li><li><a href="https://jack110530.github.io/runtimer-5-super%E7%9A%84%E6%9C%AC%E8%B4%A8/">RunTimer(5)-super的本质</a></li><li><a href="https://jack110530.github.io/runtimer-6-%E5%AE%9E%E9%99%85%E8%BF%90%E7%94%A8/">RunTimer(6)-实际运用</a></li><li><a href="https://jack110530.github.io/runtimer-7-%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%80/">RunTimer(7)-面试题一</a></li><li><a href="https://jack110530.github.io/runtimer-8-%E9%9D%A2%E8%AF%95%E9%A2%98%E4%BA%8C/">RunTimer(8)-面试题二</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;关键词：RunTime&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>RunTimer(6)-实际运用</title>
    <link href="https://jack110530.github.io/runtimer-6-%E5%AE%9E%E9%99%85%E8%BF%90%E7%94%A8/"/>
    <id>https://jack110530.github.io/runtimer-6-%E5%AE%9E%E9%99%85%E8%BF%90%E7%94%A8/</id>
    <published>2020-10-28T03:41:45.000Z</published>
    <updated>2020-10-28T03:50:50.070Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>关键词：RunTime</p></blockquote><a id="more"></a><p>RunTime系列文章:<br></p><ul><li><a href="https://jack110530.github.io/runtimer-1-oc%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9C%AC%E8%B4%A8/">RunTimer(1)-OC对象的本质</a></li><li><a href="https://jack110530.github.io/runtimer-2-class%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/">RunTimer(2)-Class结构分析</a></li><li><a href="https://jack110530.github.io/runtimer-3-cache%E6%96%B9%E6%B3%95%E7%BC%93%E5%AD%98/">RunTimer(3)-Cache方法缓存</a></li><li><a href="https://jack110530.github.io/runtimer-4-%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/">RunTimer(4)-消息机制</a></li><li><a href="https://jack110530.github.io/runtimer-5-super%E7%9A%84%E6%9C%AC%E8%B4%A8/">RunTimer(5)-super的本质</a></li><li><a href="https://jack110530.github.io/runtimer-6-%E5%AE%9E%E9%99%85%E8%BF%90%E7%94%A8/">RunTimer(6)-实际运用</a></li><li><a href="https://jack110530.github.io/runtimer-7-%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%80/">RunTimer(7)-面试题一</a></li><li><a href="https://jack110530.github.io/runtimer-8-%E9%9D%A2%E8%AF%95%E9%A2%98%E4%BA%8C/">RunTimer(8)-面试题二</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;关键词：RunTime&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>RunTimer(5)-super的本质</title>
    <link href="https://jack110530.github.io/runtimer-5-super%E7%9A%84%E6%9C%AC%E8%B4%A8/"/>
    <id>https://jack110530.github.io/runtimer-5-super%E7%9A%84%E6%9C%AC%E8%B4%A8/</id>
    <published>2020-10-28T03:41:32.000Z</published>
    <updated>2020-10-28T03:50:50.071Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>关键词：RunTime</p></blockquote><a id="more"></a><p>RunTime系列文章:<br></p><ul><li><a href="https://jack110530.github.io/runtimer-1-oc%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9C%AC%E8%B4%A8/">RunTimer(1)-OC对象的本质</a></li><li><a href="https://jack110530.github.io/runtimer-2-class%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/">RunTimer(2)-Class结构分析</a></li><li><a href="https://jack110530.github.io/runtimer-3-cache%E6%96%B9%E6%B3%95%E7%BC%93%E5%AD%98/">RunTimer(3)-Cache方法缓存</a></li><li><a href="https://jack110530.github.io/runtimer-4-%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/">RunTimer(4)-消息机制</a></li><li><a href="https://jack110530.github.io/runtimer-5-super%E7%9A%84%E6%9C%AC%E8%B4%A8/">RunTimer(5)-super的本质</a></li><li><a href="https://jack110530.github.io/runtimer-6-%E5%AE%9E%E9%99%85%E8%BF%90%E7%94%A8/">RunTimer(6)-实际运用</a></li><li><a href="https://jack110530.github.io/runtimer-7-%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%80/">RunTimer(7)-面试题一</a></li><li><a href="https://jack110530.github.io/runtimer-8-%E9%9D%A2%E8%AF%95%E9%A2%98%E4%BA%8C/">RunTimer(8)-面试题二</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;关键词：RunTime&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>RunTimer(4)-消息机制</title>
    <link href="https://jack110530.github.io/runtimer-4-%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/"/>
    <id>https://jack110530.github.io/runtimer-4-%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/</id>
    <published>2020-10-28T03:41:21.000Z</published>
    <updated>2020-10-28T03:50:50.071Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>关键词：RunTime</p></blockquote><a id="more"></a><p>RunTime系列文章:<br></p><ul><li><a href="https://jack110530.github.io/runtimer-1-oc%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9C%AC%E8%B4%A8/">RunTimer(1)-OC对象的本质</a></li><li><a href="https://jack110530.github.io/runtimer-2-class%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/">RunTimer(2)-Class结构分析</a></li><li><a href="https://jack110530.github.io/runtimer-3-cache%E6%96%B9%E6%B3%95%E7%BC%93%E5%AD%98/">RunTimer(3)-Cache方法缓存</a></li><li><a href="https://jack110530.github.io/runtimer-4-%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/">RunTimer(4)-消息机制</a></li><li><a href="https://jack110530.github.io/runtimer-5-super%E7%9A%84%E6%9C%AC%E8%B4%A8/">RunTimer(5)-super的本质</a></li><li><a href="https://jack110530.github.io/runtimer-6-%E5%AE%9E%E9%99%85%E8%BF%90%E7%94%A8/">RunTimer(6)-实际运用</a></li><li><a href="https://jack110530.github.io/runtimer-7-%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%80/">RunTimer(7)-面试题一</a></li><li><a href="https://jack110530.github.io/runtimer-8-%E9%9D%A2%E8%AF%95%E9%A2%98%E4%BA%8C/">RunTimer(8)-面试题二</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;关键词：RunTime&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>RunTimer(3)-Cache方法缓存</title>
    <link href="https://jack110530.github.io/runtimer-3-cache%E6%96%B9%E6%B3%95%E7%BC%93%E5%AD%98/"/>
    <id>https://jack110530.github.io/runtimer-3-cache%E6%96%B9%E6%B3%95%E7%BC%93%E5%AD%98/</id>
    <published>2020-10-28T03:41:11.000Z</published>
    <updated>2020-10-28T03:50:50.071Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>关键词：RunTime</p></blockquote><a id="more"></a><p>RunTime系列文章:<br></p><ul><li><a href="https://jack110530.github.io/runtimer-1-oc%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9C%AC%E8%B4%A8/">RunTimer(1)-OC对象的本质</a></li><li><a href="https://jack110530.github.io/runtimer-2-class%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/">RunTimer(2)-Class结构分析</a></li><li><a href="https://jack110530.github.io/runtimer-3-cache%E6%96%B9%E6%B3%95%E7%BC%93%E5%AD%98/">RunTimer(3)-Cache方法缓存</a></li><li><a href="https://jack110530.github.io/runtimer-4-%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/">RunTimer(4)-消息机制</a></li><li><a href="https://jack110530.github.io/runtimer-5-super%E7%9A%84%E6%9C%AC%E8%B4%A8/">RunTimer(5)-super的本质</a></li><li><a href="https://jack110530.github.io/runtimer-6-%E5%AE%9E%E9%99%85%E8%BF%90%E7%94%A8/">RunTimer(6)-实际运用</a></li><li><a href="https://jack110530.github.io/runtimer-7-%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%80/">RunTimer(7)-面试题一</a></li><li><a href="https://jack110530.github.io/runtimer-8-%E9%9D%A2%E8%AF%95%E9%A2%98%E4%BA%8C/">RunTimer(8)-面试题二</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;关键词：RunTime&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>RunTimer(2)-Class结构分析</title>
    <link href="https://jack110530.github.io/runtimer-2-class%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/"/>
    <id>https://jack110530.github.io/runtimer-2-class%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/</id>
    <published>2020-10-28T03:40:59.000Z</published>
    <updated>2020-10-28T03:50:50.071Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>关键词：RunTime</p></blockquote><a id="more"></a><p>RunTime系列文章:<br></p><ul><li><a href="https://jack110530.github.io/runtimer-1-oc%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9C%AC%E8%B4%A8/">RunTimer(1)-OC对象的本质</a></li><li><a href="https://jack110530.github.io/runtimer-2-class%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/">RunTimer(2)-Class结构分析</a></li><li><a href="https://jack110530.github.io/runtimer-3-cache%E6%96%B9%E6%B3%95%E7%BC%93%E5%AD%98/">RunTimer(3)-Cache方法缓存</a></li><li><a href="https://jack110530.github.io/runtimer-4-%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/">RunTimer(4)-消息机制</a></li><li><a href="https://jack110530.github.io/runtimer-5-super%E7%9A%84%E6%9C%AC%E8%B4%A8/">RunTimer(5)-super的本质</a></li><li><a href="https://jack110530.github.io/runtimer-6-%E5%AE%9E%E9%99%85%E8%BF%90%E7%94%A8/">RunTimer(6)-实际运用</a></li><li><a href="https://jack110530.github.io/runtimer-7-%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%80/">RunTimer(7)-面试题一</a></li><li><a href="https://jack110530.github.io/runtimer-8-%E9%9D%A2%E8%AF%95%E9%A2%98%E4%BA%8C/">RunTimer(8)-面试题二</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;关键词：RunTime&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>RunTimer(1)-OC对象的本质</title>
    <link href="https://jack110530.github.io/runtimer-1-oc%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9C%AC%E8%B4%A8/"/>
    <id>https://jack110530.github.io/runtimer-1-oc%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9C%AC%E8%B4%A8/</id>
    <published>2020-10-28T03:40:43.000Z</published>
    <updated>2020-10-28T03:50:50.164Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>关键词：RunTime</p></blockquote><a id="more"></a><p>RunTime系列文章:<br></p><ul><li><a href="https://jack110530.github.io/runtimer-1-oc%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9C%AC%E8%B4%A8/">RunTimer(1)-OC对象的本质</a></li><li><a href="https://jack110530.github.io/runtimer-2-class%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/">RunTimer(2)-Class结构分析</a></li><li><a href="https://jack110530.github.io/runtimer-3-cache%E6%96%B9%E6%B3%95%E7%BC%93%E5%AD%98/">RunTimer(3)-Cache方法缓存</a></li><li><a href="https://jack110530.github.io/runtimer-4-%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/">RunTimer(4)-消息机制</a></li><li><a href="https://jack110530.github.io/runtimer-5-super%E7%9A%84%E6%9C%AC%E8%B4%A8/">RunTimer(5)-super的本质</a></li><li><a href="https://jack110530.github.io/runtimer-6-%E5%AE%9E%E9%99%85%E8%BF%90%E7%94%A8/">RunTimer(6)-实际运用</a></li><li><a href="https://jack110530.github.io/runtimer-7-%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%80/">RunTimer(7)-面试题一</a></li><li><a href="https://jack110530.github.io/runtimer-8-%E9%9D%A2%E8%AF%95%E9%A2%98%E4%BA%8C/">RunTimer(8)-面试题二</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;关键词：RunTime&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="重拾iOS" scheme="https://jack110530.github.io/categories/%E9%87%8D%E6%8B%BEiOS/"/>
    
    
    <category term="runtime" scheme="https://jack110530.github.io/tags/runtime/"/>
    
  </entry>
  
  <entry>
    <title>Crash防护(4)-NSTimer</title>
    <link href="https://jack110530.github.io/crash%E9%98%B2%E6%8A%A4-4-nstimer/"/>
    <id>https://jack110530.github.io/crash%E9%98%B2%E6%8A%A4-4-nstimer/</id>
    <published>2020-10-27T05:44:15.000Z</published>
    <updated>2020-10-28T03:07:35.595Z</updated>
    
    <content type="html"><![CDATA[<img src="/crash%E9%98%B2%E6%8A%A4-4-nstimer/%E9%87%8D%E6%8B%BEiOS.jpg" class=""><br><blockquote><p>关键词：NSTimer、Runloop、循环引用、NSProxy</p></blockquote><a id="more"></a><p>Crash防护系列文章:<br></p><ul><li><a href="https://jack110530.github.io/crash%E9%98%B2%E6%8A%A4-1-unrecognized-selector/">Crash防护(1)-Unrecognized Selector</a></li><li><a href="https://jack110530.github.io/crash%E9%98%B2%E6%8A%A4-2-kvo/">Crash防护(2)-KVO</a></li><li><a href="https://jack110530.github.io/crash%E9%98%B2%E6%8A%A4-3-kvc/">Crash防护(3)-KVC</a></li><li><a href="https://jack110530.github.io/crash%E9%98%B2%E6%8A%A4-4-nstimer/">Crash防护(4)-NSTimer</a></li></ul>        <h3 id="前言"   >          <a href="#前言" class="heading-link"><i class="fas fa-link"></i></a>前言</h3>      <ol><li>开发中又遇到NSTimer相关的问题吗，是怎么解决的？</li><li>NSTimer循环引用方案</li></ol>        <h3 id="NSTimer-Crash-的产生原因"   >          <a href="#NSTimer-Crash-的产生原因" class="heading-link"><i class="fas fa-link"></i></a>NSTimer Crash 的产生原因</h3>      <p>在程序开发过程中，大家会经常使用定时任务，但使用NSTimer的 scheduledTimerWithTimeInterval:target:selector:userInfo:repeats:接口做重复性的定时任务时存在一个问题：NSTimer会强引用target实例，所以需要在合适的时机invalidate定时器，否则就会由于定时器timer强引用target的关系导致target不能被释放，造成内存泄露，甚至在定时任务触发时导致crash。crash的展现形式和具体的target执行的selector有关。<br></p><p>与此同时，如果NSTimer是无限重复的执行一个任务的话，也有可能导致target的selector一直被重复调用且处于无效状态，对app的CPU，内存等性能方面均是没有必要的浪费。<br></p><p><strong>代码示例</strong>：<br></p><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&quot;TimerCrashTestVC.h&quot;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">TimerCrashTestVC</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSTimer</span> *timer;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">TimerCrashTestVC</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="keyword">self</span>.timer = [<span class="built_in">NSTimer</span> timerWithTimeInterval:<span class="number">1</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(timerEvent) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line">    [[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:<span class="keyword">self</span>.timer forMode:<span class="built_in">NSRunLoopCommonModes</span>];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)timerEvent&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;定时器事件&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></div></figure><p>在ViewController中，点击按钮push到TimerCrashTestVC。<br></p><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TimerCrashTestVC *vc = [[TimerCrashTestVC alloc]init];</span><br><span class="line">[<span class="keyword">self</span>.navigationController pushViewController:vc animated:<span class="literal">YES</span>];</span><br></pre></td></tr></table></div></figure><p>控制台打印定时器事件:<br></p><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2020</span><span class="number">-10</span><span class="number">-21</span> <span class="number">10</span>:<span class="number">16</span>:<span class="number">37.877364</span>+<span class="number">0800</span> TestDemo[<span class="number">39003</span>:<span class="number">883014</span>] 定时器事件</span><br><span class="line"><span class="number">2020</span><span class="number">-10</span><span class="number">-21</span> <span class="number">10</span>:<span class="number">16</span>:<span class="number">38.876337</span>+<span class="number">0800</span> TestDemo[<span class="number">39003</span>:<span class="number">883014</span>] 定时器事件</span><br><span class="line"><span class="number">2020</span><span class="number">-10</span><span class="number">-21</span> <span class="number">10</span>:<span class="number">16</span>:<span class="number">39.877408</span>+<span class="number">0800</span> TestDemo[<span class="number">39003</span>:<span class="number">883014</span>] 定时器事件</span><br><span class="line">...</span><br></pre></td></tr></table></div></figure><p>此时，若pop，按我们想象的来说，TimerCrashTestVC应该dealloc 并且NSTimer也应该停止。<br><br>但是，当我们pop时，事实却与我们想象的不一样，打印如下：<br></p><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2020</span><span class="number">-10</span><span class="number">-21</span> <span class="number">10</span>:<span class="number">16</span>:<span class="number">40.877086</span>+<span class="number">0800</span> TestDemo[<span class="number">39003</span>:<span class="number">883014</span>] 定时器事件</span><br><span class="line"><span class="number">2020</span><span class="number">-10</span><span class="number">-21</span> <span class="number">10</span>:<span class="number">16</span>:<span class="number">41.877532</span>+<span class="number">0800</span> TestDemo[<span class="number">39003</span>:<span class="number">883014</span>] 定时器事件</span><br><span class="line"><span class="number">2020</span><span class="number">-10</span><span class="number">-21</span> <span class="number">10</span>:<span class="number">16</span>:<span class="number">42.877496</span>+<span class="number">0800</span> TestDemo[<span class="number">39003</span>:<span class="number">883014</span>] 定时器事件</span><br><span class="line">...</span><br></pre></td></tr></table></div></figure><p>TimerCrashTestVC并没有dealloc，并且NSTimer也没有停止！！！<br></p><p>有人说，需要在dealloc中将NSTImer invalidate。比如：<br></p><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">    [<span class="keyword">self</span>.timer invalidate];</span><br><span class="line">    <span class="keyword">self</span>.timer = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>不幸的是，dealloc方法将永远不会被调用。因为timer的引用，TimerCrashTestVC对象的引用计数永远不会降到0，dealloc方法也就不会被调用，timer也一直在执行事件。<br></p><p>其实，在实际开发过程中很容易出现这种错误。<br></p><p>所以，很有必要设计出一种方案，可以有效的防护NSTimer的滥用问题。</p>        <h3 id="NSTimer-Crash-防护方案"   >          <a href="#NSTimer-Crash-防护方案" class="heading-link"><i class="fas fa-link"></i></a>NSTimer Crash 防护方案</h3>      <p>苹果官方文档中：<br></p><blockquote><p>This method is the only way to remove a timer from an NSRunLoop object. The NSRunLoop object removes its strong reference to the timer, either just before the invalidate method returns or at some later point.<br>If it was configured with target and user info objects, the receiver removes its strong references to those objects as well.<br>You must send this message from the thread on which the timer was installed. If you send this message from another thread, the input source associated with the timer may not be removed from its run loop, which could prevent the thread from exiting properly.</p></blockquote><p>可以看到，当一个timer被schedule的时候，timer会持有target对象，NSRunLoop对象会持有timer。当invalidate被调用时，NSRunLoop对象会释放对timer的持有，timer会释放对target的持有。除此之外，我们没有途径可以释放timer对target的持有。所以解决内存泄露就必须撤销timer，若不撤销，target对象将永远无法释放。<br></p><p>上面的分析可见，NSTimer所产生的问题的主要原因是因为其没有再一个合适的时机invalidate，同时还有NSTimer对target的强引用导致的内存泄漏问题。<br></p><p>那么解决NSTimer的问题的关键点在于以下两点：<br></p><ol><li>STimer对其target是否可以不强引用；</li><li>是否找到一个合适的时机，在确定NSTimer已经失效的情况下，让NSTimer自动invalidate；</li></ol><p>针对第一点，可以使用NSProxy消息转发实现。<br><br>在NSTimer和target之间加入一层proxy，proxy主要做为一个桥接层，负责NSTimer和target之间的通信。<br><br>让NSProxy作为NSTimer的target，NSTimer强引用着proxy，同时proxy弱引用真正的target，并把所有的消息转发到真正的target上。这样就解决了循环引用的问题了。<br></p><p>针对第二点，也可以使用中间层，在执行定时器的方法selector前判断NSTimer是否已经失效。<br></p><p>结合第一点和第二点总结，有如下代码：<br><br>首先，子类化一个NSProxy用于做消息转发。<br></p><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SFProxy</span> : <span class="title">NSProxy</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="built_in">NSObject</span> *target;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithTarget:(<span class="keyword">id</span>)target;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)proxyWithTarget:(<span class="keyword">id</span>)target;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// .m</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SFProxy</span></span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithTarget:(<span class="keyword">id</span>)target &#123;</span><br><span class="line">    _target = target;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)proxyWithTarget:(<span class="keyword">id</span>)target &#123;</span><br><span class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span> alloc] initWithTarget:target];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息转发</span></span><br><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.target &amp;&amp; [<span class="keyword">self</span>.target respondsToSelector:aSelector]) &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="keyword">self</span>.target methodSignatureForSelector:aSelector];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> methodSignatureForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation&#123;</span><br><span class="line">    SEL aSelector = [anInvocation selector];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.target &amp;&amp; [<span class="keyword">self</span>.target respondsToSelector:aSelector]) &#123;</span><br><span class="line">        [anInvocation invokeWithTarget:<span class="keyword">self</span>.target];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [<span class="keyword">super</span> forwardInvocation:anInvocation];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></div></figure><p>然后，再子类化SFProxy，用于接收aTarget的aSelector，在执行前判断timer是否应该invalidate。<br></p><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SFTimerProxy</span> : <span class="title">SFProxy</span></span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithTarget:(<span class="keyword">id</span>)target aSelector:(SEL)aSelector;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)proxyWithTarget:(<span class="keyword">id</span>)target aSelector:(SEL)aSelector;</span><br><span class="line">- (<span class="keyword">void</span>)fireProxyTimer:(<span class="built_in">NSTimer</span> *)timer;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// .m</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SFTimerProxy</span></span></span><br><span class="line">&#123;</span><br><span class="line">    SEL _aSelector;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithTarget:(<span class="keyword">id</span>)target aSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> initWithTarget:target];</span><br><span class="line">    _aSelector = aSelector;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)proxyWithTarget:(<span class="keyword">id</span>)target aSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span> alloc] initWithTarget:target aSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)fireProxyTimer:(<span class="built_in">NSTimer</span> *)timer &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.target) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span>.target respondsToSelector:_aSelector]) &#123;</span><br><span class="line">            [<span class="keyword">self</span>.target performSelector:_aSelector withObject:timer];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        [timer invalidate];</span><br><span class="line">        timer = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span><span class="class"><span class="keyword">@implementation</span> <span class="title">SFTimerProxy</span></span></span><br><span class="line">&#123;</span><br><span class="line">    SEL _aSelector;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithTarget:(<span class="keyword">id</span>)target aSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> initWithTarget:target];</span><br><span class="line">    _aSelector = aSelector;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)proxyWithTarget:(<span class="keyword">id</span>)target aSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span> alloc] initWithTarget:target aSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)fireProxyTimer:(<span class="built_in">NSTimer</span> *)timer &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.target) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span>.target respondsToSelector:_aSelector]) &#123;</span><br><span class="line">            [<span class="keyword">self</span>.target performSelector:_aSelector withObject:timer];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        [timer invalidate];</span><br><span class="line">        timer = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></div></figure><p>第三步，新建一个分类NSTimer+TimerCrash。<br></p><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&quot;NSTimer+TimerCrash.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;NSObject+MethodSwizzling.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;SFCrachInspector.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;SFTimerProxy.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSTimer</span> (<span class="title">TimerCrash</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 交换timerWithTimeInterval:target:selector:userInfo:repeats:方法</span></span><br><span class="line">        [<span class="built_in">NSObject</span> sf_swizzlingClassMethod:<span class="keyword">@selector</span>(timerWithTimeInterval:target:selector:userInfo:repeats:) swizzledMethod:<span class="keyword">@selector</span>(sf_timerWithTimeInterval:target:selector:userInfo:repeats:) withClass:[<span class="built_in">NSTimer</span> <span class="keyword">class</span>]];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 交换scheduledTimerWithTimeInterval:target:selector:userInfo:repeats:方法</span></span><br><span class="line">        [<span class="built_in">NSObject</span> sf_swizzlingClassMethod:<span class="keyword">@selector</span>(scheduledTimerWithTimeInterval:target:selector:userInfo:repeats:) swizzledMethod:<span class="keyword">@selector</span>(sf_scheduledTimerWithTimeInterval:target:selector:userInfo:repeats:) withClass:[<span class="built_in">NSTimer</span> <span class="keyword">class</span>]];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSTimer</span> *)sf_timerWithTimeInterval:(<span class="built_in">NSTimeInterval</span>)ti target:(<span class="keyword">id</span>)aTarget selector:(SEL)aSelector userInfo:(<span class="keyword">nullable</span> <span class="keyword">id</span>)userInfo repeats:(<span class="built_in">BOOL</span>)yesOrNo &#123;</span><br><span class="line">    SFTimerProxy *proxy = [SFTimerProxy proxyWithTarget:aTarget aSelector:aSelector];</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> sf_timerWithTimeInterval:ti target:proxy selector:<span class="keyword">@selector</span>(fireProxyTimer:) userInfo:userInfo repeats:yesOrNo];</span><br><span class="line">&#125;</span><br><span class="line">+ (<span class="built_in">NSTimer</span> *)sf_scheduledTimerWithTimeInterval:(<span class="built_in">NSTimeInterval</span>)ti target:(<span class="keyword">id</span>)aTarget selector:(SEL)aSelector userInfo:(<span class="keyword">nullable</span> <span class="keyword">id</span>)userInfo repeats:(<span class="built_in">BOOL</span>)yesOrNo &#123;</span><br><span class="line">    SFTimerProxy *proxy = [SFTimerProxy proxyWithTarget:aTarget aSelector:aSelector];</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> sf_scheduledTimerWithTimeInterval:ti target:proxy selector:<span class="keyword">@selector</span>(fireProxyTimer:) userInfo:userInfo repeats:yesOrNo];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></div></figure><p>至此，NSTimer的循环引用问题和NSTimer的invalidate时机问题就解决了。<br></p><p>重新运行后，push后pop，打印如下：<br></p><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2020</span><span class="number">-10</span><span class="number">-21</span> <span class="number">10</span>:<span class="number">41</span>:<span class="number">18.160033</span>+<span class="number">0800</span> TestDemo[<span class="number">39207</span>:<span class="number">898748</span>] 定时器事件</span><br><span class="line"><span class="number">2020</span><span class="number">-10</span><span class="number">-21</span> <span class="number">10</span>:<span class="number">41</span>:<span class="number">19.160044</span>+<span class="number">0800</span> TestDemo[<span class="number">39207</span>:<span class="number">898748</span>] 定时器事件</span><br><span class="line"><span class="number">2020</span><span class="number">-10</span><span class="number">-21</span> <span class="number">10</span>:<span class="number">41</span>:<span class="number">20.160049</span>+<span class="number">0800</span> TestDemo[<span class="number">39207</span>:<span class="number">898748</span>] 定时器事件</span><br><span class="line"><span class="number">2020</span><span class="number">-10</span><span class="number">-21</span> <span class="number">10</span>:<span class="number">41</span>:<span class="number">21.100760</span>+<span class="number">0800</span> TestDemo[<span class="number">39207</span>:<span class="number">898748</span>] -[TimerCrashTestVC dealloc]</span><br></pre></td></tr></table></div></figure><p>此时，我们不需要在dealloc中写NSTImer invalidate方法，TimerCrashTestVC也成功dealloc，NSTimer也invalidate了。<br></p><hr><p>[代码链接]<br/><br>GitHub：<span class="exturl"><a class="exturl__link"   href="https://github.com/jack110530/SFCrash" >https://github.com/jack110530/SFCrash</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><hr><p>[相关参考]<br/></p><ol><li><span class="exturl"><a class="exturl__link"   href="https://www.jianshu.com/p/f63395599633" >网易iOS App运行时Crash自动防护实践</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li></ol>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;/crash%E9%98%B2%E6%8A%A4-4-nstimer/%E9%87%8D%E6%8B%BEiOS.jpg&quot; class=&quot;&quot;&gt;
&lt;br&gt;

&lt;blockquote&gt;
&lt;p&gt;关键词：NSTimer、Runloop、循环引用、NSProxy&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Crash防护(3)-KVC</title>
    <link href="https://jack110530.github.io/crash%E9%98%B2%E6%8A%A4-3-kvc/"/>
    <id>https://jack110530.github.io/crash%E9%98%B2%E6%8A%A4-3-kvc/</id>
    <published>2020-10-27T04:52:18.000Z</published>
    <updated>2020-10-28T03:07:35.596Z</updated>
    
    <content type="html"><![CDATA[<img src="/crash%E9%98%B2%E6%8A%A4-3-kvc/%E9%87%8D%E6%8B%BEiOS.jpg" class=""><br><blockquote><p>关键词：KVC、Runtime</p></blockquote><a id="more"></a><p>Crash防护系列文章:<br></p><ul><li><a href="https://jack110530.github.io/crash%E9%98%B2%E6%8A%A4-1-unrecognized-selector/">Crash防护(1)-Unrecognized Selector</a></li><li><a href="https://jack110530.github.io/crash%E9%98%B2%E6%8A%A4-2-kvo/">Crash防护(2)-KVO</a></li><li><a href="https://jack110530.github.io/crash%E9%98%B2%E6%8A%A4-3-kvc/">Crash防护(3)-KVC</a></li><li><a href="https://jack110530.github.io/crash%E9%98%B2%E6%8A%A4-4-nstimer/">Crash防护(4)-NSTimer</a></li></ul>        <h3 id="前言"   >          <a href="#前言" class="heading-link"><i class="fas fa-link"></i></a>前言</h3>      <ol><li>日常开发中有没有遇到过因为KVC而奔溃的问题？</li></ol>        <h3 id="KVC-Crash-的产生原因"   >          <a href="#KVC-Crash-的产生原因" class="heading-link"><i class="fas fa-link"></i></a>KVC Crash 的产生原因</h3>      <p>KVC 日常使用造成崩溃的原因通常有以下几个：</p><ol><li>key 不是对象的属性，造成崩溃。</li><li>keyPath 不正确，造成崩溃。</li><li>key 为 nil，造成崩溃。</li><li>value 为 nil，为非对象设值，造成崩溃。</li></ol>        <h3 id="KVC-Crash-防护方案"   >          <a href="#KVC-Crash-防护方案" class="heading-link"><i class="fas fa-link"></i></a>KVC Crash 防护方案</h3>              <h4 id="1、思路"   >          <a href="#1、思路" class="heading-link"><i class="fas fa-link"></i></a>1、思路</h4>      <p>理解了KVC的设值取值原理的基础上，我们知道：<br></p><ul><li>setValue:forKey: 执行失败会调用 setValue: forUndefinedKey: 方法，并引发崩溃。</li><li>valueForKey: 执行失败会调用 valueForUndefinedKey: 方法，并引发崩溃。</li></ul><p>所以，为了进行 KVC Crash 防护，我们就需要重写 setValue: forUndefinedKey: 方法和 valueForUndefinedKey: 方法。重写这两个方法之后，就可以防护 <strong>1. key 不是对象的属性</strong> 和 <strong>2. keyPath 不正确 这两种崩溃情况了</strong>。<br></p><p>那么 <strong>3. key 为 nil，造成崩溃</strong> 的情况，该怎么防护呢？<br><br>我们可以利用 Method Swizzling 方法，在 NSObject 的分类中将 setValue:forKey: 和 sf_setValue:forKey: 进行方法交换。然后在自定义的方法中，添加对 key 为 nil 这种类型的判断。<br></p><p>还有最后一种 <strong>4. value 为 nil，为非对象设值，造成崩溃</strong> 的情况。<br><br>在 NSKeyValueCoding.h 文件中，有一个 setNilValueForKey: 方法。上边的官方注释给了我们答案。<br><br>在调用 setValue:forKey: 方法时，系统如果查找到名为 set<Key>: 方法的时候，会去检测 value 的参数类型，如果参数类型为 NSNmber 的标量类型或者是 NSValue 的结构类型，但是 value 为 nil 时，会自动调用 setNilValueForKey: 方法。这个方法的默认实现会引发崩溃。<br><br>所以为了防止这种情况导致的崩溃，我们可以通过重写 setNilValueForKey: 来解决。</p>        <h4 id="2、代码"   >          <a href="#2、代码" class="heading-link"><i class="fas fa-link"></i></a>2、代码</h4>      <p>新建分类NSObject+KvoCrash<br></p><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">KvcCrash</span>)</span></span><br><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        <span class="comment">// 交换setValue:forKey:方法(实例方法和对象方法)</span></span><br><span class="line">        [<span class="built_in">NSObject</span> sf_swizzlingInstanceMethod:<span class="keyword">@selector</span>(setValue:forKey:) swizzledMethod:<span class="keyword">@selector</span>(sf_setValue:forKey:) withClass:[<span class="built_in">NSObject</span> <span class="keyword">class</span>]];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)sf_setValue:(<span class="keyword">id</span>)value forKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="built_in">BOOL</span> isOpen = [SFCrachInspector checkIsOpenWithOption:SFCrashInspectorOptionKVC];</span><br><span class="line">    <span class="keyword">if</span> (isOpen) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!key) &#123;</span><br><span class="line">            <span class="built_in">NSString</span> *msg = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;【KVC】[&lt;%@ %p&gt; setValue:forKey:]: attempt to set a value for a nil key. &quot;</span>,<span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> <span class="keyword">class</span>]),<span class="keyword">self</span>];</span><br><span class="line">            [SFCrachInspector log:msg];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span> sf_setValue:value forKey:key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setNilValueForKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="built_in">BOOL</span> isOpen = [SFCrachInspector  checkIsOpenWithOption:SFCrashInspectorOptionKVC];</span><br><span class="line">    <span class="keyword">if</span> (isOpen) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *msg = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;【KVC】[&lt;%@ %p&gt; setNilValueForKey]: could not set nil as the value for the key %@.&quot;</span>,<span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> <span class="keyword">class</span>]),<span class="keyword">self</span>,key];</span><br><span class="line">        [SFCrachInspector log:msg];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setValue:(<span class="keyword">id</span>)value forUndefinedKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="built_in">BOOL</span> isOpen = [SFCrachInspector checkIsOpenWithOption:SFCrashInspectorOptionKVC];</span><br><span class="line">    <span class="keyword">if</span> (isOpen) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *msg = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;【KVC】[&lt;%@ %p&gt; setValue:forUndefinedKey:]: this class is not key value coding-compliant for the key: %@,value:%@&#x27;.&quot;</span>,<span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> <span class="keyword">class</span>]),<span class="keyword">self</span>,key,value];</span><br><span class="line">        [SFCrachInspector log:msg];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>)valueForUndefinedKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="built_in">BOOL</span> isOpen = [SFCrachInspector checkIsOpenWithOption:SFCrashInspectorOptionKVC];</span><br><span class="line">    <span class="keyword">if</span> (isOpen) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *msg = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;【KVC】[&lt;%@ %p&gt; valueForUndefinedKey:]: this class is not key value coding-compliant for the key: %@.&quot;</span>,<span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> <span class="keyword">class</span>]),<span class="keyword">self</span>,key];</span><br><span class="line">        [SFCrachInspector log:msg];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></div></figure><hr><p>[代码链接]<br/><br>GitHub：<span class="exturl"><a class="exturl__link"   href="https://github.com/jack110530/SFCrash" >https://github.com/jack110530/SFCrash</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><hr><p>[相关参考]<br/></p><ol><li><span class="exturl"><a class="exturl__link"   href="https://juejin.im/post/6844903934662803464" >iOS 开发：『Crash 防护系统』（三）KVC 防护</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> </li><li><span class="exturl"><a class="exturl__link"   href="https://www.jianshu.com/p/f63395599633" >网易iOS App运行时Crash自动防护实践</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li></ol>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;/crash%E9%98%B2%E6%8A%A4-3-kvc/%E9%87%8D%E6%8B%BEiOS.jpg&quot; class=&quot;&quot;&gt;
&lt;br&gt;

&lt;blockquote&gt;
&lt;p&gt;关键词：KVC、Runtime&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Crash防护(2)-KVO</title>
    <link href="https://jack110530.github.io/crash%E9%98%B2%E6%8A%A4-2-kvo/"/>
    <id>https://jack110530.github.io/crash%E9%98%B2%E6%8A%A4-2-kvo/</id>
    <published>2020-10-27T04:41:33.000Z</published>
    <updated>2020-10-28T03:07:35.595Z</updated>
    
    <content type="html"><![CDATA[<img src="/crash%E9%98%B2%E6%8A%A4-2-kvo/%E9%87%8D%E6%8B%BEiOS.jpg" class=""><br><blockquote><p>关键词：KVO、HashMap、Swizzling</p></blockquote><a id="more"></a><p>Crash防护系列文章:<br></p><ul><li><a href="https://jack110530.github.io/crash%E9%98%B2%E6%8A%A4-1-unrecognized-selector/">Crash防护(1)-Unrecognized Selector</a></li><li><a href="https://jack110530.github.io/crash%E9%98%B2%E6%8A%A4-2-kvo/">Crash防护(2)-KVO</a></li><li><a href="https://jack110530.github.io/crash%E9%98%B2%E6%8A%A4-3-kvc/">Crash防护(3)-KVC</a></li><li><a href="https://jack110530.github.io/crash%E9%98%B2%E6%8A%A4-4-nstimer/">Crash防护(4)-NSTimer</a></li></ul>        <h3 id="前言"   >          <a href="#前言" class="heading-link"><i class="fas fa-link"></i></a>前言</h3>      <ol><li>开发中KVO用的多吗，有没有遇到过因为KVO引发的bug？</li><li>针对KVO crash防护，怎么做？</li></ol>        <h3 id="KVO造成崩溃的原因"   >          <a href="#KVO造成崩溃的原因" class="heading-link"><i class="fas fa-link"></i></a>KVO造成崩溃的原因</h3>      <ol><li>KVO 添加次数和移除次数不匹配：<ul><li>移除了未注册的观察者，导致崩溃。</li><li>重复移除多次，移除次数多于添加次数，导致崩溃。</li><li>重复添加多次，虽然不会崩溃，但是发生改变时，也同时会被观察多次。</li></ul></li><li>被观察者提前被释放，被观察者在 dealloc 时仍然注册着 KVO，导致崩溃。 例如：被观察者是局部变量的情况（iOS 10 及之前会崩溃）。</li><li>添加了观察者，但未实现 observeValueForKeyPath:ofObject:change:context: 方法，导致崩溃。</li><li>添加或者移除时 keypath == nil，导致崩溃。</li></ol>        <h3 id="KVO-Crash防护方案"   >          <a href="#KVO-Crash防护方案" class="heading-link"><i class="fas fa-link"></i></a>KVO Crash防护方案</h3>      <p>为了避免上面提到的使用 KVO 造成崩溃的问题，于是出现了很多关于 KVO 的第三方库，比如最出名的就是 FaceBook 开源的第三方库 <span class="exturl"><a class="exturl__link"   href="https://github.com/facebook/KVOController" >facebook / KVOController</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>。<br></p><p>FBKVOController 对 KVO 机制进行了额外的一层封装，框架不但可以自动帮我们移除观察者，还提供了 block 或者 selector 的方式供我们进行观察处理。不可否认的是，FBKVOController 为我们的开发提供了很大的便利性。但是相对而言，这种方式对项目代码的侵入性比较大，必须依靠编码规范来强制约束团队人员使用这种方式。<br></p><p>那么有没有一种对项目代码侵入性小，同时还能有效防护 KVO 崩溃的防护机制呢？<br>具体可以参考一下 iOS 开发：『Crash 防护系统』（二）KVO 防护 这篇文章。<br></p><p>但是，查阅YSC-Avoid-Crash和BayMaxProtector 源码后，发现还存在些问题，所以在“前人”的基础上添加了自己的改进代码：<br><br>本来是把源码中的一些问题写了下来，发现似乎有些不妥，就删掉了。想详细了解的朋友可以私信我。</p><hr><p>[代码链接]<br/><br>GitHub：<span class="exturl"><a class="exturl__link"   href="https://github.com/jack110530/SFCrash" >https://github.com/jack110530/SFCrash</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><hr><p>[相关参考]<br/></p><ol><li><span class="exturl"><a class="exturl__link"   href="https://juejin.im/post/6844903927469588488" >iOS 开发：『Crash 防护系统』（二）KVO 防护</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> </li><li><span class="exturl"><a class="exturl__link"   href="https://www.jianshu.com/p/f63395599633" >网易iOS App运行时Crash自动防护实践</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li></ol>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;/crash%E9%98%B2%E6%8A%A4-2-kvo/%E9%87%8D%E6%8B%BEiOS.jpg&quot; class=&quot;&quot;&gt;
&lt;br&gt;

&lt;blockquote&gt;
&lt;p&gt;关键词：KVO、HashMap、Swizzling&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="重拾iOS" scheme="https://jack110530.github.io/categories/%E9%87%8D%E6%8B%BEiOS/"/>
    
    
    <category term="crash" scheme="https://jack110530.github.io/tags/crash/"/>
    
  </entry>
  
  <entry>
    <title>Crash防护(1)-Unrecognized Selector</title>
    <link href="https://jack110530.github.io/crash%E9%98%B2%E6%8A%A4-1-unrecognized-selector/"/>
    <id>https://jack110530.github.io/crash%E9%98%B2%E6%8A%A4-1-unrecognized-selector/</id>
    <published>2020-10-27T03:33:52.000Z</published>
    <updated>2020-10-28T03:06:25.091Z</updated>
    
    <content type="html"><![CDATA[<img src="/crash%E9%98%B2%E6%8A%A4-1-unrecognized-selector/%E9%87%8D%E6%8B%BEiOS.jpg" class=""><br><blockquote><p>关键词：Unrecognized Selector、Runtime、Swizzling</p></blockquote><a id="more"></a><p>Crash防护系列文章:<br></p><ul><li><a href="https://jack110530.github.io/crash%E9%98%B2%E6%8A%A4-1-unrecognized-selector/">Crash防护(1)-Unrecognized Selector</a></li><li><a href="https://jack110530.github.io/crash%E9%98%B2%E6%8A%A4-2-kvo/">Crash防护(2)-KVO</a></li><li><a href="https://jack110530.github.io/crash%E9%98%B2%E6%8A%A4-3-kvc/">Crash防护(3)-KVC</a></li><li><a href="https://jack110530.github.io/crash%E9%98%B2%E6%8A%A4-4-nstimer/">Crash防护(4)-NSTimer</a></li></ul>        <h3 id="前言"   >          <a href="#前言" class="heading-link"><i class="fas fa-link"></i></a>前言</h3>      <p>APP 的崩溃问题，一直以来都是开发过程中重中之重的问题。日常开发阶段的崩溃，发现后还能够立即处理。但是一旦发布上架的版本出现问题，就需要紧急加班修复 BUG，再更新上架新版本了。在这个过程中， 说不定会因为崩溃而导致关键业务中断、用户存留率下降、品牌口碑变差、生命周期价值下降等，最终导致流失用户，影响到公司的发展。<br></p><p>当然，避免崩溃问题的最好办法就是不产生崩溃。在开发的过程中就要尽可能地保证程序的健壮性。但是，人又不是机器，不可能不犯错。不可能存在没有 BUG 的程序。但是如果能够利用一些语言机制和系统方法，设计一套防护系统，使之能够有效的降低 APP 的崩溃率，那么不仅 APP 的稳定性得到了保障，而且最重要的是可以减少不必要的加班。<br></p><p><strong>【代码示例】</strong><br><br>如果被调用的对象方法没有实现，那么程序在运行中调用该方法时，就会因为找不到对应的方法实现，从而导致 APP 崩溃。比如下面这样的代码：<br></p><p>首先，在Person类中，声明了一个testInstanceFunc对象方法和一个testClassFunc类方法，但是却没有给出实现代码（IMP）</p><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line">- (<span class="keyword">void</span>)testInstanceFunc;</span><br><span class="line">+ (<span class="keyword">void</span>)testClassFunc;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// .m</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></div></figure><p>然后，在ViewController中：</p><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试对象方法</span></span><br><span class="line">Person *p = [[Person alloc]init];</span><br><span class="line">[p testInstanceFunc];</span><br><span class="line"><span class="comment">// 测试类方法</span></span><br><span class="line">[Person testClassFunc];</span><br></pre></td></tr></table></div></figure><p>运行后，会发现崩溃了。分别报错：</p><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试对象方法</span></span><br><span class="line">TestDemo[<span class="number">11056</span>:<span class="number">518162</span>] -[Person testInstanceFunc]: unrecognized selector sent to instance <span class="number">0x600000c74340</span></span><br><span class="line"><span class="comment">// 测试类方法</span></span><br><span class="line">TestDemo[<span class="number">11082</span>:<span class="number">519535</span>] +[Person testClassFunc]: unrecognized selector sent to <span class="keyword">class</span> <span class="number">0x108897670</span></span><br></pre></td></tr></table></div></figure><p>那么，像这种 unrecognized selector 的奔溃问题怎么去避免呢？至少项目上线后，在正式环境中不发生崩溃吧。</p>        <h3 id="一、Runtime预备知识"   >          <a href="#一、Runtime预备知识" class="heading-link"><i class="fas fa-link"></i></a>一、Runtime预备知识</h3>      <p>首先，我们要知道方法调用的本质是什么。<br></p><p>在OC中，方法调用的本质就是消息发送objc_msgSend。给对象发送消息，先会经过方法查找，找到了则执行方法实现。若没有找到则会进入消息转发阶段。若消息转发阶段也没有方法实现，则发生崩溃。<br></p><p>其中，在消息转发中三大步骤：动态方法解析、备用接收者、完整的消息转发。通过这三大步骤，可以让我们在程序找不到调用方法崩溃之前，拦截方法调用。<br></p><ul><li><strong>动态方法解析</strong>：Objective-C 运行时会调用 +resolveInstanceMethod: 或者 +resolveClassMethod:，让你有机会提供一个函数实现。我们可以通过重写这两个方法，添加其他函数实现，并返回 YES， 那运行时系统就会重新启动一次消息发送的过程。若返回 NO 或者没有添加其他函数实现，则进入下一步。</li><li><strong>备用接收者</strong>：如果当前对象实现了 forwardingTargetForSelector:，Runtime 就会调用这个方法，允许我们将消息的接受者转发给其他对象。如果这一步方法返回 nil，则进入下一步。</li><li><strong>完整的消息转发</strong>：Runtime 系统利用 methodSignatureForSelector: 方法获取函数的参数和返回值类型。<br>如果 methodSignatureForSelector: 返回了一个 NSMethodSignature 对象（函数签名），Runtime 系统就会创建一个 NSInvocation 对象，并通过 forwardInvocation: 消息通知当前对象，给予此次消息发送最后一次寻找 IMP 的机会。<br>如果 methodSignatureForSelector: 返回 nil。则 Runtime 系统会发出 doesNotRecognizeSelector: 消息，程序也就崩溃了。</li></ul><img src="/crash%E9%98%B2%E6%8A%A4-1-unrecognized-selector/%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91.jpg" class="">        <h3 id="二、Crash防护方案"   >          <a href="#二、Crash防护方案" class="heading-link"><i class="fas fa-link"></i></a>二、Crash防护方案</h3>              <h4 id="1、思路"   >          <a href="#1、思路" class="heading-link"><i class="fas fa-link"></i></a>1、思路</h4>      <p>Objective-C 语言是一门动态语言，我们可以利用 Objective-C 语言的 Runtime 运行时机制，对需要 Hook 的类添加 Category（分类），在各个分类的 +(void)load; 中通过 Method Swizzling 拦截容易造成崩溃的系统方法，将系统原有方法与添加的防护方法的 selector（方法选择器） 与 IMP（函数实现指针）进行对调。然后在替换方法中添加防护操作，从而达到避免以及修复崩溃的目的。<br></p><p>这里我们选择第二步（备用接收者）来进行拦截。因为 -forwardingTargetForSelector 方法可以将消息转发给一个对象，开销较小，并且被重写的概率较低，适合重写。<br></p>        <h4 id="2、代码"   >          <a href="#2、代码" class="heading-link"><i class="fas fa-link"></i></a>2、代码</h4>              <h5 id="1，给NSObject新建个Category用于方法交换（NSObject-MethodSwizzling）"   >          <a href="#1，给NSObject新建个Category用于方法交换（NSObject-MethodSwizzling）" class="heading-link"><i class="fas fa-link"></i></a>1，给NSObject新建个Category用于方法交换（NSObject+MethodSwizzling）</h5>      <figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&quot;NSObject+MethodSwizzling.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">MethodSwizzling</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)sf_swizzlingClassMethod:(SEL)originalSel swizzledMethod:(SEL)swizzledMethod withClass:(Class)targetClass &#123;</span><br><span class="line">    swizzlingMethod(targetClass, <span class="literal">YES</span>, originalSel, swizzledMethod);</span><br><span class="line">&#125;</span><br><span class="line">+ (<span class="keyword">void</span>)sf_swizzlingInstanceMethod:(SEL)originalSel swizzledMethod:(SEL)swizzledMethod withClass:(Class)targetClass &#123;</span><br><span class="line">    swizzlingMethod(targetClass, <span class="literal">NO</span>, originalSel, swizzledMethod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 交换类方法</span></span><br><span class="line"><span class="comment">/// @param class 类/元类</span></span><br><span class="line"><span class="comment">/// @param originalSel 原方法</span></span><br><span class="line"><span class="comment">/// @param swizzledSel 交换方法</span></span><br><span class="line"><span class="keyword">void</span> swizzlingMethod(Class <span class="keyword">class</span>, <span class="built_in">BOOL</span> isMetaClass, SEL originalSel, SEL swizzledSel) &#123;</span><br><span class="line">    Method originalMethod;</span><br><span class="line">    Method swizzledMethod;</span><br><span class="line">    <span class="keyword">if</span> (isMetaClass) &#123;</span><br><span class="line">        originalMethod = class_getClassMethod(<span class="keyword">class</span>, originalSel);</span><br><span class="line">        swizzledMethod = class_getClassMethod(<span class="keyword">class</span>, swizzledSel);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        originalMethod = class_getInstanceMethod(<span class="keyword">class</span>, originalSel);</span><br><span class="line">        swizzledMethod = class_getInstanceMethod(<span class="keyword">class</span>, swizzledSel);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!originalMethod || !swizzledMethod) &#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="built_in">BOOL</span> didAddMethod = class_addMethod(<span class="keyword">class</span>,</span><br><span class="line">                                         originalSel,</span><br><span class="line">                                         method_getImplementation(swizzledMethod),</span><br><span class="line">                                         method_getTypeEncoding(swizzledMethod));</span><br><span class="line">    <span class="keyword">if</span> (didAddMethod) &#123;</span><br><span class="line">        class_replaceMethod(<span class="keyword">class</span>,</span><br><span class="line">                            swizzledSel,</span><br><span class="line">                            method_getImplementation(originalMethod),</span><br><span class="line">                            method_getTypeEncoding(originalMethod));</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></div></figure>        <h5 id="2、给NSObject新建个Category用于Crash防护（NSObject-UnrecognizedSelectorCrash）"   >          <a href="#2、给NSObject新建个Category用于Crash防护（NSObject-UnrecognizedSelectorCrash）" class="heading-link"><i class="fas fa-link"></i></a>2、给NSObject新建个Category用于Crash防护（NSObject+UnrecognizedSelectorCrash）</h5>      <figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&quot;NSObject+UnrecognizedSelectorCrash.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;NSObject+MethodSwizzling.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">UnrecognizedSelectorCrash</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG</span></span><br><span class="line">        </span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        <span class="comment">// 交换forwardingTargetForSelector:方法(实例方法和对象方法)</span></span><br><span class="line">        [<span class="built_in">NSObject</span> sf_swizzlingInstanceMethod:<span class="keyword">@selector</span>(forwardingTargetForSelector:) swizzledMethod:<span class="keyword">@selector</span>(sf_forwardingTargetForSelector:) withClass:[<span class="built_in">NSObject</span> <span class="keyword">class</span>]];</span><br><span class="line">        [<span class="built_in">NSObject</span> sf_swizzlingClassMethod:<span class="keyword">@selector</span>(forwardingTargetForSelector:) swizzledMethod:<span class="keyword">@selector</span>(sf_forwardingTargetForSelector:) withClass:[<span class="built_in">NSObject</span> <span class="keyword">class</span>]];</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)sf_forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="comment">// 1，判断当前类有没有重写forwardingTargetForSelector:方法</span></span><br><span class="line">    SEL forwarding_sel = <span class="keyword">@selector</span>(forwardingTargetForSelector:);</span><br><span class="line">    <span class="built_in">BOOL</span> override_forwarding = checkMethodOverride([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="literal">NO</span>, forwarding_sel);</span><br><span class="line">    <span class="keyword">if</span> (!override_forwarding) &#123;</span><br><span class="line">        <span class="comment">// 没有重写「备用接受者」</span></span><br><span class="line">        <span class="comment">// 2，判断当前类有没有重写methodSignatureForSelector:方法</span></span><br><span class="line">        SEL methodSignature_sel = <span class="keyword">@selector</span>(methodSignatureForSelector:);</span><br><span class="line">        <span class="built_in">BOOL</span> override_methodSignature = checkMethodOverride([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="literal">NO</span>, methodSignature_sel);</span><br><span class="line">        <span class="keyword">if</span> (!override_methodSignature) &#123;</span><br><span class="line">            <span class="comment">// 没有重写「方法签名」</span></span><br><span class="line">            <span class="comment">// 3，把消息转发到当前动态生成类的实例对象上</span></span><br><span class="line">            <span class="built_in">NSString</span> *className = <span class="string">@&quot;SFCrachInspector&quot;</span>;</span><br><span class="line">            Class cls = <span class="built_in">NSClassFromString</span>(className);</span><br><span class="line">            <span class="comment">// 如果类不存在 动态创建一个类</span></span><br><span class="line">            <span class="keyword">if</span> (!cls) &#123;</span><br><span class="line">                Class superClsss = [<span class="built_in">NSObject</span> <span class="keyword">class</span>];</span><br><span class="line">                cls = objc_allocateClassPair(superClsss, className.UTF8String, <span class="number">0</span>);</span><br><span class="line">                <span class="comment">// 注册类</span></span><br><span class="line">                objc_registerClassPair(cls);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果类没有对应的方法，则动态添加一个</span></span><br><span class="line">            <span class="keyword">if</span> (!class_getInstanceMethod(<span class="built_in">NSClassFromString</span>(className), aSelector)) &#123;</span><br><span class="line">                class_addMethod(cls, aSelector, (IMP)crash, <span class="string">&quot;@@:@&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 打印日志</span></span><br><span class="line">            printCrachMessage(<span class="keyword">self</span>, <span class="literal">NO</span>, aSelector);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> [[cls alloc] init];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> sf_forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line">+ (<span class="keyword">id</span>)sf_forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="comment">// 1，判断当前类有没有重写forwardingTargetForSelector:方法</span></span><br><span class="line">    SEL forwarding_sel = <span class="keyword">@selector</span>(forwardingTargetForSelector:);</span><br><span class="line">    <span class="built_in">BOOL</span> override_forwarding = checkMethodOverride([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="literal">YES</span>, forwarding_sel);</span><br><span class="line">    <span class="keyword">if</span> (!override_forwarding) &#123;</span><br><span class="line">        <span class="comment">// 没有重写「备用接受者」</span></span><br><span class="line">        <span class="comment">// 2，判断当前类有没有重写methodSignatureForSelector:方法</span></span><br><span class="line">        SEL methodSignature_sel = <span class="keyword">@selector</span>(methodSignatureForSelector:);</span><br><span class="line">        <span class="built_in">BOOL</span> override_methodSignature = checkMethodOverride([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="literal">YES</span>, methodSignature_sel);</span><br><span class="line">        <span class="keyword">if</span> (!override_methodSignature) &#123;</span><br><span class="line">            <span class="comment">// 没有重写「方法签名」</span></span><br><span class="line">            <span class="comment">// 3，把消息转发到当前动态生成类的实例对象上</span></span><br><span class="line">            <span class="built_in">NSString</span> *className = <span class="string">@&quot;SFCrachInspector&quot;</span>;</span><br><span class="line">            Class cls = <span class="built_in">NSClassFromString</span>(className);</span><br><span class="line">            <span class="comment">// 如果类不存在 动态创建一个类</span></span><br><span class="line">            <span class="keyword">if</span> (!cls) &#123;</span><br><span class="line">                Class superClsss = [<span class="built_in">NSObject</span> <span class="keyword">class</span>];</span><br><span class="line">                cls = objc_allocateClassPair(superClsss, className.UTF8String, <span class="number">0</span>);</span><br><span class="line">                <span class="comment">// 注册类</span></span><br><span class="line">                objc_registerClassPair(cls);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果类没有对应的方法，则动态添加一个</span></span><br><span class="line">            <span class="keyword">if</span> (!class_getInstanceMethod(<span class="built_in">NSClassFromString</span>(className), aSelector)) &#123;</span><br><span class="line">                class_addMethod(cls, aSelector, (IMP)crash, <span class="string">&quot;@@:@&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 打印日志</span></span><br><span class="line">            printCrachMessage(<span class="keyword">self</span>, <span class="literal">YES</span>, aSelector);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> [[cls alloc] init];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> sf_forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 判断方法是否重写过</span></span><br><span class="line"><span class="comment">/// @param class 类</span></span><br><span class="line"><span class="comment">/// @param isMetaClass 是否元类</span></span><br><span class="line"><span class="comment">/// @param aSelector 方法</span></span><br><span class="line"><span class="built_in">BOOL</span> checkMethodOverride(Class <span class="keyword">class</span>, <span class="built_in">BOOL</span> isMetaClass, SEL aSelector) &#123;</span><br><span class="line">    Method root_method;</span><br><span class="line">    Method current_method;</span><br><span class="line">    <span class="keyword">if</span> (isMetaClass) &#123;</span><br><span class="line">        root_method = class_getClassMethod([<span class="built_in">NSObject</span> <span class="keyword">class</span>], aSelector);</span><br><span class="line">        current_method = class_getClassMethod(<span class="keyword">class</span>, aSelector);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        root_method = class_getInstanceMethod([<span class="built_in">NSObject</span> <span class="keyword">class</span>], aSelector);</span><br><span class="line">        current_method = class_getInstanceMethod(<span class="keyword">class</span>, aSelector);</span><br><span class="line">    &#125;</span><br><span class="line">    IMP root_imp = method_getImplementation(root_method);</span><br><span class="line">    IMP current_imp = method_getImplementation(current_method);</span><br><span class="line">    <span class="keyword">return</span> root_imp != current_imp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态添加的方法实现</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> crash(<span class="keyword">id</span> slf, SEL selector) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 打印Crash日志</span></span><br><span class="line"><span class="comment">/// @param obj 对象（实例对象/类对象）</span></span><br><span class="line"><span class="comment">/// @param isMetaClass 是否元类</span></span><br><span class="line"><span class="comment">/// @param aSelector 方法</span></span><br><span class="line"><span class="keyword">void</span> printCrachMessage(<span class="keyword">id</span> obj, <span class="built_in">BOOL</span> isMetaClass, SEL aSelector) &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *errClassName = <span class="built_in">NSStringFromClass</span>([obj <span class="keyword">class</span>]);</span><br><span class="line">    <span class="built_in">NSString</span> *errSel = <span class="built_in">NSStringFromSelector</span>(aSelector);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;\n-------------------------SFCrash-------------------------\n Crash Message:\n %@[%@ %@]: unrecognized selector sent to %@ %p  \n---------------------------END---------------------------\n ***&quot;</span>,isMetaClass?<span class="string">@&quot;+&quot;</span>:<span class="string">@&quot;-&quot;</span>, errClassName, errSel, isMetaClass?<span class="string">@&quot;class&quot;</span>:<span class="string">@&quot;instance&quot;</span>, obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></div></figure><hr><p>[代码链接]<br/><br>GitHub：<span class="exturl"><a class="exturl__link"   href="https://github.com/jack110530/SFCrash" >https://github.com/jack110530/SFCrash</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><hr><p>[相关参考]<br/></p><ol><li><span class="exturl"><a class="exturl__link"   href="https://juejin.im/post/6844903922667094023" >iOS 开发：『Crash 防护系统』（一）Unrecognized Selector</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> </li><li><span class="exturl"><a class="exturl__link"   href="https://www.jianshu.com/p/f63395599633" >网易iOS App运行时Crash自动防护实践</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li></ol>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;/crash%E9%98%B2%E6%8A%A4-1-unrecognized-selector/%E9%87%8D%E6%8B%BEiOS.jpg&quot; class=&quot;&quot;&gt;
&lt;br&gt;

&lt;blockquote&gt;
&lt;p&gt;关键词：Unrecognized Selector、Runtime、Swizzling&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="重拾iOS" scheme="https://jack110530.github.io/categories/%E9%87%8D%E6%8B%BEiOS/"/>
    
    
    <category term="crash" scheme="https://jack110530.github.io/tags/crash/"/>
    
  </entry>
  
  <entry>
    <title>NSTimer和界面滑动冲突</title>
    <link href="https://jack110530.github.io/nstimer%E5%92%8C%E7%95%8C%E9%9D%A2%E6%BB%91%E5%8A%A8%E5%86%B2%E7%AA%81/"/>
    <id>https://jack110530.github.io/nstimer%E5%92%8C%E7%95%8C%E9%9D%A2%E6%BB%91%E5%8A%A8%E5%86%B2%E7%AA%81/</id>
    <published>2020-10-27T01:46:20.000Z</published>
    <updated>2020-10-27T02:08:47.259Z</updated>
    
    <content type="html"><![CDATA[<img src="/nstimer%E5%92%8C%E7%95%8C%E9%9D%A2%E6%BB%91%E5%8A%A8%E5%86%B2%E7%AA%81/%E9%87%8D%E6%8B%BEiOS.jpg" class=""><br><blockquote><p>关键词：NSTimer、CADisplayLink、GCD、RunLoop、多线程</p></blockquote><a id="more"></a>        <h3 id="前言"   >          <a href="#前言" class="heading-link"><i class="fas fa-link"></i></a>前言</h3>      <ol><li>在滑动页面上的列表时，NSTimer会暂停，为什么？该如何解决？</li></ol>        <h3 id="一、原因"   >          <a href="#一、原因" class="heading-link"><i class="fas fa-link"></i></a>一、原因</h3>      <p>原因在于滑动时当前线程的runloop切换了mode用于列表滑动，导致timer暂停。<br></p><p>runloop中的mode主要用来指定事件在runloop中的优先级，有以下几种：</p><ul><li>Default（NSDefaultRunLoopMode）：默认，一般情况下使用；</li><li>Connection（NSConnectionReplyMode）：一般系统用来处理NSConnection相关事件，开发者一般用不到；</li><li>Modal（NSModalPanelRunLoopMode）：处理modal panels事件；</li><li>Event Tracking（NSEventTrackingRunLoopMode）：用于处理拖拽和用户交互的模式。</li><li>Common（NSRunloopCommonModes）：模式合集。默认包括Default，Modal，Event Tracking三大模式，可以处理几乎所有事件。</li></ul><p>回到题中的情境。滑动列表时，runloop的mode由原来的Default模式切换到了Event Tracking模式，timer原来好好的运行在Default模式中，被关闭后自然就停止工作了。</p><p><strong>注意：</strong><br><br>在NSTimer的初始化方法中，以scheduled开头的方法，timer默认已经添加到了当前RunLoop中（以default mode形式添加）</p>        <h3 id="二、解决方案"   >          <a href="#二、解决方案" class="heading-link"><i class="fas fa-link"></i></a>二、解决方案</h3>              <h4 id="1、将timer加入到NSRunloopCommonModes中"   >          <a href="#1、将timer加入到NSRunloopCommonModes中" class="heading-link"><i class="fas fa-link"></i></a>1、将timer加入到NSRunloopCommonModes中</h4>      <figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class="built_in">NSRunLoopCommonModes</span>];</span><br></pre></td></tr></table></div></figure>        <h4 id="2、将timer放到另一个线程中，然后开启另一个线程的runloop，这样可以保证与主线程互不干扰"   >          <a href="#2、将timer放到另一个线程中，然后开启另一个线程的runloop，这样可以保证与主线程互不干扰" class="heading-link"><i class="fas fa-link"></i></a>2、将timer放到另一个线程中，然后开启另一个线程的runloop，这样可以保证与主线程互不干扰</h4>      <figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">    timer = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">1</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(repeat:) userInfo:<span class="literal">nil</span> repeats:<span class="literal">true</span>];</span><br><span class="line">    [[<span class="built_in">NSRunLoop</span> currentRunLoop] run];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></div></figure>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;/nstimer%E5%92%8C%E7%95%8C%E9%9D%A2%E6%BB%91%E5%8A%A8%E5%86%B2%E7%AA%81/%E9%87%8D%E6%8B%BEiOS.jpg&quot; class=&quot;&quot;&gt;
&lt;br&gt;

&lt;blockquote&gt;
&lt;p&gt;关键词：NSTimer、CADisplayLink、GCD、RunLoop、多线程&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="重拾iOS" scheme="https://jack110530.github.io/categories/%E9%87%8D%E6%8B%BEiOS/"/>
    
    
    <category term="timer" scheme="https://jack110530.github.io/tags/timer/"/>
    
  </entry>
  
  <entry>
    <title>定时器</title>
    <link href="https://jack110530.github.io/%E5%AE%9A%E6%97%B6%E5%99%A8/"/>
    <id>https://jack110530.github.io/%E5%AE%9A%E6%97%B6%E5%99%A8/</id>
    <published>2020-10-24T03:47:55.000Z</published>
    <updated>2020-10-27T03:54:53.920Z</updated>
    
    <content type="html"><![CDATA[<img src="/%E5%AE%9A%E6%97%B6%E5%99%A8/%E9%87%8D%E6%8B%BEiOS.jpg" class=""><br><blockquote><p>关键词：NSTimer、CADisplayLink、GCD、RunLoop</p></blockquote><a id="more"></a>        <h3 id="前言"   >          <a href="#前言" class="heading-link"><i class="fas fa-link"></i></a>前言</h3>      <ol><li>开发中常用的定时器有哪些，优缺点是什么？</li><li>定时器的循环引用问题怎么解决？</li><li>CADisplayLink、NSTimer是否准时？</li></ol>        <h3 id="一、NSTimer和CADisplayLink"   >          <a href="#一、NSTimer和CADisplayLink" class="heading-link"><i class="fas fa-link"></i></a>一、NSTimer和CADisplayLink</h3>              <h4 id="1、NSTimer"   >          <a href="#1、NSTimer" class="heading-link"><i class="fas fa-link"></i></a>1、NSTimer</h4>      <p>常用api有：</p><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSTimer</span> *)timerWithTimeInterval:(<span class="built_in">NSTimeInterval</span>)ti invocation:(<span class="built_in">NSInvocation</span> *)invocation repeats:(<span class="built_in">BOOL</span>)yesOrNo;</span><br><span class="line">+ (<span class="built_in">NSTimer</span> *)scheduledTimerWithTimeInterval:(<span class="built_in">NSTimeInterval</span>)ti invocation:(<span class="built_in">NSInvocation</span> *)invocation repeats:(<span class="built_in">BOOL</span>)yesOrNo;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSTimer</span> *)timerWithTimeInterval:(<span class="built_in">NSTimeInterval</span>)ti target:(<span class="keyword">id</span>)aTarget selector:(SEL)aSelector userInfo:(<span class="keyword">nullable</span> <span class="keyword">id</span>)userInfo repeats:(<span class="built_in">BOOL</span>)yesOrNo;</span><br><span class="line">+ (<span class="built_in">NSTimer</span> *)scheduledTimerWithTimeInterval:(<span class="built_in">NSTimeInterval</span>)ti target:(<span class="keyword">id</span>)aTarget selector:(SEL)aSelector userInfo:(<span class="keyword">nullable</span> <span class="keyword">id</span>)userInfo repeats:(<span class="built_in">BOOL</span>)yesOrNo;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/// Creates and returns a new NSTimer object initialized with the specified block object. This timer needs to be scheduled on a run loop (via -[NSRunLoop addTimer:]) before it will fire.</span></span><br><span class="line"><span class="comment">/// - parameter:  timeInterval  The number of seconds between firings of the timer. If seconds is less than or equal to 0.0, this method chooses the nonnegative value of 0.1 milliseconds instead</span></span><br><span class="line"><span class="comment">/// - parameter:  repeats  If YES, the timer will repeatedly reschedule itself until invalidated. If NO, the timer will be invalidated after it fires.</span></span><br><span class="line"><span class="comment">/// - parameter:  block  The execution body of the timer; the timer itself is passed as the parameter to this block when executed to aid in avoiding cyclical references</span></span><br><span class="line">+ (<span class="built_in">NSTimer</span> *)timerWithTimeInterval:(<span class="built_in">NSTimeInterval</span>)interval repeats:(<span class="built_in">BOOL</span>)repeats block:(<span class="keyword">void</span> (^)(<span class="built_in">NSTimer</span> *timer))block API_AVAILABLE(macosx(<span class="number">10.12</span>), ios(<span class="number">10.0</span>), watchos(<span class="number">3.0</span>), tvos(<span class="number">10.0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Creates and returns a new NSTimer object initialized with the specified block object and schedules it on the current run loop in the default mode.</span></span><br><span class="line"><span class="comment">/// - parameter:  ti    The number of seconds between firings of the timer. If seconds is less than or equal to 0.0, this method chooses the nonnegative value of 0.1 milliseconds instead</span></span><br><span class="line"><span class="comment">/// - parameter:  repeats  If YES, the timer will repeatedly reschedule itself until invalidated. If NO, the timer will be invalidated after it fires.</span></span><br><span class="line"><span class="comment">/// - parameter:  block  The execution body of the timer; the timer itself is passed as the parameter to this block when executed to aid in avoiding cyclical references</span></span><br><span class="line">+ (<span class="built_in">NSTimer</span> *)scheduledTimerWithTimeInterval:(<span class="built_in">NSTimeInterval</span>)interval repeats:(<span class="built_in">BOOL</span>)repeats block:(<span class="keyword">void</span> (^)(<span class="built_in">NSTimer</span> *timer))block API_AVAILABLE(macosx(<span class="number">10.12</span>), ios(<span class="number">10.0</span>), watchos(<span class="number">3.0</span>), tvos(<span class="number">10.0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Initializes a new NSTimer object using the block as the main body of execution for the timer. This timer needs to be scheduled on a run loop (via -[NSRunLoop addTimer:]) before it will fire.</span></span><br><span class="line"><span class="comment">/// - parameter:  fireDate   The time at which the timer should first fire.</span></span><br><span class="line"><span class="comment">/// - parameter:  interval  The number of seconds between firings of the timer. If seconds is less than or equal to 0.0, this method chooses the nonnegative value of 0.1 milliseconds instead</span></span><br><span class="line"><span class="comment">/// - parameter:  repeats  If YES, the timer will repeatedly reschedule itself until invalidated. If NO, the timer will be invalidated after it fires.</span></span><br><span class="line"><span class="comment">/// - parameter:  block  The execution body of the timer; the timer itself is passed as the parameter to this block when executed to aid in avoiding cyclical references</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithFireDate:(<span class="built_in">NSDate</span> *)date interval:(<span class="built_in">NSTimeInterval</span>)interval repeats:(<span class="built_in">BOOL</span>)repeats block:(<span class="keyword">void</span> (^)(<span class="built_in">NSTimer</span> *timer))block API_AVAILABLE(macosx(<span class="number">10.12</span>), ios(<span class="number">10.0</span>), watchos(<span class="number">3.0</span>), tvos(<span class="number">10.0</span>));</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithFireDate:(<span class="built_in">NSDate</span> *)date interval:(<span class="built_in">NSTimeInterval</span>)ti target:(<span class="keyword">id</span>)t selector:(SEL)s userInfo:(<span class="keyword">nullable</span> <span class="keyword">id</span>)ui repeats:(<span class="built_in">BOOL</span>)rep <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)fire;</span><br></pre></td></tr></table></div></figure><p>在NSTimer的初始化方法中，以scheduled开头的方法，timer默认已经添加到了当前RunLoop中（以default mode形式添加）<br/></p>        <h4 id="2、CADisplayLink"   >          <a href="#2、CADisplayLink" class="heading-link"><i class="fas fa-link"></i></a>2、CADisplayLink</h4>      <p>常用api有：</p><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Create a new display link object for the main display. It will</span></span><br><span class="line"><span class="comment"> * invoke the method called &#x27;sel&#x27; on &#x27;target&#x27;, the method has the</span></span><br><span class="line"><span class="comment"> * signature &#x27;(void)selector:(CADisplayLink *)sender&#x27;. */</span></span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">CADisplayLink</span> *)displayLinkWithTarget:(<span class="keyword">id</span>)target selector:(SEL)sel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Adds the receiver to the given run-loop and mode. Unless paused, it</span></span><br><span class="line"><span class="comment"> * will fire every vsync until removed. Each object may only be added</span></span><br><span class="line"><span class="comment"> * to a single run-loop, but it may be added in multiple modes at once.</span></span><br><span class="line"><span class="comment"> * While added to a run-loop it will implicitly be retained. */</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)addToRunLoop:(<span class="built_in">NSRunLoop</span> *)runloop forMode:(<span class="built_in">NSRunLoopMode</span>)mode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Removes the receiver from the given mode of the runloop. This will</span></span><br><span class="line"><span class="comment"> * implicitly release it when removed from the last mode it has been</span></span><br><span class="line"><span class="comment"> * registered for. */</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)removeFromRunLoop:(<span class="built_in">NSRunLoop</span> *)runloop forMode:(<span class="built_in">NSRunLoopMode</span>)mode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Removes the object from all runloop modes (releasing the receiver if</span></span><br><span class="line"><span class="comment"> * it has been implicitly retained) and releases the &#x27;target&#x27; object. */</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)invalidate;</span><br></pre></td></tr></table></div></figure>        <h3 id="二、定时器循环引用问题的解决方案"   >          <a href="#二、定时器循环引用问题的解决方案" class="heading-link"><i class="fas fa-link"></i></a>二、定时器循环引用问题的解决方案</h3>              <h4 id="1、使用block方式初始化NSTimer；"   >          <a href="#1、使用block方式初始化NSTimer；" class="heading-link"><i class="fas fa-link"></i></a>1、使用block方式初始化NSTimer；</h4>              <h4 id="2、使用中间层WeakContainer；"   >          <a href="#2、使用中间层WeakContainer；" class="heading-link"><i class="fas fa-link"></i></a>2、使用中间层WeakContainer；</h4>      <p>代码示例：<br/><br>新建SFWeakContainer类<br></p><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SFWeakContainer</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithTarget:(<span class="built_in">NSObject</span> *)target;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)containerWithTarget:(<span class="built_in">NSObject</span> *)target;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// .m</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SFWeakContainer</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="built_in">NSObject</span> *target;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SFWeakContainer</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithTarget:(<span class="built_in">NSObject</span> *)target &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        <span class="keyword">self</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)containerWithTarget:(<span class="built_in">NSObject</span> *)target &#123;</span><br><span class="line">    SFWeakContainer *container = [[SFWeakContainer alloc]initWithTarget:target];</span><br><span class="line">    <span class="keyword">return</span> container;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 备用接受者</span></span><br><span class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.target &amp;&amp; [<span class="keyword">self</span>.target respondsToSelector:aSelector]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.target;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="keyword">super</span> forwardingTargetForSelector:aSelector];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></div></figure><p>测试：</p><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="keyword">self</span>.view.backgroundColor = [<span class="built_in">UIColor</span> whiteColor];</span><br><span class="line">    SFWeakContainer *weakContainer = [SFWeakContainer containerWithTarget:<span class="keyword">self</span>];</span><br><span class="line">    <span class="keyword">self</span>.timer = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">1</span> target:weakContainer selector:<span class="keyword">@selector</span>(timerEvent:) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)timerEvent:(<span class="built_in">NSTimer</span> *)timer &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;定时器事件&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    [<span class="keyword">self</span>.timer invalidate];</span><br><span class="line">    <span class="keyword">self</span>.timer = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h4 id="3、NSProxy消息转发；"   >          <a href="#3、NSProxy消息转发；" class="heading-link"><i class="fas fa-link"></i></a>3、NSProxy消息转发；</h4>      <p>代码示例：<br/><br>新建SFProxy<br/></p><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SFProxy</span> : <span class="title">NSProxy</span></span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithTarget:(<span class="keyword">id</span>)target;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)proxyWithTarget:(<span class="keyword">id</span>)target;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// .m</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SFProxy</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="built_in">NSObject</span> *target;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SFProxy</span></span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithTarget:(<span class="keyword">id</span>)target &#123;</span><br><span class="line">    _target = target;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)proxyWithTarget:(<span class="keyword">id</span>)target &#123;</span><br><span class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span> alloc] initWithTarget:target];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息转发</span></span><br><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.target &amp;&amp; [<span class="keyword">self</span>.target respondsToSelector:aSelector]) &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="keyword">self</span>.target methodSignatureForSelector:aSelector];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> methodSignatureForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation&#123;</span><br><span class="line">    SEL aSelector = [anInvocation selector];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.target &amp;&amp; [<span class="keyword">self</span>.target respondsToSelector:aSelector]) &#123;</span><br><span class="line">        [anInvocation invokeWithTarget:<span class="keyword">self</span>.target];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [<span class="keyword">super</span> forwardInvocation:anInvocation];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></div></figure><p>测试：</p><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="keyword">self</span>.view.backgroundColor = [<span class="built_in">UIColor</span> whiteColor];</span><br><span class="line">    SFProxy *proxy = [SFProxy proxyWithTarget:<span class="keyword">self</span>];</span><br><span class="line">    <span class="keyword">self</span>.timer = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">1</span> target:proxy selector:<span class="keyword">@selector</span>(timerEvent:) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)timerEvent:(<span class="built_in">NSTimer</span> *)timer &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;定时器事件&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    [<span class="keyword">self</span>.timer invalidate];</span><br><span class="line">    <span class="keyword">self</span>.timer = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>具体怎么做，根据个人喜好选择，我这里有一个写好的方案：<a href="">Crash防护(4)-NSTimer</a></p>        <h3 id="三、CADisplayLink、NSTimer是否准时？"   >          <a href="#三、CADisplayLink、NSTimer是否准时？" class="heading-link"><i class="fas fa-link"></i></a>三、CADisplayLink、NSTimer是否准时？</h3>      <p>CADisplayLink、NSTimer底层都是靠RunLoop来实现的，也就是可以把它们理解成RunLoop所需要处理的事件。我们知道RunLoop可以拿来刷新UI，处理定时器（CADisplayLink、NSTimer），处理点击滑动事件等非常多的事情。这里，就需要来了解一下RunLoop是如何触发NSTimer任务的。RunLoop每循环一圈，都会处理一定的事件，会消耗一定的时间，但是具体耗时多少这个是无法确定的。<br/></p><p>假如你开启一个timer，隔1秒触发定时器事件，RunLoop会开始累计每一圈循环的用时，当时间累计够1秒，就会触发定时器事件。你有兴趣的话，是可以在RunLoop的源码里面找到时间累加相关代码的。可以借助下图来加深理解:<br/></p><img src="/%E5%AE%9A%E6%97%B6%E5%99%A8/runloop1.png" class=""><p>如果RunLoop在某一圈任务过于繁重，就可能出现如下情况</p><img src="/%E5%AE%9A%E6%97%B6%E5%99%A8/runloop2.png" class=""><p>所以CADisplayLink、NSTimer是无法保证准时性的。</p>        <h3 id="四、GCD-Timer"   >          <a href="#四、GCD-Timer" class="heading-link"><i class="fas fa-link"></i></a>四、GCD Timer</h3>              <h4 id="1、GCD-Timer-的简单使用"   >          <a href="#1、GCD-Timer-的简单使用" class="heading-link"><i class="fas fa-link"></i></a>1、GCD Timer 的简单使用</h4>      <figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) dispatch_source_t timer;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">// 初始化定时器</span></span><br><span class="line">    <span class="keyword">self</span>.timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="number">0</span>, <span class="number">0</span>, dispatch_get_main_queue());</span><br><span class="line">    <span class="comment">// 间隔时间</span></span><br><span class="line">    uint64_t intervalTime = <span class="number">1.0</span>;</span><br><span class="line">    <span class="comment">//误差时间</span></span><br><span class="line">    uint64_t leewayTime = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 延迟时间</span></span><br><span class="line">    uint64_t delayTime = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 开始时间</span></span><br><span class="line">    dispatch_time_t startTime = dispatch_time(DISPATCH_TIME_NOW, delayTime*<span class="built_in">NSEC_PER_SEC</span>);</span><br><span class="line">    <span class="comment">// 设置定时器时间</span></span><br><span class="line">    dispatch_source_set_timer(<span class="keyword">self</span>.timer, startTime, intervalTime * <span class="built_in">NSEC_PER_SEC</span>, leewayTime * <span class="built_in">NSEC_PER_SEC</span>);</span><br><span class="line">    <span class="comment">// 设置定时器回调事件</span></span><br><span class="line">    dispatch_source_set_event_handler(<span class="keyword">self</span>.timer, ^&#123;</span><br><span class="line">        <span class="comment">// 定时器事件代码</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;GCD定时器事件&quot;</span>);</span><br><span class="line">        <span class="comment">// 如果定时器不需要重复，可以在这里取消定时器</span></span><br><span class="line">        dispatch_source_cancel(<span class="keyword">self</span>.timer);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 运行定时器</span></span><br><span class="line">    dispatch_resume(<span class="keyword">self</span>.timer);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h4 id="2、GCD-Timer-的封装"   >          <a href="#2、GCD-Timer-的封装" class="heading-link"><i class="fas fa-link"></i></a>2、GCD Timer 的封装</h4>      <p>代码如下：<br/></p><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&quot;SFGcdTimer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SFGcdTimer</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) dispatch_source_t timer;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">dispatch_queue_t</span> queue;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 提问：苹果为什么要把NSTimer中的target设计成强引用关系，既然他会导致循环引用问题，为什么苹果不直接将NSTimer的target设计成弱引用关系？</span></span><br><span class="line"><span class="comment"> * 所以这里保留跟NSTimer类似的设计</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSObject</span> *target;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">retain</span>) <span class="keyword">id</span> userInfo;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSTimeInterval</span> timeInterval;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SFGcdTimer</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: target方式</span></span><br><span class="line"><span class="comment">/// 初始化方法（target）</span></span><br><span class="line"><span class="comment">/// @param interval 时间间隔</span></span><br><span class="line"><span class="comment">/// @param delay 延迟时间</span></span><br><span class="line"><span class="comment">/// @param aTarget 执行对象</span></span><br><span class="line"><span class="comment">/// @param aSelector 执行方法</span></span><br><span class="line"><span class="comment">/// @param userInfo 附带信息</span></span><br><span class="line"><span class="comment">/// @param repeats 是否重复</span></span><br><span class="line">+ (SFGcdTimer *)timerWithTimeInterval:(<span class="built_in">NSTimeInterval</span>)interval delay:(<span class="built_in">NSTimeInterval</span>)delay target:(<span class="keyword">id</span>)aTarget selector:(SEL)aSelector userInfo:(<span class="keyword">nullable</span> <span class="keyword">id</span>)userInfo repeats:(<span class="built_in">BOOL</span>)repeats  &#123;</span><br><span class="line">    SFGcdTimer *timer = [[SFGcdTimer alloc] initWithTimeInterval:interval delay:delay target:aTarget selector:aSelector userInfo:userInfo repeats:repeats queue:<span class="literal">nil</span>];</span><br><span class="line">    <span class="keyword">return</span> timer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 初始化方法（target）</span></span><br><span class="line"><span class="comment">/// @param interval 时间间隔</span></span><br><span class="line"><span class="comment">/// @param delay 延迟时间</span></span><br><span class="line"><span class="comment">/// @param aTarget 执行对象</span></span><br><span class="line"><span class="comment">/// @param aSelector 执行方法</span></span><br><span class="line"><span class="comment">/// @param userInfo 附带信息</span></span><br><span class="line"><span class="comment">/// @param repeats 是否重复</span></span><br><span class="line"><span class="comment">/// @param queue 指定队列（默认主队列）</span></span><br><span class="line">+ (SFGcdTimer *)timerWithTimeInterval:(<span class="built_in">NSTimeInterval</span>)interval delay:(<span class="built_in">NSTimeInterval</span>)delay target:(<span class="keyword">id</span>)aTarget selector:(SEL)aSelector userInfo:(<span class="keyword">nullable</span> <span class="keyword">id</span>)userInfo repeats:(<span class="built_in">BOOL</span>)repeats queue:(<span class="built_in">dispatch_queue_t</span>)queue &#123;</span><br><span class="line">    SFGcdTimer *timer = [[SFGcdTimer alloc] initWithTimeInterval:interval delay:delay target:aTarget selector:aSelector userInfo:userInfo repeats:repeats queue:queue];</span><br><span class="line">    <span class="keyword">return</span> timer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 初始化方法（target）</span></span><br><span class="line"><span class="comment">/// @param interval 时间间隔</span></span><br><span class="line"><span class="comment">/// @param delay 延迟时间</span></span><br><span class="line"><span class="comment">/// @param aTarget 执行对象</span></span><br><span class="line"><span class="comment">/// @param aSelector 执行方法</span></span><br><span class="line"><span class="comment">/// @param userInfo 附带信息</span></span><br><span class="line"><span class="comment">/// @param repeats 是否重复</span></span><br><span class="line"><span class="comment">/// @param queue 指定队列（默认主队列）</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithTimeInterval:(<span class="built_in">NSTimeInterval</span>)interval delay:(<span class="built_in">NSTimeInterval</span>)delay target:(<span class="keyword">id</span>)aTarget selector:(SEL)aSelector userInfo:(<span class="keyword">nullable</span> <span class="keyword">id</span>)userInfo repeats:(<span class="built_in">BOOL</span>)repeats queue:(<span class="built_in">dispatch_queue_t</span>)queue &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        <span class="keyword">self</span>.timeInterval = interval;</span><br><span class="line">        <span class="keyword">self</span>.queue = queue;</span><br><span class="line">        <span class="keyword">self</span>.target = aTarget;</span><br><span class="line">        <span class="keyword">self</span>.userInfo = userInfo;</span><br><span class="line">        <span class="keyword">self</span>.timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">self</span>.queue);</span><br><span class="line">        dispatch_source_set_timer(<span class="keyword">self</span>.timer,</span><br><span class="line">                                  dispatch_time(DISPATCH_TIME_NOW, delay * <span class="built_in">NSEC_PER_SEC</span>), <span class="comment">// 开始时间</span></span><br><span class="line">                                  interval * <span class="built_in">NSEC_PER_SEC</span>, <span class="comment">// 间隔</span></span><br><span class="line">                                  <span class="number">0</span> <span class="comment">// 误差</span></span><br><span class="line">                                  );</span><br><span class="line">        dispatch_source_set_event_handler(<span class="keyword">self</span>.timer, ^&#123;</span><br><span class="line">            <span class="keyword">if</span> ([<span class="keyword">self</span>.target respondsToSelector:aSelector]) &#123;</span><br><span class="line">                [<span class="keyword">self</span>.target performSelector:aSelector withObject:<span class="keyword">self</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!repeats) &#123;</span><br><span class="line">                [<span class="keyword">self</span> invalidate];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: block方式</span></span><br><span class="line"><span class="comment">/// 初始化方法（block）</span></span><br><span class="line"><span class="comment">/// @param interval 时间间隔</span></span><br><span class="line"><span class="comment">/// @param delay 延迟时间</span></span><br><span class="line"><span class="comment">/// @param repeats 是否重复</span></span><br><span class="line"><span class="comment">/// @param block 执行block</span></span><br><span class="line">+ (SFGcdTimer *)timerWithTimeInterval:(<span class="built_in">NSTimeInterval</span>)interval delay:(<span class="built_in">NSTimeInterval</span>)delay repeats:(<span class="built_in">BOOL</span>)repeats block:(<span class="keyword">void</span> (^)(SFGcdTimer *timer))block &#123;</span><br><span class="line">    SFGcdTimer *timer = [[SFGcdTimer alloc]initWithTimeInterval:interval delay:delay repeats:repeats block:block queue:<span class="literal">nil</span>];</span><br><span class="line">    <span class="keyword">return</span> timer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 初始化方法（block）</span></span><br><span class="line"><span class="comment">/// @param interval 时间间隔</span></span><br><span class="line"><span class="comment">/// @param delay 延迟时间</span></span><br><span class="line"><span class="comment">/// @param repeats 是否重复</span></span><br><span class="line"><span class="comment">/// @param block 执行block</span></span><br><span class="line"><span class="comment">/// @param queue 执行队列（默认主队列）</span></span><br><span class="line">+ (SFGcdTimer *)timerWithTimeInterval:(<span class="built_in">NSTimeInterval</span>)interval delay:(<span class="built_in">NSTimeInterval</span>)delay repeats:(<span class="built_in">BOOL</span>)repeats block:(<span class="keyword">void</span> (^)(SFGcdTimer *timer))block queue:(<span class="built_in">dispatch_queue_t</span>)queue &#123;</span><br><span class="line">    SFGcdTimer *timer = [[SFGcdTimer alloc]initWithTimeInterval:interval delay:delay repeats:repeats block:block queue:queue];</span><br><span class="line">    <span class="keyword">return</span> timer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 初始化方法（block）</span></span><br><span class="line"><span class="comment">/// @param interval 时间间隔</span></span><br><span class="line"><span class="comment">/// @param delay 延迟时间</span></span><br><span class="line"><span class="comment">/// @param repeats 是否重复</span></span><br><span class="line"><span class="comment">/// @param block 执行block</span></span><br><span class="line"><span class="comment">/// @param queue 执行队列（默认主队列）</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithTimeInterval:(<span class="built_in">NSTimeInterval</span>)interval delay:(<span class="built_in">NSTimeInterval</span>)delay repeats:(<span class="built_in">BOOL</span>)repeats block:(<span class="keyword">void</span> (^)(SFGcdTimer *timer))block queue:(<span class="built_in">dispatch_queue_t</span>)queue &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        <span class="keyword">self</span>.timeInterval = interval;</span><br><span class="line">        <span class="keyword">self</span>.queue = queue;</span><br><span class="line">        <span class="keyword">self</span>.timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">self</span>.queue);</span><br><span class="line">        dispatch_source_set_timer(<span class="keyword">self</span>.timer,</span><br><span class="line">                                  dispatch_time(DISPATCH_TIME_NOW, delay * <span class="built_in">NSEC_PER_SEC</span>), <span class="comment">// 开始时间</span></span><br><span class="line">                                  interval * <span class="built_in">NSEC_PER_SEC</span>, <span class="comment">// 间隔</span></span><br><span class="line">                                  <span class="number">0</span> <span class="comment">// 误差</span></span><br><span class="line">                                  );</span><br><span class="line">        dispatch_source_set_event_handler(<span class="keyword">self</span>.timer, ^&#123;</span><br><span class="line">            <span class="keyword">if</span> (block) &#123;</span><br><span class="line">                block(<span class="keyword">self</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!repeats) &#123;</span><br><span class="line">                [<span class="keyword">self</span> invalidate];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 开启</span></span><br><span class="line">- (<span class="keyword">void</span>)fire &#123;</span><br><span class="line">    dispatch_resume(<span class="keyword">self</span>.timer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 暂停</span></span><br><span class="line">- (<span class="keyword">void</span>)pause &#123;</span><br><span class="line">    dispatch_suspend(<span class="keyword">self</span>.timer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 销毁</span></span><br><span class="line">- (<span class="keyword">void</span>)invalidate &#123;</span><br><span class="line">    dispatch_source_cancel(<span class="keyword">self</span>.timer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - lazy load</span></span><br><span class="line"><span class="comment">// 默认主队列</span></span><br><span class="line">- (<span class="built_in">dispatch_queue_t</span>)queue &#123;</span><br><span class="line">    <span class="keyword">if</span> (!_queue) &#123;</span><br><span class="line">        _queue = dispatch_get_main_queue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _queue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></div></figure><hr><p>[代码链接]<br/><br>GitHub：<span class="exturl"><a class="exturl__link"   href="https://github.com/jack110530/SFCrash" >https://github.com/jack110530/SFCrash</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><hr><p>[相关参考]<br/></p><ol><li><span class="exturl"><a class="exturl__link"   href="https://juejin.im/post/6844904033824538638" >比较一下iOS中的三种定时器</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> </li><li><span class="exturl"><a class="exturl__link"   href="https://blog.csdn.net/u013480070/article/details/100154694" >内存管理——定时器问题</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li></ol><p>[相关思考]<br/></p><ol><li>NSTimer和线程的关系</li><li>苹果为什么要把NSTimer中的target设计成强引用关系，既然他会导致循环引用问题，为什么苹果不直接将NSTimer的target设计成弱引用关系？</li></ol>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;/%E5%AE%9A%E6%97%B6%E5%99%A8/%E9%87%8D%E6%8B%BEiOS.jpg&quot; class=&quot;&quot;&gt;
&lt;br&gt;

&lt;blockquote&gt;
&lt;p&gt;关键词：NSTimer、CADisplayLink、GCD、RunLoop&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="重拾iOS" scheme="https://jack110530.github.io/categories/%E9%87%8D%E6%8B%BEiOS/"/>
    
    
    <category term="timer" scheme="https://jack110530.github.io/tags/timer/"/>
    
  </entry>
  
</feed>

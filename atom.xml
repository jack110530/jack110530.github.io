<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>jack110530的博客</title>
  
  <subtitle>路漫漫其修远兮，吾将上下而求索。</subtitle>
  <link href="https://jack110530.github.io/atom.xml" rel="self"/>
  
  <link href="https://jack110530.github.io/"/>
  <updated>2020-12-15T02:03:24.066Z</updated>
  <id>https://jack110530.github.io/</id>
  
  <author>
    <name>jack110530</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RAC(1)基础入门</title>
    <link href="https://jack110530.github.io/rac-1-%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    <id>https://jack110530.github.io/rac-1-%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/</id>
    <published>2020-12-14T07:24:10.000Z</published>
    <updated>2020-12-15T02:03:24.066Z</updated>
    
    <content type="html"><![CDATA[<img src="/rac-1-%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/RAC.jpg" class=""><blockquote><p>关键词：rac</p></blockquote><a id="more"></a>        <h4 id="前言"   >          <a href="#前言" class="heading-link"><i class="fas fa-link"></i></a>前言</h4>      <p>个人认为，学习一个新东西时，最好的方式是先学会去使用它。先对它的“功能”有个简单的认识，知道他的应用场景，等接触时间长了，再慢慢的对它的底层原理进行一个探索。<br><br>所以，今天呢，先来几个小demo，对RAC有个简单的认识。<br><br>那么，就开始吧…<br></p>        <h4 id="正文"   >          <a href="#正文" class="heading-link"><i class="fas fa-link"></i></a>正文</h4>              <h5 id="1，监听方法"   >          <a href="#1，监听方法" class="heading-link"><i class="fas fa-link"></i></a>1，监听方法</h5>      <p>直接上代码：<br></p><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SFViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="keyword">self</span>.view.backgroundColor = [<span class="built_in">UIColor</span> whiteColor];</span><br><span class="line">    <span class="comment">// 创建信号量</span></span><br><span class="line">    RACSignal *signal = [<span class="keyword">self</span> rac_signalForSelector:<span class="keyword">@selector</span>(testFunc:)];</span><br><span class="line">    <span class="comment">// 订阅信号量</span></span><br><span class="line">    [signal subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>,x);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)testFunc:(<span class="built_in">NSInteger</span>)i &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>,__func__);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>,__func__);</span><br><span class="line">    [<span class="keyword">self</span> testFunc:<span class="number">10</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></div></figure><p>测试发现，当我们点击屏幕时，会有如下打印：</p><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">OCTestDemo[<span class="number">37634</span>:<span class="number">572271</span>] -[SFViewController touchesBegan:withEvent:]</span><br><span class="line">OCTestDemo[<span class="number">37634</span>:<span class="number">572271</span>] -[SFViewController testFunc:]</span><br><span class="line">OCTestDemo[<span class="number">37634</span>:<span class="number">572271</span>] &lt;RACTuple: <span class="number">0x600002dde3d0</span>&gt; (</span><br><span class="line">    <span class="number">10</span></span><br><span class="line">)</span><br></pre></td></tr></table></div></figure><p>由此可知，我们已经成功的监听到了<code>testFunc:</code>方法的响应了。是不是很棒😊<br></p>        <h5 id="2，UIButton的响应事件监听"   >          <a href="#2，UIButton的响应事件监听" class="heading-link"><i class="fas fa-link"></i></a>2，UIButton的响应事件监听</h5>      <p>通常我们想给一个UIButton添加点击事件时，可能会这么写：<br></p><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="keyword">self</span>.view.backgroundColor = [<span class="built_in">UIColor</span> whiteColor];</span><br><span class="line">    [<span class="keyword">self</span>.view addSubview:<span class="keyword">self</span>.signInBtn];</span><br><span class="line">    [<span class="keyword">self</span>.signInBtn addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(signInBtnEvent:) forControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)signInBtnEvent:(<span class="built_in">UIButton</span> *)sender &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="built_in">UIButton</span> *)signInBtn &#123;</span><br><span class="line">    <span class="keyword">if</span> (!_signInBtn) &#123;</span><br><span class="line">        _signInBtn = [<span class="built_in">UIButton</span> buttonWithType:<span class="built_in">UIButtonTypeCustom</span>];</span><br><span class="line">        _signInBtn.frame = <span class="built_in">CGRectMake</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">        _signInBtn.backgroundColor = [<span class="built_in">UIColor</span> orangeColor];</span><br><span class="line">        [_signInBtn setTitle:<span class="string">@&quot;登录&quot;</span> forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _signInBtn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>首先，这么写当然没有什么问题。<br><br>那么，还有什么可看的呢，rac能有什么独特的地方？<br><br>我们带着疑问，来看一下rac中的写法:<br></p><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="keyword">self</span>.view.backgroundColor = [<span class="built_in">UIColor</span> whiteColor];</span><br><span class="line">    [<span class="keyword">self</span>.view addSubview:<span class="keyword">self</span>.signInBtn];</span><br><span class="line">    </span><br><span class="line">    RACSignal *signal = [<span class="keyword">self</span>.signInBtn rac_signalForControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>];</span><br><span class="line">    [signal subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>,x);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="built_in">UIButton</span> *)signInBtn &#123;</span><br><span class="line">    <span class="keyword">if</span> (!_signInBtn) &#123;</span><br><span class="line">        _signInBtn = [<span class="built_in">UIButton</span> buttonWithType:<span class="built_in">UIButtonTypeCustom</span>];</span><br><span class="line">        _signInBtn.frame = <span class="built_in">CGRectMake</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">        _signInBtn.backgroundColor = [<span class="built_in">UIColor</span> orangeColor];</span><br><span class="line">        [_signInBtn setTitle:<span class="string">@&quot;登录&quot;</span> forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _signInBtn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>打印如下：<br></p><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OCTestDemo[37767:583939] &lt;UIButton: 0x7ff1fe4255d0; frame &#x3D; (100 100; 100 100); opaque &#x3D; NO; layer &#x3D; &lt;CALayer: 0x6000035eee20&gt;&gt;</span><br></pre></td></tr></table></div></figure><p>由此，我们发现，相比于传统的<code>target-action</code>方式，rac使用<code>block</code>的方式让代码更内聚，集中到了一处，对于代码的维护可能相对更优。</p>        <h5 id="3，UITextField文本输入监听"   >          <a href="#3，UITextField文本输入监听" class="heading-link"><i class="fas fa-link"></i></a>3，UITextField文本输入监听</h5>      <p>输入框常用在表单相关的页面里。比如在登录页面中，我们需要对输入框当前输入的内容进行验证，来限制手机号输入数量（11位）。<br><br>通常，我们会这么写：<br></p><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SFViewController</span> ()&lt;<span class="title">UITextFieldDelegate</span>&gt;</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UITextField</span> *phoneTextField;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SFViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="keyword">self</span>.view.backgroundColor = [<span class="built_in">UIColor</span> whiteColor];</span><br><span class="line">    [<span class="keyword">self</span>.view addSubview:<span class="keyword">self</span>.phoneTextField];</span><br><span class="line">    <span class="keyword">self</span>.phoneTextField.delegate = <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="built_in">BOOL</span>)textField:(<span class="built_in">UITextField</span> *)textField shouldChangeCharactersInRange:(<span class="built_in">NSRange</span>)range replacementString:(<span class="built_in">NSString</span> *)string &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *curString = [textField.text stringByReplacingCharactersInRange:range withString:string];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>,curString);</span><br><span class="line">    <span class="keyword">if</span> (curString.length &gt; <span class="number">11</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="built_in">UITextField</span> *)phoneTextField &#123;</span><br><span class="line">    <span class="keyword">if</span> (!_phoneTextField) &#123;</span><br><span class="line">        _phoneTextField = [[<span class="built_in">UITextField</span> alloc]initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">10</span>, <span class="number">200</span>, <span class="number">200</span>, <span class="number">40</span>)];</span><br><span class="line">        _phoneTextField.placeholder = <span class="string">@&quot;请输入手机号&quot;</span>;</span><br><span class="line">        _phoneTextField.keyboardType = <span class="built_in">UIKeyboardTypePhonePad</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _phoneTextField;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></div></figure><p>也就是通过代理的方式，来获取输入框当前的内容，通过<code>length</code>来判断手机号长度，进行限制输入。<br></p><p>那么，来看看在rac中，是怎么实现的：<br></p><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SFViewController</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UITextField</span> *phoneTextField;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SFViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="keyword">self</span>.view.backgroundColor = [<span class="built_in">UIColor</span> whiteColor];</span><br><span class="line">    [<span class="keyword">self</span>.view addSubview:<span class="keyword">self</span>.phoneTextField];</span><br><span class="line">    </span><br><span class="line">    RACSignal *signal = [<span class="keyword">self</span>.phoneTextField.rac_textSignal filter:^<span class="built_in">BOOL</span>(<span class="built_in">NSString</span> * _Nullable value) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value.length &gt; <span class="number">11</span>) &#123;</span><br><span class="line">            <span class="keyword">self</span>.phoneTextField.text = [value substringToIndex:<span class="number">11</span>];</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    [signal subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>,x);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">UITextField</span> *)phoneTextField &#123;</span><br><span class="line">    <span class="keyword">if</span> (!_phoneTextField) &#123;</span><br><span class="line">        _phoneTextField = [[<span class="built_in">UITextField</span> alloc]initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">10</span>, <span class="number">200</span>, <span class="number">200</span>, <span class="number">40</span>)];</span><br><span class="line">        _phoneTextField.placeholder = <span class="string">@&quot;请输入手机号&quot;</span>;</span><br><span class="line">        _phoneTextField.keyboardType = <span class="built_in">UIKeyboardTypePhonePad</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _phoneTextField;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></div></figure><p>在rac中，通过一个<code>rac_textSignal</code>信号量的方式监听输入框的变化，同时以block的方式返回监听的值。<br><br>对比，传统的代理方式，代码更内聚。<br></p>        <h5 id="4，通知中心消息监听"   >          <a href="#4，通知中心消息监听" class="heading-link"><i class="fas fa-link"></i></a>4，通知中心消息监听</h5>      <p>关于<code>页面传值方式</code>这个话题，记得以前在面试中也有被问到过😂<br><br>常用的方式也就是：指针传值、代理、block、通知中心…<br></p><p>对于<code>通知中心</code>，我们通常会这么写：<br></p><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="keyword">self</span>.view.backgroundColor = [<span class="built_in">UIColor</span> whiteColor];</span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(notifyEventOfChangeBackgroundColor:) name:<span class="string">@&quot;SF_NotifyKey_changeBackgroundColor&quot;</span> object:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)notifyEventOfChangeBackgroundColor:(<span class="built_in">NSNotification</span> *)sender &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>,__func__);</span><br><span class="line">    <span class="built_in">NSDictionary</span> *userInfo = sender.userInfo;</span><br><span class="line">    <span class="built_in">UIColor</span> *color = userInfo[<span class="string">@&quot;color&quot;</span>];</span><br><span class="line">    <span class="keyword">self</span>.view.backgroundColor = color;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 模拟通知</span></span><br><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>,__func__);</span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:<span class="string">@&quot;SF_NotifyKey_changeBackgroundColor&quot;</span> object:<span class="literal">nil</span> userInfo:@&#123;<span class="string">@&quot;color&quot;</span>:[<span class="built_in">UIColor</span> redColor]&#125;];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    <span class="comment">// dealloc时要移除通知</span></span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] removeObserver:<span class="keyword">self</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>那么，在rac中是怎么实现的呢？<br></p><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="keyword">self</span>.view.backgroundColor = [<span class="built_in">UIColor</span> whiteColor];</span><br><span class="line">    RACSignal *signal = [[<span class="built_in">NSNotificationCenter</span> defaultCenter] rac_addObserverForName:<span class="string">@&quot;SF_NotifyKey_changeBackgroundColor&quot;</span> object:<span class="literal">nil</span>];</span><br><span class="line">    [signal subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>,x);</span><br><span class="line">        <span class="built_in">NSNotification</span> *note = (<span class="built_in">NSNotification</span> *)x;</span><br><span class="line">        <span class="built_in">NSDictionary</span> *userInfo = note.userInfo;</span><br><span class="line">        <span class="built_in">UIColor</span> *color = [userInfo objectForKey:<span class="string">@&quot;color&quot;</span>];</span><br><span class="line">        <span class="keyword">self</span>.view.backgroundColor = color;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 模拟通知</span></span><br><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>,__func__);</span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:<span class="string">@&quot;SF_NotifyKey_changeBackgroundColor&quot;</span> object:<span class="literal">nil</span> userInfo:@&#123;<span class="string">@&quot;color&quot;</span>:[<span class="built_in">UIColor</span> redColor]&#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>同样的，rac用block的方式让代码更内聚。<br><br>同时，我们发现，也不需要在<code>dealloc</code>方法中，移除对应的通知了。<br><br>为什么呢？点击<code>rac_addObserverForName:object:</code>来看看它的内部实现：<br></p><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)rac_addObserverForName:(<span class="built_in">NSString</span> *)notificationName object:(<span class="keyword">id</span>)object &#123;</span><br><span class="line">@unsafeify(object);</span><br><span class="line"><span class="keyword">return</span> [[RACSignal createSignal:^(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">@strongify(object);</span><br><span class="line"><span class="keyword">id</span> observer = [<span class="keyword">self</span> addObserverForName:notificationName object:object queue:<span class="literal">nil</span> usingBlock:^(<span class="built_in">NSNotification</span> *note) &#123;</span><br><span class="line">[subscriber sendNext:note];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">[<span class="keyword">self</span> removeObserver:observer];</span><br><span class="line">&#125;];</span><br><span class="line">&#125;] setNameWithFormat:<span class="string">@&quot;-rac_addObserverForName: %@ object: &lt;%@: %p&gt;&quot;</span>, notificationName, [object <span class="keyword">class</span>], object];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>关键代码：<br></p><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">[<span class="keyword">self</span> removeObserver:observer];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></div></figure><p>即，在信号量销毁时，会将通知移除。<br></p>        <h5 id="5，代替KVO"   >          <a href="#5，代替KVO" class="heading-link"><i class="fas fa-link"></i></a>5，代替KVO</h5>      <p>我们知道，KVO实质上是利用了RunTime技术，在运行时会动态的创建一个当前对象对应类的子类，通过重写属性的setter方法来间接实现属性监听。<br><br>通常，我们会这么写KVO：<br></p><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SFViewController</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIView</span> *testView;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SFViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="keyword">self</span>.view.backgroundColor = [<span class="built_in">UIColor</span> whiteColor];</span><br><span class="line">    [<span class="keyword">self</span>.view addSubview:<span class="keyword">self</span>.testView];</span><br><span class="line">    [<span class="keyword">self</span>.testView addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@&quot;backgroundColor&quot;</span> options:(<span class="built_in">NSKeyValueObservingOptionNew</span>|<span class="built_in">NSKeyValueObservingOptionOld</span>) context:<span class="literal">NULL</span>];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>,<span class="keyword">id</span>&gt; *)change context:(<span class="keyword">void</span> *)context &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;keyPath=%@&quot;</span>,keyPath);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;object=%@&quot;</span>,object);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;change=%@&quot;</span>,change);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;context=%@&quot;</span>,context);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 模拟</span></span><br><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>,__func__);</span><br><span class="line">    <span class="keyword">self</span>.testView.backgroundColor = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="built_in">UIView</span> *)testView &#123;</span><br><span class="line">    <span class="keyword">if</span> (!_testView) &#123;</span><br><span class="line">        _testView = [[<span class="built_in">UIView</span> alloc]initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>)];</span><br><span class="line">        _testView.backgroundColor = [<span class="built_in">UIColor</span> blackColor];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _testView;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></div></figure><p>在rac中，KVO的实现方式如下：<br></p><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SFViewController</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIView</span> *testView;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SFViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="keyword">self</span>.view.backgroundColor = [<span class="built_in">UIColor</span> whiteColor];</span><br><span class="line">    [<span class="keyword">self</span>.view addSubview:<span class="keyword">self</span>.testView];</span><br><span class="line">    <span class="comment">// 方式一</span></span><br><span class="line">    [<span class="keyword">self</span>.testView rac_observeKeyPath:<span class="string">@&quot;backgroundColor&quot;</span> options:(<span class="built_in">NSKeyValueObservingOptionNew</span>|<span class="built_in">NSKeyValueObservingOptionOld</span>) observer:<span class="keyword">self</span> block:^(<span class="keyword">id</span> value, <span class="built_in">NSDictionary</span> *change, <span class="built_in">BOOL</span> causedByDealloc, <span class="built_in">BOOL</span> affectedOnlyLastComponent) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;value=%@&quot;</span>,value);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;change=%@&quot;</span>,change);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;causedByDealloc=%d&quot;</span>,causedByDealloc);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;affectedOnlyLastComponent=%d&quot;</span>,affectedOnlyLastComponent);</span><br><span class="line">    &#125;];</span><br><span class="line"><span class="comment">//    // 方式二</span></span><br><span class="line"><span class="comment">//    [RACObserve(self.testView, backgroundColor) subscribeNext:^(id  _Nullable x) &#123;</span></span><br><span class="line"><span class="comment">//        NSLog(@&quot;%@&quot;,x);</span></span><br><span class="line"><span class="comment">//    &#125;];</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 模拟</span></span><br><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>,__func__);</span><br><span class="line">    <span class="keyword">self</span>.testView.backgroundColor = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="built_in">UIView</span> *)testView &#123;</span><br><span class="line">    <span class="keyword">if</span> (!_testView) &#123;</span><br><span class="line">        _testView = [[<span class="built_in">UIView</span> alloc]initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>)];</span><br><span class="line">        _testView.backgroundColor = [<span class="built_in">UIColor</span> blackColor];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _testView;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></div></figure><p>需要注意的是：<br><br>区别：<br></p><ul><li>传统写法的KVO，只有在属性值有改变时才会触发KVO；</li><li>rac的KVO，是在一开始就会触发KVO；</li></ul>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;/rac-1-%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/RAC.jpg&quot; class=&quot;&quot;&gt;

&lt;blockquote&gt;
&lt;p&gt;关键词：rac&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="RAC" scheme="https://jack110530.github.io/categories/RAC/"/>
    
    
    <category term="rac" scheme="https://jack110530.github.io/tags/rac/"/>
    
  </entry>
  
  <entry>
    <title>Git报错-refusing to merge unrelated histories</title>
    <link href="https://jack110530.github.io/git%E6%8A%A5%E9%94%99-refusing-to-merge-unrelated-histories/"/>
    <id>https://jack110530.github.io/git%E6%8A%A5%E9%94%99-refusing-to-merge-unrelated-histories/</id>
    <published>2020-11-06T01:47:43.000Z</published>
    <updated>2020-11-06T02:15:34.282Z</updated>
    
    <content type="html"><![CDATA[<img src="/git%E6%8A%A5%E9%94%99-refusing-to-merge-unrelated-histories/git.png" class=""><br><blockquote><p>关键词：Git、pull、push、fetch、merge</p></blockquote><a id="more"></a>        <h3 id="问题"   >          <a href="#问题" class="heading-link"><i class="fas fa-link"></i></a>问题</h3>      <p>1、本地有一个git仓库，开发很长时间了，一直也都有add、commit，但是始终没有推送到远端仓库过；<br><br>因为最开始只是我自己一个人开发，所以本地这仓库并不是从远端仓库<code>git clone</code>过来的，而是直接在本地<code>git init</code>，一直在本地管理的。<br><br>2、现在需要将代码推送远端仓库，和别人协作开发。<br><br>3、先新建个远端仓库</p><img src="/git%E6%8A%A5%E9%94%99-refusing-to-merge-unrelated-histories/init.png" class=""><br><p>4、然后本地仓库添加github上的git仓库作为远程仓库，起名origin；</p><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin https:&#x2F;&#x2F;github.com&#x2F;XXXXXXX&#x2F;XXXXXX</span><br></pre></td></tr></table></div></figure><p>5、问题来了，本地仓库在想做同步远程仓库到本地为之后本地仓库推送到远程仓库做准备时报错了，错误如下：</p><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fatal: refusing to merge unrelated histories</span><br><span class="line">（拒绝合并不相关的历史）</span><br></pre></td></tr></table></div></figure>        <h3 id="解决"   >          <a href="#解决" class="heading-link"><i class="fas fa-link"></i></a>解决</h3>      <p>出现这个问题的最主要原因还是在于本地仓库和远程仓库实际上是独立的两个仓库。假如我之前是直接clone的方式在本地建立起远程github仓库的克隆本地仓库就不会有这问题了。<br></p><p>查阅了一下资料，发现可以在pull命令后紧接着使用<code>--allow-unrelated-history</code>选项来解决问题（该选项可以合并两个独立启动仓库的历史）。</p><p>命令：<br></p><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$git pull origin master --allow-unrelated-histories</span><br></pre></td></tr></table></div></figure><p>以上是将远程仓库的文件拉取到本地仓库了。<br><br>紧接着将本地仓库的提交推送到远程github仓库上，使用的命令是：&lt;&gt;</p><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</span><br><span class="line">也就是</span><br><span class="line">$git push origin master:master</span><br><span class="line">提交成功。</span><br></pre></td></tr></table></div></figure>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;/git%E6%8A%A5%E9%94%99-refusing-to-merge-unrelated-histories/git.png&quot; class=&quot;&quot;&gt;&lt;br&gt;

&lt;blockquote&gt;
&lt;p&gt;关键词：Git、pull、push、fetch、merge&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="笔记" scheme="https://jack110530.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Git" scheme="https://jack110530.github.io/categories/%E7%AC%94%E8%AE%B0/Git/"/>
    
    
    <category term="git" scheme="https://jack110530.github.io/tags/git/"/>
    
    <category term="error" scheme="https://jack110530.github.io/tags/error/"/>
    
  </entry>
  
  <entry>
    <title>笔记：设备旋转后刷新UICollectionView布局</title>
    <link href="https://jack110530.github.io/%E7%AC%94%E8%AE%B0%EF%BC%9A%E8%AE%BE%E5%A4%87%E6%97%8B%E8%BD%AC%E5%90%8E%E5%88%B7%E6%96%B0uicollectionview%E5%B8%83%E5%B1%80/"/>
    <id>https://jack110530.github.io/%E7%AC%94%E8%AE%B0%EF%BC%9A%E8%AE%BE%E5%A4%87%E6%97%8B%E8%BD%AC%E5%90%8E%E5%88%B7%E6%96%B0uicollectionview%E5%B8%83%E5%B1%80/</id>
    <published>2020-11-04T03:05:08.000Z</published>
    <updated>2020-11-04T03:52:40.382Z</updated>
    
    <content type="html"><![CDATA[<img src="/%E7%AC%94%E8%AE%B0%EF%BC%9A%E8%AE%BE%E5%A4%87%E6%97%8B%E8%BD%AC%E5%90%8E%E5%88%B7%E6%96%B0uicollectionview%E5%B8%83%E5%B1%80/%E7%AC%94%E8%AE%B0iOS.jpg" class=""><br><p>最近在开发iPad项目时遇到个问题：<br><br>屏幕旋转时，UICollectionView不会自动刷新布局，cell的大小不会自动更新？？<br></p><a id="more"></a><br><p>如：<br><br>1、当一开始进来是竖屏时：<br></p><img src="/%E7%AC%94%E8%AE%B0%EF%BC%9A%E8%AE%BE%E5%A4%87%E6%97%8B%E8%BD%AC%E5%90%8E%E5%88%B7%E6%96%B0uicollectionview%E5%B8%83%E5%B1%80/test1.png" class=""><br><p>旋转到横屏后：<br></p><img src="/%E7%AC%94%E8%AE%B0%EF%BC%9A%E8%AE%BE%E5%A4%87%E6%97%8B%E8%BD%AC%E5%90%8E%E5%88%B7%E6%96%B0uicollectionview%E5%B8%83%E5%B1%80/test2.png" class=""><br><p>两边有留白，cell没有自适应到屏幕宽度；<br></p><p>2、当一开始进来是横屏时：<br></p><img src="/%E7%AC%94%E8%AE%B0%EF%BC%9A%E8%AE%BE%E5%A4%87%E6%97%8B%E8%BD%AC%E5%90%8E%E5%88%B7%E6%96%B0uicollectionview%E5%B8%83%E5%B1%80/test3.png" class=""><br><p>旋转到竖屏后：<br></p><img src="/%E7%AC%94%E8%AE%B0%EF%BC%9A%E8%AE%BE%E5%A4%87%E6%97%8B%E8%BD%AC%E5%90%8E%E5%88%B7%E6%96%B0uicollectionview%E5%B8%83%E5%B1%80/test4.png" class=""><br><p>cell的宽度还是横屏时的宽度！；<br></p><blockquote><p>怎么解决？</p></blockquote><p>网上也有些解决办法，如：<br></p><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种，重写viewWillLayoutSubviews方法</span></span><br><span class="line">- (<span class="keyword">void</span>)viewWillLayoutSubviews &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewWillLayoutSubviews];</span><br><span class="line">    [<span class="keyword">self</span>.collectionView.collectionViewLayout invalidateLayout];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种，重写viewWillTransitionToSize方法</span></span><br><span class="line">- (<span class="keyword">void</span>)viewWillTransitionToSize:(<span class="built_in">CGSize</span>)size withTransitionCoordinator:(<span class="keyword">id</span>&lt;<span class="built_in">UIViewControllerTransitionCoordinator</span>&gt;)coordinator &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewWillTransitionToSize:size withTransitionCoordinator:coordinator];</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span>.collectionView.collectionViewLayout invalidateLayout]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>这里做些补充：<br><br>1、如果你是在UICollectionView初始化时，给定itemSize，那么不管你用以上那种方法都是无效的。<br></p><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">layout.itemSize = <span class="built_in">CGSizeMake</span>([<span class="built_in">UIScreen</span> mainScreen].bounds.size.width, <span class="number">200</span>);</span><br><span class="line">_collectionView = [[<span class="built_in">UICollectionView</span> alloc]initWithFrame:<span class="built_in">CGRectZero</span> collectionViewLayout:layout];</span><br></pre></td></tr></table></div></figure><p>因为你把layout的itemSize写死了。</p><p>所以，最好是在sizeForItemAtIndexPath的代理方法中定义，如：</p><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">CGSize</span>)collectionView:(<span class="built_in">UICollectionView</span> *)collectionView layout:(<span class="built_in">UICollectionViewLayout</span> *)collectionViewLayout sizeForItemAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CGSizeMake</span>(collectionView.bounds.size.width, <span class="number">200</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>2、经过测试，在iPhone中，是不需要额外写这些代码的，自动回更新布局。</p>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;/%E7%AC%94%E8%AE%B0%EF%BC%9A%E8%AE%BE%E5%A4%87%E6%97%8B%E8%BD%AC%E5%90%8E%E5%88%B7%E6%96%B0uicollectionview%E5%B8%83%E5%B1%80/%E7%AC%94%E8%AE%B0iOS.jpg&quot; class=&quot;&quot;&gt;&lt;br&gt;

&lt;p&gt;最近在开发iPad项目时遇到个问题：&lt;br&gt;&lt;br&gt;屏幕旋转时，UICollectionView不会自动刷新布局，cell的大小不会自动更新？？&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="https://jack110530.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="iOS" scheme="https://jack110530.github.io/categories/%E7%AC%94%E8%AE%B0/iOS/"/>
    
    
    <category term="iPad" scheme="https://jack110530.github.io/tags/iPad/"/>
    
    <category term="UICollectionView" scheme="https://jack110530.github.io/tags/UICollectionView/"/>
    
  </entry>
  
  <entry>
    <title>isKindOfClass与isMemberOfClass的区别</title>
    <link href="https://jack110530.github.io/iskindofclass%E4%B8%8Eismemberofclass%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://jack110530.github.io/iskindofclass%E4%B8%8Eismemberofclass%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2020-11-03T02:27:52.000Z</published>
    <updated>2020-11-03T02:48:50.608Z</updated>
    
    <content type="html"><![CDATA[<img src="/iskindofclass%E4%B8%8Eismemberofclass%E7%9A%84%E5%8C%BA%E5%88%AB/%E9%87%8D%E6%8B%BEiOS.jpg" class=""><blockquote><p>关键词：isa、superclass、类簇</p></blockquote><a id="more"></a>        <h3 id="一、isKindOfClass与isMemberOfClass的区别"   >          <a href="#一、isKindOfClass与isMemberOfClass的区别" class="heading-link"><i class="fas fa-link"></i></a>一、isKindOfClass与isMemberOfClass的区别</h3>      <p>以下代码的输出结果是什么，为什么？<br></p><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一组</span></span><br><span class="line"><span class="built_in">BOOL</span> re1 = [(<span class="keyword">id</span>)[<span class="built_in">NSObject</span> <span class="keyword">class</span>] isKindOfClass:[<span class="built_in">NSObject</span> <span class="keyword">class</span>]];</span><br><span class="line"><span class="built_in">BOOL</span> re2 = [(<span class="keyword">id</span>)[<span class="built_in">NSObject</span> <span class="keyword">class</span>] isMemberOfClass:[<span class="built_in">NSObject</span> <span class="keyword">class</span>]];</span><br><span class="line"><span class="built_in">BOOL</span> re3 = [(<span class="keyword">id</span>)[SFPerson <span class="keyword">class</span>] isKindOfClass:[SFPerson <span class="keyword">class</span>]];</span><br><span class="line"><span class="built_in">BOOL</span> re4 = [(<span class="keyword">id</span>)[SFPerson <span class="keyword">class</span>] isMemberOfClass:[SFPerson <span class="keyword">class</span>]];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%hhd%hhd%hhd%hhd&quot;</span>,re1,re2,re3,re4);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二组</span></span><br><span class="line"><span class="built_in">BOOL</span> re5 = [(<span class="keyword">id</span>)[<span class="built_in">NSObject</span> alloc] isKindOfClass:[<span class="built_in">NSObject</span> <span class="keyword">class</span>]];</span><br><span class="line"><span class="built_in">BOOL</span> re6 = [(<span class="keyword">id</span>)[<span class="built_in">NSObject</span> alloc] isMemberOfClass:[<span class="built_in">NSObject</span> <span class="keyword">class</span>]];</span><br><span class="line"><span class="built_in">BOOL</span> re7 = [(<span class="keyword">id</span>)[SFPerson alloc] isKindOfClass:[SFPerson <span class="keyword">class</span>]];</span><br><span class="line"><span class="built_in">BOOL</span> re8 = [(<span class="keyword">id</span>)[SFPerson alloc] isMemberOfClass:[SFPerson <span class="keyword">class</span>]];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%hhd%hhd%hhd%hhd&quot;</span>,re5,re6,re7,re8);</span><br></pre></td></tr></table></div></figure><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出：<span class="number">1000</span>，<span class="number">1111</span>&lt;br&gt;</span><br></pre></td></tr></table></div></figure><blockquote><p>为什么？</p></blockquote><p>1、首先要知道isKindOfClass 与 isMemberOfClass 的区别：<br></p><ul><li>isKindOfClass来确定一个对象是否是一个类的成员，或者是派生自该类的成员；</li><li>isMemberOfClass只能确定一个对象是否是当前类的成员；</li></ul><p>isKindOfClass的实现代码大致如下：<br></p><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由isa指针找到该对象所在当前类，判断aClass是否为当前类，若不是则通过superclass指针获取到其父类进行比较</span></span><br><span class="line">-(<span class="built_in">BOOL</span>)isKindOfClass:(Class)aClass &#123;</span><br><span class="line">    <span class="keyword">for</span> (Class tcls = isa; tcls; tcls-&gt; superclass) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tcls == aClass) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>isMemberOfClass的实现代码大致如下：<br></p><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由isa指针找到该对象所在当前类，直接比较aClass是否为当前类</span></span><br><span class="line">-(<span class="built_in">BOOL</span>)isMemberOfClass:(Class)aClass &#123;</span><br><span class="line">    <span class="keyword">return</span> isa == aClass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>2、再者要了解实例对象、类对象和元类对象之间的关系：<br></p><img src="/iskindofclass%E4%B8%8Eismemberofclass%E7%9A%84%E5%8C%BA%E5%88%AB/isa.png" class=""><br><p>由图可知：<br></p><p>isa指针：<br></p><ul><li>实例对象的isa指向类对象；</li><li>类对象的isa指向元类对象；</li><li>元类对象的isa指向基类的元类对象；</li><li>基类元类对象的isa指针指向它自己；</li></ul><p>superclass指针：<br></p><ul><li>类对象的superclass指向其父类类对象；</li><li>如果没有父类，superclass指针为nil；</li><li>元类对象的superclass指向其父类元类对象；</li><li>基类的元类对象的superclass指向基类的类对象；</li></ul><p>了解了这些，回过头来看这道题，是不是就明白了。</p>        <h3 id="二-类簇"   >          <a href="#二-类簇" class="heading-link"><i class="fas fa-link"></i></a>二.  类簇</h3>      <p>以下代码的输出结果是什么，为什么？</p><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *arr = [<span class="built_in">NSArray</span> array];</span><br><span class="line"><span class="built_in">NSArray</span> *mtArr = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line"> </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%d&quot;</span>, [arr isKindOfClass:[<span class="built_in">NSObject</span> <span class="keyword">class</span>]]);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%d&quot;</span>, [arr isMemberOfClass:[<span class="built_in">NSObject</span> <span class="keyword">class</span>]]);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%d&quot;</span>, [mtArr isKindOfClass:[<span class="built_in">NSObject</span> <span class="keyword">class</span>]]);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%d&quot;</span>, [mtArr isMemberOfClass:[<span class="built_in">NSObject</span> <span class="keyword">class</span>]]);</span><br><span class="line">    </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%d&quot;</span>, [arr isKindOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>]]);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%d&quot;</span>, [arr isMemberOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>]]);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%d&quot;</span>, [mtArr isKindOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>]]);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%d&quot;</span>, [mtArr isMemberOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>]]);</span><br><span class="line">    </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%d&quot;</span>, [mtArr isKindOfClass:[arr <span class="keyword">class</span>]]);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%d&quot;</span>, [mtArr isMemberOfClass:[arr <span class="keyword">class</span>]]); </span><br></pre></td></tr></table></div></figure><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出：<span class="number">1010101000</span></span><br></pre></td></tr></table></div></figure><p>你可能会对以下输出产生疑问🤔：<br></p><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%d&quot;</span>, [arr isMemberOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>]]); </span><br><span class="line"><span class="comment">// 输出0</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%d&quot;</span>, [mtArr isKindOfClass:[arr <span class="keyword">class</span>]]);</span><br><span class="line"><span class="comment">// 输出0</span></span><br></pre></td></tr></table></div></figure><p>原因在于NSArray是一个类簇，意味着每个NSArray的实例都是NSArray内部子类的一个实例，我们会发现[[NSArray array] class]返回值为__NSArray0,[[NSMutableArray array] class]返回值为__NSArrayM, 而[NSArray class]返回值为NSArray，所以二者不等。</p>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;/iskindofclass%E4%B8%8Eismemberofclass%E7%9A%84%E5%8C%BA%E5%88%AB/%E9%87%8D%E6%8B%BEiOS.jpg&quot; class=&quot;&quot;&gt;

&lt;blockquote&gt;
&lt;p&gt;关键词：isa、superclass、类簇&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="重拾iOS" scheme="https://jack110530.github.io/categories/%E9%87%8D%E6%8B%BEiOS/"/>
    
    
    <category term="类簇" scheme="https://jack110530.github.io/tags/%E7%B1%BB%E7%B0%87/"/>
    
    <category term="isa" scheme="https://jack110530.github.io/tags/isa/"/>
    
    <category term="superclass" scheme="https://jack110530.github.io/tags/superclass/"/>
    
  </entry>
  
  <entry>
    <title>iOS面试题(1)</title>
    <link href="https://jack110530.github.io/ios%E9%9D%A2%E8%AF%95%E9%A2%98-1/"/>
    <id>https://jack110530.github.io/ios%E9%9D%A2%E8%AF%95%E9%A2%98-1/</id>
    <published>2020-10-29T04:08:20.000Z</published>
    <updated>2020-10-30T01:05:09.740Z</updated>
    
    <content type="html"><![CDATA[<img src="/ios%E9%9D%A2%E8%AF%95%E9%A2%98-1/iOS%E9%9D%A2%E8%AF%95%E9%A2%98.jpg" class=""><br><a id="more"></a>        <h3 id="weak和assign的区别是什么，什么时候情况下使用weak？"   >          <a href="#weak和assign的区别是什么，什么时候情况下使用weak？" class="heading-link"><i class="fas fa-link"></i></a>weak和assign的区别是什么，什么时候情况下使用weak？</h3>      <blockquote><p>关键词：weak、assign、悬空指针、野指针</p></blockquote><hr>        <h3 id="什么情况下使用copy修饰属性？"   >          <a href="#什么情况下使用copy修饰属性？" class="heading-link"><i class="fas fa-link"></i></a>什么情况下使用copy修饰属性？</h3>      <blockquote><p>关键词：copy、封装性、堆栈</p></blockquote><hr>        <h3 id="深拷贝与浅拷贝"   >          <a href="#深拷贝与浅拷贝" class="heading-link"><i class="fas fa-link"></i></a>深拷贝与浅拷贝</h3>      <blockquote><p>关键词：深拷贝、浅拷贝</p></blockquote><hr>        <h3 id="property-copy-NSMutableArray-array-这种写法会有什么问题？"   >          <a href="#property-copy-NSMutableArray-array-这种写法会有什么问题？" class="heading-link"><i class="fas fa-link"></i></a>@property (copy) NSMutableArray *array;这种写法会有什么问题？</h3>      <blockquote><p>关键词：copy</p></blockquote><hr>        <h3 id="atomic和nonatomic的区别，为什么开发中常用nonatomic而非atomic？"   >          <a href="#atomic和nonatomic的区别，为什么开发中常用nonatomic而非atomic？" class="heading-link"><i class="fas fa-link"></i></a>atomic和nonatomic的区别，为什么开发中常用nonatomic而非atomic？</h3>      <blockquote><p>关键词：atomic、nonatomic、锁</p></blockquote><hr>        <h3 id="如何让自己的类用-copy-修饰符？如何重写带-copy-关键字的-setter？"   >          <a href="#如何让自己的类用-copy-修饰符？如何重写带-copy-关键字的-setter？" class="heading-link"><i class="fas fa-link"></i></a>如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？</h3>      <blockquote><p>关键词：atomic、nonatomic、锁</p></blockquote><hr>        <h3 id="property的本质是什么？"   >          <a href="#property的本质是什么？" class="heading-link"><i class="fas fa-link"></i></a>@property的本质是什么？</h3>      <blockquote><p>关键词：@property、setter、getter、ivar、protocol、category</p></blockquote><hr>        <h3 id="使用runtime-Associate方法关联的对象，需要在主对象dealloc的时候释放么？"   >          <a href="#使用runtime-Associate方法关联的对象，需要在主对象dealloc的时候释放么？" class="heading-link"><i class="fas fa-link"></i></a>使用runtime Associate方法关联的对象，需要在主对象dealloc的时候释放么？</h3>      <blockquote><p>关键词：runtime、关联对象、dealloc</p></blockquote><hr>        <h3 id="synthesize和-dynamic分别有什么作用？"   >          <a href="#synthesize和-dynamic分别有什么作用？" class="heading-link"><i class="fas fa-link"></i></a>@synthesize和@dynamic分别有什么作用？</h3>      <blockquote><p>关键词：</p></blockquote>        <h2 id="在有了自动合成属性实例变量之后，-synthesize还有哪些使用场景？"   >          <a href="#在有了自动合成属性实例变量之后，-synthesize还有哪些使用场景？" class="heading-link"><i class="fas fa-link"></i></a>在有了自动合成属性实例变量之后，@synthesize还有哪些使用场景？</h2>      ]]></content>
    
    
    <summary type="html">&lt;img src=&quot;/ios%E9%9D%A2%E8%AF%95%E9%A2%98-1/iOS%E9%9D%A2%E8%AF%95%E9%A2%98.jpg&quot; class=&quot;&quot;&gt;
&lt;br&gt;</summary>
    
    
    
    <category term="iOS面试题" scheme="https://jack110530.github.io/categories/iOS%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="property" scheme="https://jack110530.github.io/tags/property/"/>
    
  </entry>
  
  <entry>
    <title>RunTime(8)-面试题二</title>
    <link href="https://jack110530.github.io/runtime-8-%E9%9D%A2%E8%AF%95%E9%A2%98%E4%BA%8C/"/>
    <id>https://jack110530.github.io/runtime-8-%E9%9D%A2%E8%AF%95%E9%A2%98%E4%BA%8C/</id>
    <published>2020-10-28T03:42:03.000Z</published>
    <updated>2020-11-10T07:26:27.668Z</updated>
    
    <content type="html"><![CDATA[<img src="/runtime-8-%E9%9D%A2%E8%AF%95%E9%A2%98%E4%BA%8C/%E9%87%8D%E6%8B%BEiOS.jpg" class=""><blockquote><p>关键词：RunTime</p></blockquote><a id="more"></a><p>RunTime系列文章:<br></p><ul><li><a href="https://jack110530.github.io/runtime-1-oc%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9C%AC%E8%B4%A8/">RunTime(1)-OC对象的本质</a></li><li><a href="https://jack110530.github.io/runtime-2-class%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/">RunTime(2)-Class结构分析</a></li><li><a href="https://jack110530.github.io/runtime-3-%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/">RunTime(3)-消息机制</a></li><li><a href="https://jack110530.github.io/runtime-cache%E6%96%B9%E6%B3%95%E7%BC%93%E5%AD%98/">RunTime(4)-Cache方法缓存</a></li><li><a href="https://jack110530.github.io/runtime-5-super%E7%9A%84%E6%9C%AC%E8%B4%A8/">RunTime(5)-super的本质</a></li><li><a href="https://jack110530.github.io/runtime-6-%E5%AE%9E%E9%99%85%E8%BF%90%E7%94%A8/">RunTime(6)-实际运用</a></li><li><a href="https://jack110530.github.io/runtime-7-%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%80/">RunTime(7)-面试题一</a></li><li><a href="https://jack110530.github.io/runtime-8-%E9%9D%A2%E8%AF%95%E9%A2%98%E4%BA%8C/">RunTime(8)-面试题二</a></li></ul><p>【待完善…】</p>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;/runtime-8-%E9%9D%A2%E8%AF%95%E9%A2%98%E4%BA%8C/%E9%87%8D%E6%8B%BEiOS.jpg&quot; class=&quot;&quot;&gt;

&lt;blockquote&gt;
&lt;p&gt;关键词：RunTime&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="重拾iOS" scheme="https://jack110530.github.io/categories/%E9%87%8D%E6%8B%BEiOS/"/>
    
    
    <category term="runtime" scheme="https://jack110530.github.io/tags/runtime/"/>
    
  </entry>
  
  <entry>
    <title>RunTime(7)-面试题一</title>
    <link href="https://jack110530.github.io/runtime-7-%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%80/"/>
    <id>https://jack110530.github.io/runtime-7-%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%80/</id>
    <published>2020-10-28T03:41:54.000Z</published>
    <updated>2020-11-10T07:26:27.668Z</updated>
    
    <content type="html"><![CDATA[<img src="/runtime-7-%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%80/%E9%87%8D%E6%8B%BEiOS.jpg" class=""><blockquote><p>关键词：RunTime</p></blockquote><a id="more"></a><p>RunTime系列文章:<br></p><ul><li><a href="https://jack110530.github.io/runtime-1-oc%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9C%AC%E8%B4%A8/">RunTime(1)-OC对象的本质</a></li><li><a href="https://jack110530.github.io/runtime-2-class%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/">RunTime(2)-Class结构分析</a></li><li><a href="https://jack110530.github.io/runtime-3-%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/">RunTime(3)-消息机制</a></li><li><a href="https://jack110530.github.io/runtime-cache%E6%96%B9%E6%B3%95%E7%BC%93%E5%AD%98/">RunTime(4)-Cache方法缓存</a></li><li><a href="https://jack110530.github.io/runtime-5-super%E7%9A%84%E6%9C%AC%E8%B4%A8/">RunTime(5)-super的本质</a></li><li><a href="https://jack110530.github.io/runtime-6-%E5%AE%9E%E9%99%85%E8%BF%90%E7%94%A8/">RunTime(6)-实际运用</a></li><li><a href="https://jack110530.github.io/runtime-7-%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%80/">RunTime(7)-面试题一</a></li><li><a href="https://jack110530.github.io/runtime-8-%E9%9D%A2%E8%AF%95%E9%A2%98%E4%BA%8C/">RunTime(8)-面试题二</a></li></ul><p>【待完善…】</p>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;/runtime-7-%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%80/%E9%87%8D%E6%8B%BEiOS.jpg&quot; class=&quot;&quot;&gt;

&lt;blockquote&gt;
&lt;p&gt;关键词：RunTime&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="重拾iOS" scheme="https://jack110530.github.io/categories/%E9%87%8D%E6%8B%BEiOS/"/>
    
    
    <category term="runtime" scheme="https://jack110530.github.io/tags/runtime/"/>
    
  </entry>
  
  <entry>
    <title>RunTime(6)-实际运用</title>
    <link href="https://jack110530.github.io/runtime-6-%E5%AE%9E%E9%99%85%E8%BF%90%E7%94%A8/"/>
    <id>https://jack110530.github.io/runtime-6-%E5%AE%9E%E9%99%85%E8%BF%90%E7%94%A8/</id>
    <published>2020-10-28T03:41:45.000Z</published>
    <updated>2020-11-10T07:35:09.954Z</updated>
    
    <content type="html"><![CDATA[<img src="/runtime-6-%E5%AE%9E%E9%99%85%E8%BF%90%E7%94%A8/%E9%87%8D%E6%8B%BEiOS.jpg" class=""><blockquote><p>关键词：RunTime</p></blockquote><a id="more"></a><p>RunTime系列文章:<br></p><ul><li><a href="https://jack110530.github.io/runtime-1-oc%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9C%AC%E8%B4%A8/">RunTime(1)-OC对象的本质</a></li><li><a href="https://jack110530.github.io/runtime-2-class%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/">RunTime(2)-Class结构分析</a></li><li><a href="https://jack110530.github.io/runtime-3-%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/">RunTime(3)-消息机制</a></li><li><a href="https://jack110530.github.io/runtime-cache%E6%96%B9%E6%B3%95%E7%BC%93%E5%AD%98/">RunTime(4)-Cache方法缓存</a></li><li><a href="https://jack110530.github.io/runtime-5-super%E7%9A%84%E6%9C%AC%E8%B4%A8/">RunTime(5)-super的本质</a></li><li><a href="https://jack110530.github.io/runtime-6-%E5%AE%9E%E9%99%85%E8%BF%90%E7%94%A8/">RunTime(6)-实际运用</a></li><li><a href="https://jack110530.github.io/runtime-7-%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%80/">RunTime(7)-面试题一</a></li><li><a href="https://jack110530.github.io/runtime-8-%E9%9D%A2%E8%AF%95%E9%A2%98%E4%BA%8C/">RunTime(8)-面试题二</a></li></ul>        <h3 id="前言"   >          <a href="#前言" class="heading-link"><i class="fas fa-link"></i></a>前言</h3>              <h3 id="一、RunTime-API"   >          <a href="#一、RunTime-API" class="heading-link"><i class="fas fa-link"></i></a>一、RunTime API</h3>              <h4 id="类"   >          <a href="#类" class="heading-link"><i class="fas fa-link"></i></a>类</h4>      <figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 动态创建一个类（参数：父类，类名，额外的内存空间）</span></span><br><span class="line">Class objc_allocateClassPair(Class superclass, <span class="keyword">const</span> <span class="keyword">char</span> *name, size_t extraBytes)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 注册一个类（要在类注册之前添加成员变量）</span></span><br><span class="line"><span class="keyword">void</span> objc_registerClassPair(Class cls) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 销毁一个类</span></span><br><span class="line"><span class="keyword">void</span> objc_disposeClassPair(Class cls)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 获取isa指向的Class</span></span><br><span class="line">Class object_getClass(<span class="keyword">id</span> obj)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 设置isa指向的Class</span></span><br><span class="line">Class object_setClass(<span class="keyword">id</span> obj, Class cls)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. 判断一个OC对象是否为Class</span></span><br><span class="line"><span class="built_in">BOOL</span> object_isClass(<span class="keyword">id</span> obj)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 7. 判断一个Class是否为元类</span></span><br><span class="line"><span class="built_in">BOOL</span> class_isMetaClass(Class cls)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 8. 获取父类</span></span><br><span class="line">Class class_getSuperclass(Class cls)</span><br></pre></td></tr></table></div></figure>        <h4 id="成员变量"   >          <a href="#成员变量" class="heading-link"><i class="fas fa-link"></i></a>成员变量</h4>      <figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 获取一个实例变量信息</span></span><br><span class="line">Ivar class_getInstanceVariable(Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 拷贝实例变量列表（最后需要调用free释放）</span></span><br><span class="line">Ivar *class_copyIvarList(Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 设置和获取成员变量的值</span></span><br><span class="line"><span class="keyword">void</span> object_setIvar(<span class="keyword">id</span> obj, Ivar ivar, <span class="keyword">id</span> value)</span><br><span class="line"><span class="keyword">id</span> object_getIvar(<span class="keyword">id</span> obj, Ivar ivar)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 动态添加成员变量（已经注册的类是不能动态添加成员变量的）</span></span><br><span class="line"><span class="built_in">BOOL</span> class_addIvar(Class cls, <span class="keyword">const</span> <span class="keyword">char</span> * name, size_t size, uint8_t alignment, <span class="keyword">const</span> <span class="keyword">char</span> * types)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 获取成员变量的相关信息</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *ivar_getName(Ivar v)</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *ivar_getTypeEncoding(Ivar v)</span><br></pre></td></tr></table></div></figure>        <h4 id="属性"   >          <a href="#属性" class="heading-link"><i class="fas fa-link"></i></a>属性</h4>      <figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 获取一个属性</span></span><br><span class="line">objc_property_t class_getProperty(Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 拷贝属性列表（最后需要调用free释放）</span></span><br><span class="line">objc_property_t *class_copyPropertyList(Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 动态添加属性</span></span><br><span class="line"><span class="built_in">BOOL</span> class_addProperty(Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> objc_property_attribute_t *attributes, <span class="keyword">unsigned</span> <span class="keyword">int</span> attributeCount)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 动态替换属性</span></span><br><span class="line"><span class="keyword">void</span> class_replaceProperty(Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> objc_property_attribute_t *attributes, <span class="keyword">unsigned</span> <span class="keyword">int</span> attributeCount)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 获取属性的一些信息</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *property_getName(objc_property_t property)</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *property_getAttributes(objc_property_t property)</span><br></pre></td></tr></table></div></figure>        <h4 id="方法"   >          <a href="#方法" class="heading-link"><i class="fas fa-link"></i></a>方法</h4>      <figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 获得一个实例方法、类方法</span></span><br><span class="line">Method class_getInstanceMethod(Class cls, SEL name)</span><br><span class="line">Method class_getClassMethod(Class cls, SEL name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 方法实现相关操作</span></span><br><span class="line">IMP class_getMethodImplementation(Class cls, SEL name) </span><br><span class="line">IMP method_setImplementation(Method m, IMP imp)</span><br><span class="line"><span class="keyword">void</span> method_exchangeImplementations(Method m1, Method m2) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 拷贝方法列表（最后需要调用free释放）</span></span><br><span class="line">Method *class_copyMethodList(Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 动态添加方法</span></span><br><span class="line"><span class="built_in">BOOL</span> class_addMethod(Class cls, SEL name, IMP imp, <span class="keyword">const</span> <span class="keyword">char</span> *types)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 动态替换方法</span></span><br><span class="line">IMP class_replaceMethod(Class cls, SEL name, IMP imp, <span class="keyword">const</span> <span class="keyword">char</span> *types)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. 获取方法的相关信息（带有copy的需要调用free去释放）</span></span><br><span class="line">SEL method_getName(Method m)</span><br><span class="line">IMP method_getImplementation(Method m)</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *method_getTypeEncoding(Method m)</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> method_getNumberOfArguments(Method m)</span><br><span class="line"><span class="keyword">char</span> *method_copyReturnType(Method m)</span><br><span class="line"><span class="keyword">char</span> *method_copyArgumentType(Method m, <span class="keyword">unsigned</span> <span class="keyword">int</span> index)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 7. 选择器相关</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *sel_getName(SEL sel)</span><br><span class="line">SEL sel_registerName(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 8. 用block作为方法实现</span></span><br><span class="line">IMP imp_implementationWithBlock(<span class="keyword">id</span> block)</span><br><span class="line"><span class="keyword">id</span> imp_getBlock(IMP anImp)</span><br><span class="line"><span class="built_in">BOOL</span> imp_removeBlock(IMP anImp)</span><br></pre></td></tr></table></div></figure>        <h3 id="二、RunTime的实际运用场景"   >          <a href="#二、RunTime的实际运用场景" class="heading-link"><i class="fas fa-link"></i></a>二、RunTime的实际运用场景</h3>              <h4 id="1-关联对象，给分类category添加属性；"   >          <a href="#1-关联对象，给分类category添加属性；" class="heading-link"><i class="fas fa-link"></i></a>1) 关联对象，给分类category添加属性；</h4>      <p><code>objc_setAssociatedObject</code>，<code>objc_getAssociatedObject</code></p>        <h4 id="2-方法替换；"   >          <a href="#2-方法替换；" class="heading-link"><i class="fas fa-link"></i></a>2) 方法替换；</h4>      <p><code>class_addMethod</code>，<code>class_replaceMethod</code></p>        <h4 id="3-KVO；"   >          <a href="#3-KVO；" class="heading-link"><i class="fas fa-link"></i></a>3) KVO；</h4>      <p>KVO的实现依赖于 Objective-C 强大的 Runtime，当观察某对象 A 时，KVO 机制动态创建一个对象A当前类的子类，并为这个新的子类重写了被观察属性 keyPath 的 setter 方法。setter 方法随后负责通知观察对象属性的改变状况。</p>        <h4 id="4-字典转模型（MJExtension）；"   >          <a href="#4-字典转模型（MJExtension）；" class="heading-link"><i class="fas fa-link"></i></a>4) 字典转模型（MJExtension）；</h4>              <h4 id="5-自动归档解档；"   >          <a href="#5-自动归档解档；" class="heading-link"><i class="fas fa-link"></i></a>5) 自动归档解档；</h4>              <h4 id="6-利用消息转发机制解决方法找不到的异常问题；"   >          <a href="#6-利用消息转发机制解决方法找不到的异常问题；" class="heading-link"><i class="fas fa-link"></i></a>6) 利用消息转发机制解决方法找不到的异常问题；</h4>      ]]></content>
    
    
    <summary type="html">&lt;img src=&quot;/runtime-6-%E5%AE%9E%E9%99%85%E8%BF%90%E7%94%A8/%E9%87%8D%E6%8B%BEiOS.jpg&quot; class=&quot;&quot;&gt;

&lt;blockquote&gt;
&lt;p&gt;关键词：RunTime&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="重拾iOS" scheme="https://jack110530.github.io/categories/%E9%87%8D%E6%8B%BEiOS/"/>
    
    
    <category term="runtime" scheme="https://jack110530.github.io/tags/runtime/"/>
    
  </entry>
  
  <entry>
    <title>RunTime(5)-super的本质</title>
    <link href="https://jack110530.github.io/runtime-5-super%E7%9A%84%E6%9C%AC%E8%B4%A8/"/>
    <id>https://jack110530.github.io/runtime-5-super%E7%9A%84%E6%9C%AC%E8%B4%A8/</id>
    <published>2020-10-28T03:41:32.000Z</published>
    <updated>2020-11-10T07:26:27.668Z</updated>
    
    <content type="html"><![CDATA[<img src="/runtime-5-super%E7%9A%84%E6%9C%AC%E8%B4%A8/%E9%87%8D%E6%8B%BEiOS.jpg" class=""><blockquote><p>关键词：RunTime</p></blockquote><a id="more"></a><p>RunTime系列文章:<br></p><ul><li><a href="https://jack110530.github.io/runtime-1-oc%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9C%AC%E8%B4%A8/">RunTime(1)-OC对象的本质</a></li><li><a href="https://jack110530.github.io/runtime-2-class%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/">RunTime(2)-Class结构分析</a></li><li><a href="https://jack110530.github.io/runtime-3-%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/">RunTime(3)-消息机制</a></li><li><a href="https://jack110530.github.io/runtime-cache%E6%96%B9%E6%B3%95%E7%BC%93%E5%AD%98/">RunTime(4)-Cache方法缓存</a></li><li><a href="https://jack110530.github.io/runtime-5-super%E7%9A%84%E6%9C%AC%E8%B4%A8/">RunTime(5)-super的本质</a></li><li><a href="https://jack110530.github.io/runtime-6-%E5%AE%9E%E9%99%85%E8%BF%90%E7%94%A8/">RunTime(6)-实际运用</a></li><li><a href="https://jack110530.github.io/runtime-7-%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%80/">RunTime(7)-面试题一</a></li><li><a href="https://jack110530.github.io/runtime-8-%E9%9D%A2%E8%AF%95%E9%A2%98%E4%BA%8C/">RunTime(8)-面试题二</a></li></ul>        <h3 id="前言"   >          <a href="#前言" class="heading-link"><i class="fas fa-link"></i></a>前言</h3>      <p>先来看一道面试题：<br></p><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先定义两个类SFPerson和SFStudent</span></span><br><span class="line"><span class="comment">// .h</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SFPerson</span> : <span class="title">NSObject</span></span></span><br><span class="line">- (<span class="keyword">void</span>)run;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// .m</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SFPerson</span></span></span><br><span class="line">- (<span class="keyword">void</span>)run &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// .h</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SFStudent</span> : <span class="title">SFPerson</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// .m</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SFStudent</span></span></span><br><span class="line">- (<span class="keyword">instancetype</span>)init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;[self class] = %@&quot;</span>,[<span class="keyword">self</span> <span class="keyword">class</span>]);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;[self superclass] = %@&quot;</span>,[<span class="keyword">self</span> superclass]);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;[super class] = %@&quot;</span>,[<span class="keyword">super</span> <span class="keyword">class</span>]);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;[super superclass] = %@&quot;</span>,[<span class="keyword">super</span> superclass]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)run &#123;</span><br><span class="line">    [<span class="keyword">super</span> run];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></div></figure><p><strong>问：以下代码将会如何打印?</strong><br><br><code>[[SFStudent alloc] init];</code> <br></p><p><strong>分析：</strong><br></p><ul><li><code>[self class]</code> 这个应该没有什么疑问，结果应该是[self class] = SFStudent</li><li><code>[self superclass]</code> 这个应该没有什么疑问，结果应该是[self superclass] = CLPerson</li><li><code>[super class]</code> 我们重写父类方法的时候，如果需要执行父类方法的逻辑，通常会加一句[super 方法名]，那么super不是指向父类的指针呢，如果是的话，这里的打印结果应该是[super class] = CLPerson</li><li><code>[super superclass]</code> 根据上面的推断，那么这里应该是打印CLPerson的父类，也就是[super superclass] = NSObject</li></ul><p><strong>实际打印结果：</strong><br></p><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TestDemo[<span class="number">3861</span>:<span class="number">132784</span>] [<span class="keyword">self</span> <span class="keyword">class</span>] = SFStudent</span><br><span class="line">TestDemo[<span class="number">3861</span>:<span class="number">132784</span>] [<span class="keyword">self</span> superclass] = SFPerson</span><br><span class="line">TestDemo[<span class="number">3861</span>:<span class="number">132784</span>] [<span class="keyword">super</span> <span class="keyword">class</span>] = SFStudent</span><br><span class="line">TestDemo[<span class="number">3861</span>:<span class="number">132784</span>] [<span class="keyword">super</span> superclass] = SFPerson</span><br></pre></td></tr></table></div></figure><p>通过实际的代码调试，我们看到[super class]和[super superclass]的打印结果不是我们所预期的。怎么回事呢？</p>        <h3 id="一、super的本质"   >          <a href="#一、super的本质" class="heading-link"><i class="fas fa-link"></i></a>一、super的本质</h3>      <p>为了研究本质，故技重施，我们可以使用clang先将代码转化为C++代码。<br></p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc SFStudent.m -o SFStudent.cpp</span><br></pre></td></tr></table></div></figure><p>转化后，主要看run方法：<br></p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _I_SFStudent_run(SFStudent * self, SEL _cmd) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [super run];</span></span><br><span class="line">    ((<span class="keyword">void</span> (*)(__rw_objc_super *, SEL))(<span class="keyword">void</span> *)objc_msgSendSuper)((__rw_objc_super)&#123;(id)self, (id)class_getSuperclass(objc_getClass(<span class="string">&quot;SFStudent&quot;</span>))&#125;, sel_registerName(<span class="string">&quot;run&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// NSLog(@&quot;SFStudent Run&quot;);</span></span><br><span class="line">    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_7__p19yp82j0xd2m_1k8fpr77z40000gn_T_SFStudent_5be081_mi_0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// =====简化一下=====</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _I_SFStudent_run(SFStudent * self, SEL _cmd) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [super run];</span></span><br><span class="line">   objc_msgSendSuper((__rw_objc_super)&#123;</span><br><span class="line">            (id)self,   </span><br><span class="line">            (id)class_getSuperclass(objc_getClass(<span class="string">&quot;SFStudent&quot;</span>))</span><br><span class="line">           &#125;,   </span><br><span class="line">            @selector(run));</span><br><span class="line"></span><br><span class="line"><span class="comment">// NSLog(@&quot;SFStudent Run&quot;);不重要，不用管</span></span><br><span class="line">    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_7__p19yp82j0xd2m_1k8fpr77z40000gn_T_SFStudent_5be081_mi_0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// =====再精简一下=====</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _I_SFStudent_run(SFStudent * self, SEL _cmd) &#123;</span><br><span class="line"><span class="comment">// 结构体单独抽出来</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">rw_objc_super</span> <span class="title">arg</span> =</span> &#123;</span><br><span class="line">            (id)self,   </span><br><span class="line">            (id)class_getSuperclass(objc_getClass(<span class="string">&quot;SFStudent&quot;</span>))</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [super run];</span></span><br><span class="line">   objc_msgSendSuper(arg, @selector(run));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure><p>从精简后的代码，可以看出来，<code>[super run];</code>底层实际上是调用了函数<code>objc_msgSendSuper(arg, @selector(run));</code> <br></p><p>1、首先我们来分析一下它的两个参数。第二个参数相信不用多解释了，就是一个方法选择器<code>SEL</code>，重点看一下第一个参数，这是一个结构体<code>__rw_objc_super</code> <br></p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">rw_objc_super</span> &#123;</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> *<span class="title">object</span>;</span>     <span class="comment">// 消息接受者</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> *<span class="title">superClass</span>;</span> <span class="comment">// 父类</span></span><br><span class="line">__rw_objc_super(struct objc_object *o, struct objc_object *s) : object(o), superClass(s) &#123;&#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure><p>由此可知：<br></p><ul><li>第一个参数object传入的是self，即SFStudent实例对象；<br></li><li>第二个参数superClass传入的是SFPerson类对象，即[SFPerson class]；<br></li></ul><p>2、接着我们来分析一下<code>objc_msgSendSuper</code>这个方法里到底做了什么。<br></p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_msgSendSuper(struct objc_super * _Nonnull super, SEL _Nonnull op, ...)</span><br></pre></td></tr></table></div></figure><ul><li>第一个参数super是一个指向结构体指针<code>struct objc_super *</code>，它里面的内容是<code>&#123;消息接受者 recv， 消息接受者的父类类对象 [[recv superclass] class]&#125;</code>，objc_msgSendSuper会将消息接受者的父类类对象作为消息查找的起点。</li><li>第二个参数op 是消息接受者接受的消息/方法，也就是需要去查找的方法。</li></ul>        <h3 id="二、self和super"   >          <a href="#二、self和super" class="heading-link"><i class="fas fa-link"></i></a>二、self和super</h3>              <h4 id="1）区别："   >          <a href="#1）区别：" class="heading-link"><i class="fas fa-link"></i></a>1）区别：</h4>      <ul><li>self 关键字是类中的一个<strong>隐藏参数</strong>;<ul><li>代表当前类的方法调用者；</li><li>调用对象方法，self代表当前类的实例对象；</li><li>调用类方法，self代表当前类的类对象； </li></ul></li><li>super 是一个<strong>编译器指令</strong>;</li></ul>        <h4 id="2）-self-message-和-super-message-的实现"   >          <a href="#2）-self-message-和-super-message-的实现" class="heading-link"><i class="fas fa-link"></i></a>2）[self message] 和 [super message] 的实现</h4>      <p>不管是self还是super真正调用的对象都是一样的，只是查找方法的位置不一样，self是从当前类结构中开始查找，super是从父类中查找，但方法真正的接受者都是当前类或者当前类的对象；<br></p><p><code>[self message]</code>会转化为<code>objc_msgSend(id self,SEL _cmd)</code>这个函数，在当前类结构中找到方法并且调用<br><code>[super message]</code>会转化为<code>id objc_msgSendSuper(struct __rw_objc_super *super, SEL op, …) </code><br>对比<code>[self message]</code>这里除了函数名加了super以外，第一个参数由self变成了一个结构体:</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">rw_objc_super</span> &#123;</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> *<span class="title">object</span>;</span>     <span class="comment">// 消息接受者</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> *<span class="title">superClass</span>;</span> <span class="comment">// 父类</span></span><br><span class="line">__rw_objc_super(struct objc_object *o, struct objc_object *s) : object(o), superClass(s) &#123;&#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure><p>在执行[super message]时，会做下面的事：<br></p><ol><li>编译器会先构造一个__rw_objc_super的结构体 </li><li>然后去superClass的方法列表中找方法 </li><li>找到之后由object调用</li></ol><p>所以当你用[self Class]和[super Class]打印类的时候，打印的都是同一个类，因为他们只是查找方法的位置不同，但是调用方法的类/对象是一样的.</p>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;/runtime-5-super%E7%9A%84%E6%9C%AC%E8%B4%A8/%E9%87%8D%E6%8B%BEiOS.jpg&quot; class=&quot;&quot;&gt;

&lt;blockquote&gt;
&lt;p&gt;关键词：RunTime&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="重拾iOS" scheme="https://jack110530.github.io/categories/%E9%87%8D%E6%8B%BEiOS/"/>
    
    
    <category term="runtime" scheme="https://jack110530.github.io/tags/runtime/"/>
    
  </entry>
  
  <entry>
    <title>RunTime(4)-Cache方法缓存</title>
    <link href="https://jack110530.github.io/runtime-4-cache%E6%96%B9%E6%B3%95%E7%BC%93%E5%AD%98/"/>
    <id>https://jack110530.github.io/runtime-4-cache%E6%96%B9%E6%B3%95%E7%BC%93%E5%AD%98/</id>
    <published>2020-10-28T03:41:31.000Z</published>
    <updated>2020-11-10T07:26:27.668Z</updated>
    
    <content type="html"><![CDATA[<img src="/runtime-4-cache%E6%96%B9%E6%B3%95%E7%BC%93%E5%AD%98/%E9%87%8D%E6%8B%BEiOS.jpg" class=""><blockquote><p>关键词：RunTime</p></blockquote><a id="more"></a><p>RunTime系列文章:<br></p><ul><li><a href="https://jack110530.github.io/runtime-1-oc%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9C%AC%E8%B4%A8/">RunTime(1)-OC对象的本质</a></li><li><a href="https://jack110530.github.io/runtime-2-class%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/">RunTime(2)-Class结构分析</a></li><li><a href="https://jack110530.github.io/runtime-3-%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/">RunTime(3)-消息机制</a></li><li><a href="https://jack110530.github.io/runtime-cache%E6%96%B9%E6%B3%95%E7%BC%93%E5%AD%98/">RunTime(4)-Cache方法缓存</a></li><li><a href="https://jack110530.github.io/runtime-5-super%E7%9A%84%E6%9C%AC%E8%B4%A8/">RunTime(5)-super的本质</a></li><li><a href="https://jack110530.github.io/runtime-6-%E5%AE%9E%E9%99%85%E8%BF%90%E7%94%A8/">RunTime(6)-实际运用</a></li><li><a href="https://jack110530.github.io/runtime-7-%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%80/">RunTime(7)-面试题一</a></li><li><a href="https://jack110530.github.io/runtime-8-%E9%9D%A2%E8%AF%95%E9%A2%98%E4%BA%8C/">RunTime(8)-面试题二</a></li></ul>        <h3 id="前言"   >          <a href="#前言" class="heading-link"><i class="fas fa-link"></i></a>前言</h3>      <p>从上一节《消息机制》中，我们知道在「消息发送」阶段会先在cache中查找方法，cache中没有时，会去方法列表中查找，找到后也会缓存到cache中。<br><br>先回顾一下，Class的结构：<br></p><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_object &#123;</span><br><span class="line">Class isa;</span><br><span class="line">&#125; *<span class="keyword">id</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> objc_class : objc_object &#123;</span><br><span class="line">    <span class="comment">// Class ISA;</span></span><br><span class="line">    Class superclass;           <span class="comment">// 指向父类</span></span><br><span class="line">    cache_t cache;              <span class="comment">// 用于方法缓存</span></span><br><span class="line">    class_data_bits_t bits;     <span class="comment">// 用于获取具体的类信息</span></span><br><span class="line"></span><br><span class="line">    class_rw_t *data() &#123; </span><br><span class="line">        <span class="keyword">return</span> bits.data();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> setData(class_rw_t *newData) &#123;</span><br><span class="line">        bits.setData(newData);</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//......下面的一堆方法/函数代码可以暂时不用关注</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure><p>在Class中确实有一个用于方法缓存的成员cache，那么，在cache中方法到底是怎么存取的呢？<br><br>其实cache_t cache是通过<strong>散列表</strong>来实现的，类似我们开发中常用的NSDictionary，下面就来着重分析一下：<br></p>        <h3 id="一、cache-t"   >          <a href="#一、cache-t" class="heading-link"><i class="fas fa-link"></i></a>一、cache_t</h3>      <p>先来看看cache_t的结构：<br></p><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> cache_t &#123;</span><br><span class="line">    <span class="keyword">struct</span> bucket_t *_buckets;  <span class="comment">// 用来缓存方法的散列/哈希表</span></span><br><span class="line">    mask_t _mask;               <span class="comment">// 这个值 = 散列表长度 - 1</span></span><br><span class="line">    mask_t _occupied;           <span class="comment">// 表示已经缓存的方法的数量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> bucket_t &#123;</span><br><span class="line">private:</span><br><span class="line">    cache_key_t _key; <span class="comment">// 这个key实际上就是方法的SEL，也就是方法名</span></span><br><span class="line">    IMP _imp;         <span class="comment">// 这个就是方法对应的函数的内存地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>想一想我们平时是怎么使用NSDictionary的，通过一堆Key-Value键值对来进行存储的，NSDictionary的底层就是散列表。方法缓存的时候，key就是上面的cache_key_t _key;，value就是上面的bucket_t结构体对象。<br></p><p>但是散列表的运作原理到底如何呢，这个属于数据结构问题，这里简要介绍一下。首先散列表本质上就是一个数组。<br></p><p>在往散列表里面添加成员的时候，首先需要借助key计算出一个index，然后再将元素插入散列表的index位置。<br></p><img src="/runtime-4-cache%E6%96%B9%E6%B3%95%E7%BC%93%E5%AD%98/set.png" class=""><br><p>那么从散列表里面取值就显而易见了，根据一个key，计算出index，然后到散列表对应位置将值取出。<br></p><img src="/runtime-4-cache%E6%96%B9%E6%B3%95%E7%BC%93%E5%AD%98/get.png" class=""><br><p>这里的查询方法的时候（也就是取值操作），时间复杂度为O(1), 对比我们一开始从方法列表的遍历查询所对应的时间复杂度为O(n)，因此通过缓存方法，可以极大的提高方法查询的效率，从而提高了方法调用机制的效率。<br></p><p>根据key计算出index值的这个算法称作<strong>散列算法</strong>，这个算法可以由你自己设计，总之目的就是尽可能减少不同的key得出相同index的情况出现，这种情况被称作<strong>哈希碰撞</strong>，同时还要保证得出的index值在合理的范围。index越大，意味着对应的散列表的长度越长，这是需要占用实际物理空间的，而我们的内存是有限的。<br></p><p>散列表是一种通过牺牲一定空间，来换取时间效率的设计思想。<br></p><p>我们通过key计算出的index大小是随机的，无顺序的，因此在方法缓存的过程中，插入的顺序也是无顺序的。<br></p><img src="/runtime-4-cache%E6%96%B9%E6%B3%95%E7%BC%93%E5%AD%98/random.png" class=""><br><p>而且可以预见的是，散列表里面再实际使用中会有很多位置是空着的，比如散列表长度为16，最终值存储了10个方法，散列表长度为64，最终可能只会存储40个方法，有一部分空间终究是要被浪费的。但是却提高查找的效率。这既是所谓的<strong>空间换时间</strong>。</p>        <h3 id="二、向cache-t存入方法"   >          <a href="#二、向cache-t存入方法" class="heading-link"><i class="fas fa-link"></i></a>二、向cache_t存入方法</h3>      <img src="/runtime-4-cache%E6%96%B9%E6%B3%95%E7%BC%93%E5%AD%98/setA.png" class=""><br><img src="/runtime-4-cache%E6%96%B9%E6%B3%95%E7%BC%93%E5%AD%98/setB.png" class=""><br><img src="/runtime-4-cache%E6%96%B9%E6%B3%95%E7%BC%93%E5%AD%98/setC.png" class=""><br><img src="/runtime-4-cache%E6%96%B9%E6%B3%95%E7%BC%93%E5%AD%98/setD.png" class=""><br>        <h3 id="三、从cache-t查询方法"   >          <a href="#三、从cache-t查询方法" class="heading-link"><i class="fas fa-link"></i></a>三、从cache_t查询方法</h3>      <img src="/runtime-4-cache%E6%96%B9%E6%B3%95%E7%BC%93%E5%AD%98/getA.png" class=""><br><img src="/runtime-4-cache%E6%96%B9%E6%B3%95%E7%BC%93%E5%AD%98/getC.png" class=""><br><img src="/runtime-4-cache%E6%96%B9%E6%B3%95%E7%BC%93%E5%AD%98/getD.png" class=""><br><img src="/runtime-4-cache%E6%96%B9%E6%B3%95%E7%BC%93%E5%AD%98/getE.png" class=""><br>        <h3 id="四、扩容"   >          <a href="#四、扩容" class="heading-link"><i class="fas fa-link"></i></a>四、扩容</h3>      <blockquote><p>你可能还会有一个疑问，如果不断的往缓存里添加方法，缓存满了怎么办？<br></p></blockquote><p>其实苹果的做法是，在已缓存的方法数量达到当前缓存容量的3/4时候，就会出发扩容操作<code>expand()</code>，源码如下：<br></p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cache_t::expand</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cacheUpdateLock.assertLocked();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">uint32_t</span> oldCapacity = capacity();</span><br><span class="line">    <span class="keyword">uint32_t</span> newCapacity = oldCapacity ? oldCapacity*<span class="number">2</span> : INIT_CACHE_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">uint32_t</span>)(<span class="keyword">mask_t</span>)newCapacity != newCapacity) &#123;</span><br><span class="line">        <span class="comment">// mask overflow - can&#x27;t grow further</span></span><br><span class="line">        <span class="comment">// fixme this wastes one bit of mask</span></span><br><span class="line">        newCapacity = oldCapacity;</span><br><span class="line">    &#125;</span><br><span class="line">    reallocate(oldCapacity, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>上面代码里面<code>uint32_t newCapacity = oldCapacity ? oldCapacity*2 : INIT_CACHE_SIZE;</code>说的很明白，扩容就是将当前缓存容量* 2，如果是首次调用这个函数，会使用一个初始容量值<code>INIT_CACHE_SIZE</code>来设定缓存容量</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    INIT_CACHE_SIZE_LOG2 = <span class="number">2</span>,</span><br><span class="line">    INIT_CACHE_SIZE      = (<span class="number">1</span> &lt;&lt; INIT_CACHE_SIZE_LOG2)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure><p>从INIT_CACHE_SIZE的定义显示它的值是4，也就是说苹果给<strong>cache_t设定的初始容量是4</strong>。</p><blockquote><p>你可能还会问，重置缓存之后，原来老缓存里面的内容还要不要呢?<br></p></blockquote><p>expand()函数里面调用的最后一个函数是<code>reallocate(oldCapacity, newCapacity);</code>，我们在进入它的源码看看:</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cache_t::reallocate</span><span class="params">(<span class="keyword">mask_t</span> oldCapacity, <span class="keyword">mask_t</span> newCapacity)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> freeOld = canBeFreed();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bucket_t</span> *oldBuckets = buckets();</span><br><span class="line">    <span class="keyword">bucket_t</span> *newBuckets = allocateBuckets(newCapacity);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cache&#x27;s old contents are not propagated. </span></span><br><span class="line">    <span class="comment">// This is thought to save cache memory at the cost of extra cache fills.</span></span><br><span class="line">    <span class="comment">// fixme re-measure this</span></span><br><span class="line"></span><br><span class="line">    assert(newCapacity &gt; <span class="number">0</span>);</span><br><span class="line">    assert((<span class="keyword">uintptr_t</span>)(<span class="keyword">mask_t</span>)(newCapacity<span class="number">-1</span>) == newCapacity<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    setBucketsAndMask(newBuckets, newCapacity - <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (freeOld) &#123;</span><br><span class="line">        cache_collect_free(oldBuckets, oldCapacity);</span><br><span class="line">        cache_collect(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>很明显，在最对旧的缓存空间进行了释放，但是条件是<code>freeOld = true</code>，函数开头给出了freeOld的由来，通过<code>canBeFreed()</code>函数获得</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cache_t::isConstantEmptyCache</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line">        occupied() == <span class="number">0</span>  &amp;&amp;  </span><br><span class="line">        buckets() == emptyBucketsForCapacity(capacity(), <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cache_t::canBeFreed</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !isConstantEmptyCache();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p><code>canBeFreed()</code>函数其实很简单，就是判断一下缓存是不是空的，如果空的，旧没必要释放空间了，如果原来的缓存不是空的，就直接释放掉，并且我们发现，扩容的操作里面，并没有对旧的缓存空间里面的内容进行复制保留，就是很粗暴的直接分配一块新的缓存空间，然后直接释放掉旧的缓存空间，这意味着，<strong>每次进行扩容操作之后，原来缓存过的方法就会全部丢失</strong>，而上面的<code>cache_fill_nolock</code>函数里面，在进行完<code>expand()</code>扩容操作之后，也仅仅是把当前处理的方法放到缓存空间里面，因此，扩容之前曾经被缓存过的方法，如果下次再次调用的话，又需要被重新缓存了。</p>        <h3 id="面试题"   >          <a href="#面试题" class="heading-link"><i class="fas fa-link"></i></a>面试题</h3>      <hr><p><strong>1、父类的方法被调用的时候，会如何缓存？</strong><br></p><p>现在，我们知道，当对一个对象发送消息后，会通过对象的isa找到它的Class对象，在Class对象里面先从方法缓存cache_t查找该方法，没有的话再对Class对象的方法列表进行遍历查找，如果找到了方法，就进行缓存并且调用，那么这里肯定是将方法缓存到了该对象的Class对象的cache_t里面。<br></p><p>如果在当前Class对象里面没有找到该方法，那么会通过Class对象的superclass进入其父类的Class对象里面，同样，会先查找它的cache_t,如果没有找到方法，会对其方法列表进行遍历查找，问题就在这里，如果此时在方法列表里面找到了方法，进行缓存操作的时候，是会将方法存入当前父类的Class对象的cache_t里面呢，还是会存到接收消息的对象的Class对象的cache_t里面呢？<br></p><p>答：<br><br>只缓存到接收消息的对象的Class对象的cache_t里。</p><hr><p>[相关参考]<br/></p><ol><li><span class="exturl"><a class="exturl__link"   href="https://blog.csdn.net/u013480070/article/details/100155929" >Runtime笔记（三）—— OC Class的方法缓存cache_t</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> </li></ol>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;/runtime-4-cache%E6%96%B9%E6%B3%95%E7%BC%93%E5%AD%98/%E9%87%8D%E6%8B%BEiOS.jpg&quot; class=&quot;&quot;&gt;

&lt;blockquote&gt;
&lt;p&gt;关键词：RunTime&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="重拾iOS" scheme="https://jack110530.github.io/categories/%E9%87%8D%E6%8B%BEiOS/"/>
    
    
    <category term="runtime" scheme="https://jack110530.github.io/tags/runtime/"/>
    
  </entry>
  
  <entry>
    <title>RunTime(3)-消息机制</title>
    <link href="https://jack110530.github.io/runtime-3-%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/"/>
    <id>https://jack110530.github.io/runtime-3-%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/</id>
    <published>2020-10-28T03:41:30.000Z</published>
    <updated>2020-11-10T07:26:27.668Z</updated>
    
    <content type="html"><![CDATA[<img src="/runtime-3-%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/%E9%87%8D%E6%8B%BEiOS.jpg" class=""><blockquote><p>关键词：RunTime</p></blockquote><a id="more"></a><p>RunTime系列文章:<br></p><ul><li><a href="https://jack110530.github.io/runtime-1-oc%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9C%AC%E8%B4%A8/">RunTime(1)-OC对象的本质</a></li><li><a href="https://jack110530.github.io/runtime-2-class%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/">RunTime(2)-Class结构分析</a></li><li><a href="https://jack110530.github.io/runtime-3-%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/">RunTime(3)-消息机制</a></li><li><a href="https://jack110530.github.io/runtime-cache%E6%96%B9%E6%B3%95%E7%BC%93%E5%AD%98/">RunTime(4)-Cache方法缓存</a></li><li><a href="https://jack110530.github.io/runtime-5-super%E7%9A%84%E6%9C%AC%E8%B4%A8/">RunTime(5)-super的本质</a></li><li><a href="https://jack110530.github.io/runtime-6-%E5%AE%9E%E9%99%85%E8%BF%90%E7%94%A8/">RunTime(6)-实际运用</a></li><li><a href="https://jack110530.github.io/runtime-7-%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%80/">RunTime(7)-面试题一</a></li><li><a href="https://jack110530.github.io/runtime-8-%E9%9D%A2%E8%AF%95%E9%A2%98%E4%BA%8C/">RunTime(8)-面试题二</a></li></ul>        <h3 id="前言"   >          <a href="#前言" class="heading-link"><i class="fas fa-link"></i></a>前言</h3>      <ol><li>我们知道方法查找时，如果找到了，会将方法缓存到cache_t中。那么，当对象所在当前类中没有该方法时，会通过superclass指针去它的父类中查找，如果在父类中找到了该方法时，方法会怎么缓存？是缓存到父类的cache_t中，还是缓存到当前类的cache_t中，还是都会缓存？</li></ol>        <h3 id="一、方法的本质"   >          <a href="#一、方法的本质" class="heading-link"><i class="fas fa-link"></i></a>一、方法的本质</h3>      <p>有了前两节的基础后，我们知道：<br><br>不管是对象方法还是类方法其实都是存在类或元类的bits中，具体一点是存在class_rw_t和class_ro_t中。那么，方法具体是如何被调用的呢？<br><br>如以下代码，person对象时怎么找到test方法，再进行调用的？<br></p><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> play()&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>,__func__);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        SFPerson *person = [SFPerson alloc];</span><br><span class="line">        [person test];</span><br><span class="line">        play();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>同样的，我们可以使用clang先将代码转化成C++代码来研究<br></p><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -rewrite-objc main.m -o main.cpp</span><br></pre></td></tr></table></div></figure><p>转化后的代码是：<br></p><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="comment">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line">        SFPerson *person = ((SFPerson *(*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *)objc_msgSend)((<span class="keyword">id</span>)objc_getClass(<span class="string">&quot;SFPerson&quot;</span>), sel_registerName(<span class="string">&quot;alloc&quot;</span>));</span><br><span class="line">        ((<span class="keyword">void</span> (*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *)objc_msgSend)((<span class="keyword">id</span>)person, sel_registerName(<span class="string">&quot;test&quot;</span>));</span><br><span class="line"></span><br><span class="line">        play();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>可以发现，方法的调用objc_msgSend(id,SEL) 发送消息的方式来实现的。<br></p><p>objec_msgSend的方法定义如下：<br></p><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OBJC_EXPORT objc_msgSend(<span class="keyword">id</span> _Nullable <span class="keyword">self</span>, SEL _Nonnull op, ...)</span><br></pre></td></tr></table></div></figure><p>同样的，play()方法的调用直接就是函数指针调用。<br></p><p>所以，OC对象的方法调用底层是通过objc_msgSend(id,SEL) 发送消息的方式来实现的，那么发送消息的具体流程到底是什么呢？这就是本章节讨论的问题。</p>        <h3 id="二、消息发送"   >          <a href="#二、消息发送" class="heading-link"><i class="fas fa-link"></i></a>二、消息发送</h3>      <p>一个对象的方法像这样[obj foo]，编译器转成消息发送objc_msgSend(obj, foo)，Runtime时执行的流程是这样的：<br></p><ol><li>首先，通过obj的isa指针找到它的class;</li><li>在class的method list找foo;</li><li>如果class中没到foo，继续往它的superclass中找;</li><li>一旦找到foo这个函数，就去执行它的实现IMP；</li></ol><p>但这种实现有个问题，效率低。<br><br>如果每个消息都需要将整个方法列表遍历一次这并不合理，十分损耗性能。但是如果把经常被调用的函数缓存下来，那可以大大提高函数查询的效率。这也就是objc_class中另一个重要成员cache_t cache做的事情。<br><br>在找到foo之后，cache_t会把foo的方法名作为key ，方法实现作为value给存起来。当再次收到foo消息的时候，可以直接在cache里找到，避免去遍历，大大提高了效率。<br></p><p>所以消息发送objc_msgSend的具体的流程应该是：<br></p><ol><li>首先，通过obj的isa指针找到它的class;</li><li>快速查找：在当前类的cache中查找方法，如果找到则调用方法的实现；</li><li>慢速查找：如果cache中没有，则在当前类的方法列表中查找，如果找到则调用方法的实现，并且cache会以该方法的方法名为key，方法的实现为value进行缓存；</li><li>如果当前类中也没有查找到该方法，会通过class的superclass指针找到其父类，在父类中重复第2，3步骤，直到找到为止。</li><li>如果从当前类开始，整条继承关系链的所有相关类中都没有找到该方法，则会进入Runtime的下一个阶段<strong>「消息转发」</strong></li></ol><img src="/runtime-3-%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/msgSend1.png" class=""><br>        <h3 id="三、消息转发"   >          <a href="#三、消息转发" class="heading-link"><i class="fas fa-link"></i></a>三、消息转发</h3>      <p><strong>「消息发送」</strong>中没有找到方法的实现时，会进入<strong>「消息转发」</strong>阶段。<br><br>消息转发主要经历三大阶段：<strong>「动态方法解析」</strong>、<strong>「备用接收者」</strong>、<strong>「完整的消息转发」</strong><br></p><p>1）首先是<strong>「动态方法解析」</strong>，Objective-C运行时会调用 <code>+resolveInstanceMethod:</code>或者 <code>+resolveClassMethod:</code>，让你有机会提供一个函数实现。如果你添加了函数并返回YES， 那运行时系统就会重新启动一次消息发送的过程。<br></p><p>2）然后是<strong>「备用接收者」</strong>，如果目标对象实现了<code>-forwardingTargetForSelector:</code>，RunTime 这时就会调用这个方法，给你把这个消息转发给其他对象的机会。<br></p><p>3）最后是<strong>「完整的消息转发」</strong>，首先它会发送<code>-methodSignatureForSelector:</code>消息获得函数的参数和返回值类型。如果<code>-methodSignatureForSelector:</code>返回<code>nil</code> ，<code>Runtime</code>则会发出 <code>-doesNotRecognizeSelector:</code>消息，程序这时也就挂掉了。如果返回了一个函数签名，Runtime就会创建一个<code>NSInvocation</code> 对象并发送 <code>-forwardInvocation:</code>消息给目标对象。<br></p><img src="/runtime-3-%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/msgSend2.jpg" class=""><br>        <h4 id="1、动态方法解析"   >          <a href="#1、动态方法解析" class="heading-link"><i class="fas fa-link"></i></a>1、动态方法解析</h4>      <p>代码示例：<br></p><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SFPerson</span> : <span class="title">NSObject</span></span></span><br><span class="line">- (<span class="keyword">void</span>)run;</span><br><span class="line">+ (<span class="keyword">void</span>)run;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// .m</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;SFPerson.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> resolvedMethod(<span class="keyword">id</span> obj, SEL _cmd) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;resolvedMethod&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SFPerson</span></span></span><br><span class="line"><span class="comment">//- (void)run &#123;</span></span><br><span class="line"><span class="comment">//    NSLog(@&quot;%s&quot;, __func__);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//+ (void)run &#123;</span></span><br><span class="line"><span class="comment">//    NSLog(@&quot;%s&quot;, __func__);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象方法</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    <span class="keyword">if</span> (sel == <span class="keyword">@selector</span>(run)) &#123;</span><br><span class="line">        class_addMethod([<span class="keyword">self</span> <span class="keyword">class</span>], sel, (IMP)resolvedMethod, <span class="string">&quot;v@:&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类方法</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveClassMethod:(SEL)sel &#123;</span><br><span class="line">    <span class="keyword">if</span> (sel == <span class="keyword">@selector</span>(run)) &#123;</span><br><span class="line">        Class metaClass = objc_getMetaClass([<span class="built_in">NSStringFromClass</span>(<span class="keyword">self</span>) UTF8String]);</span><br><span class="line">        class_addMethod(metaClass , sel, (IMP)resolvedMethod, <span class="string">&quot;v@:&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> resolveClassMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></div></figure><p>在ViewController中：<br></p><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    SFPerson *person = [SFPerson alloc];</span><br><span class="line">    [person run];</span><br><span class="line">    [SFPerson run];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印如下：</span></span><br><span class="line">TestDemo[<span class="number">25114</span>:<span class="number">980378</span>] resolvedMethod</span><br><span class="line">TestDemo[<span class="number">25114</span>:<span class="number">980378</span>] resolvedMethod</span><br></pre></td></tr></table></div></figure>        <h4 id="2、备用接收者"   >          <a href="#2、备用接收者" class="heading-link"><i class="fas fa-link"></i></a>2、备用接收者</h4>      <p>代码示例：<br></p><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SFAnimal</span></span></span><br><span class="line">- (<span class="keyword">void</span>)run &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line">+ (<span class="keyword">void</span>)run &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// .h</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SFPerson</span> : <span class="title">NSObject</span></span></span><br><span class="line">- (<span class="keyword">void</span>)run;</span><br><span class="line">+ (<span class="keyword">void</span>)run;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// .m</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;SFPerson.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;SFAnimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SFPerson</span></span></span><br><span class="line"><span class="comment">//- (void)run &#123;</span></span><br><span class="line"><span class="comment">//    NSLog(@&quot;%s&quot;, __func__);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//+ (void)run &#123;</span></span><br><span class="line"><span class="comment">//    NSLog(@&quot;%s&quot;, __func__);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象方法</span></span><br><span class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="keyword">if</span> (aSelector == <span class="keyword">@selector</span>(run)) &#123;</span><br><span class="line">        <span class="keyword">return</span> [[SFAnimal alloc]init];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类方法</span></span><br><span class="line">+ (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="keyword">if</span> (aSelector == <span class="keyword">@selector</span>(run)) &#123;</span><br><span class="line">        <span class="keyword">return</span> [SFAnimal <span class="keyword">class</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></div></figure><p>在ViewController中：<br></p><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    SFPerson *person = [SFPerson alloc];</span><br><span class="line">    [person run];</span><br><span class="line">    [SFPerson run];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印如下：</span></span><br><span class="line">TestDemo[<span class="number">25114</span>:<span class="number">980378</span>] -[SFAnimal run]</span><br><span class="line">TestDemo[<span class="number">25114</span>:<span class="number">980378</span>] +[SFAnimal run]</span><br></pre></td></tr></table></div></figure>        <h4 id="3、完整的消息转发"   >          <a href="#3、完整的消息转发" class="heading-link"><i class="fas fa-link"></i></a>3、完整的消息转发</h4>      <p>代码示例：<br></p><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .m</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;SFPerson.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;SFAnimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SFPerson</span></span></span><br><span class="line"><span class="comment">//- (void)run &#123;</span></span><br><span class="line"><span class="comment">//    NSLog(@&quot;%s&quot;, __func__);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//+ (void)run &#123;</span></span><br><span class="line"><span class="comment">//    NSLog(@&quot;%s&quot;, __func__);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象方法</span></span><br><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="keyword">if</span> (aSelector == <span class="keyword">@selector</span>(run)) &#123;</span><br><span class="line">        <span class="built_in">NSMethodSignature</span> *sign = [<span class="built_in">NSMethodSignature</span> signatureWithObjCTypes:<span class="string">&quot;v@:&quot;</span>];</span><br><span class="line">        <span class="keyword">return</span> sign;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> methodSignatureForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation &#123;</span><br><span class="line">    SEL sel = anInvocation.selector;</span><br><span class="line">    <span class="keyword">id</span> target = [[SFAnimal alloc]init];</span><br><span class="line">    <span class="keyword">if</span>([target respondsToSelector:sel]) &#123;</span><br><span class="line">        [anInvocation invokeWithTarget:target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 类方法</span></span><br><span class="line">+ (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="keyword">if</span> (aSelector == <span class="keyword">@selector</span>(run)) &#123;</span><br><span class="line">        <span class="built_in">NSMethodSignature</span> *sign = [<span class="built_in">NSMethodSignature</span> signatureWithObjCTypes:<span class="string">&quot;v@:&quot;</span>];</span><br><span class="line">        <span class="keyword">return</span> sign;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> methodSignatureForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line">+ (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation &#123;</span><br><span class="line">    SEL sel = anInvocation.selector;</span><br><span class="line">    <span class="keyword">id</span> target = [SFAnimal <span class="keyword">class</span>];</span><br><span class="line">    <span class="keyword">if</span>([target respondsToSelector:sel]) &#123;</span><br><span class="line">        [anInvocation invokeWithTarget:target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></div></figure><p>在ViewController中：<br></p><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    SFPerson *person = [SFPerson alloc];</span><br><span class="line">    [person run];</span><br><span class="line">    [SFPerson run];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印如下：</span></span><br><span class="line">TestDemo[<span class="number">25114</span>:<span class="number">980378</span>] -[SFAnimal run]</span><br><span class="line">TestDemo[<span class="number">25114</span>:<span class="number">980378</span>] +[SFAnimal run]</span><br></pre></td></tr></table></div></figure>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;/runtime-3-%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/%E9%87%8D%E6%8B%BEiOS.jpg&quot; class=&quot;&quot;&gt;

&lt;blockquote&gt;
&lt;p&gt;关键词：RunTime&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="重拾iOS" scheme="https://jack110530.github.io/categories/%E9%87%8D%E6%8B%BEiOS/"/>
    
    
    <category term="runtime" scheme="https://jack110530.github.io/tags/runtime/"/>
    
  </entry>
  
  <entry>
    <title>RunTime(2)-Class结构分析</title>
    <link href="https://jack110530.github.io/runtime-2-class%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/"/>
    <id>https://jack110530.github.io/runtime-2-class%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/</id>
    <published>2020-10-28T03:40:59.000Z</published>
    <updated>2020-11-10T07:26:27.668Z</updated>
    
    <content type="html"><![CDATA[<img src="/runtime-2-class%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/%E9%87%8D%E6%8B%BEiOS.jpg" class=""><blockquote><p>关键词：RunTime</p></blockquote><a id="more"></a><p>RunTime系列文章:<br></p><ul><li><a href="https://jack110530.github.io/runtime-1-oc%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9C%AC%E8%B4%A8/">RunTime(1)-OC对象的本质</a></li><li><a href="https://jack110530.github.io/runtime-2-class%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/">RunTime(2)-Class结构分析</a></li><li><a href="https://jack110530.github.io/runtime-3-%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/">RunTime(3)-消息机制</a></li><li><a href="https://jack110530.github.io/runtime-cache%E6%96%B9%E6%B3%95%E7%BC%93%E5%AD%98/">RunTime(4)-Cache方法缓存</a></li><li><a href="https://jack110530.github.io/runtime-5-super%E7%9A%84%E6%9C%AC%E8%B4%A8/">RunTime(5)-super的本质</a></li><li><a href="https://jack110530.github.io/runtime-6-%E5%AE%9E%E9%99%85%E8%BF%90%E7%94%A8/">RunTime(6)-实际运用</a></li><li><a href="https://jack110530.github.io/runtime-7-%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%80/">RunTime(7)-面试题一</a></li><li><a href="https://jack110530.github.io/runtime-8-%E9%9D%A2%E8%AF%95%E9%A2%98%E4%BA%8C/">RunTime(8)-面试题二</a></li></ul>        <h3 id="前言"   >          <a href="#前言" class="heading-link"><i class="fas fa-link"></i></a>前言</h3>      <p>上一节，我们通过clang将main.m转化成了main.cpp，通过研究C++代码来研究OC对象的底层结构。<br></p><p>我们知道：实例对象、类对象、元类对象之间的关系如下：<br></p><img src="/runtime-2-class%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/isa.png" class=""><p>由图，我们可以猜测到：<br><br>首先，不管实例对象、类对象还是元类对象，都有isa指针。<br><br>其次，类对象和元类对象中还有superclass指针，指向父类。<br></p><p>那么，Class对象的底层结构，具体是怎样的呢？<br></p>        <h3 id="一、Class的结构"   >          <a href="#一、Class的结构" class="heading-link"><i class="fas fa-link"></i></a>一、Class的结构</h3>      <p>Class的结构如下：<br></p><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_object &#123;</span><br><span class="line">Class isa;</span><br><span class="line">&#125; *<span class="keyword">id</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> objc_class : objc_object &#123;</span><br><span class="line">    <span class="comment">// Class ISA;</span></span><br><span class="line">    Class superclass;           <span class="comment">// 指向父类</span></span><br><span class="line">    cache_t cache;              <span class="comment">// 用于方法缓存</span></span><br><span class="line">    class_data_bits_t bits;     <span class="comment">// 用于获取具体的类信息</span></span><br><span class="line"></span><br><span class="line">    class_rw_t *data() &#123; </span><br><span class="line">        <span class="keyword">return</span> bits.data();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> setData(class_rw_t *newData) &#123;</span><br><span class="line">        bits.setData(newData);</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//......下面的一堆方法/函数代码可以暂时不用关注</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure><p><strong>Class ISA</strong><br><br>objc_class结构体内ISA是被注释的，不代表结构体内不包含它，因为objc_class继承objc_object，所以ISA是来自于父类。<br></p><p><strong>Class superclass</strong><br><br>指向父类的指针，superclass的结构同样是objc_class，因为它是结构体指针，占有8个字节。<br></p><p><strong>cache_t cache</strong><br><br>cache是方法缓存,方法缓存涉及到方法查找流程，缓存策略，动态扩容等，点击<a href="https://jack110530.github.io/runtime-cache%E6%96%B9%E6%B3%95%E7%BC%93%E5%AD%98/">RunTime(4)-Cache方法缓存</a>可查看详细说明，这里不展开讨论。<br></p><p><strong>class_data_bits_t bits</strong><br><br>重点讨论这部分内容。<br></p><p>在Class的结构中，我们发现：<strong>bits</strong>用于获取具体的类信息，有没有很眼熟的感觉。<br></p><p>首先，我们先来看在Class的结构中的这一对setter/getter方法:<br></p><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class_rw_t *data() &#123; </span><br><span class="line">    <span class="keyword">return</span> bits.data();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> setData(class_rw_t *newData) &#123;</span><br><span class="line">    bits.setData(newData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>点击查看bits.data()方法，发现：<br></p><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class_rw_t* data() &#123;</span><br><span class="line">    <span class="keyword">return</span> (class_rw_t *)(bits &amp; FAST_DATA_MASK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>看到这里，你或许已经发现了点端倪<br><br>没错，和isa_t类似，使用的是共用体+位域来存储更多的信息。<br></p><p>跟我们之前通过isa获取对象地址操作很像，这里是将类对象里面的class_data_bits_t bits和一个FAST_DATA_MASK进行&amp;运算取得。返回的是一个指针，类型为class_rw_t *，查看该类型的源码如下：<br></p><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> class_rw_t &#123;</span><br><span class="line">    <span class="comment">// Be warned that Symbolication knows the layout of this structure.</span></span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint32_t version;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> class_ro_t *ro;</span><br><span class="line"></span><br><span class="line">    method_array_t methods;         <span class="comment">// 方法列表</span></span><br><span class="line">    property_array_t properties;    <span class="comment">// 属性列表</span></span><br><span class="line">    protocol_array_t protocols;     <span class="comment">// 协议列表</span></span><br><span class="line"></span><br><span class="line">    Class firstSubclass;</span><br><span class="line">    Class nextSiblingClass;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *demangledName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>我们知道，OC类的方法、属性、协议都是可以动态添加，也就是可读可写的，从上面的源码中，可以发现确实是有对应的成员来保存方法、属性、协议的信息。而从该结构体的名字class_rw_t，也暗含了上述的方法、属性、协议信息，是可读可写的。<br></p><p>另外，我们知道Class类里面的成员变量是不可以动态添加的，也就是属于只读内容，相应的，可以推断const class_ro_t *ro;就是指向了该部分内容信息的指针。同样，查看其源码：<br></p><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> class_ro_t &#123;</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint32_t instanceStart;</span><br><span class="line">    uint32_t instanceSize;          <span class="comment">// instance对象占用的内存空间</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __LP64__</span></span><br><span class="line">    uint32_t reserved;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> uint8_t * ivarLayout;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * name;              <span class="comment">// 类名</span></span><br><span class="line">    method_list_t * baseMethodList; <span class="comment">// 方法列表</span></span><br><span class="line">    protocol_list_t * baseProtocols;<span class="comment">// 协议列表</span></span><br><span class="line">    <span class="keyword">const</span> ivar_list_t * ivars;      <span class="comment">// 成员变量列表</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> uint8_t * weakIvarLayout;</span><br><span class="line">    property_list_t *baseProperties;<span class="comment">//属性列表</span></span><br><span class="line"></span><br><span class="line">    method_list_t *baseMethods() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> baseMethodList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>以上的发现都符合逻辑，但是发现这里面也有跟类的方法、属性、协议相关的信息：</p><ul><li>method_list_t * baseMethodList;</li><li>protocol_list_t * baseProtocols;</li><li>property_list_t *baseProperties;，</li></ul><p>这跟我们前面在class_rw_t中看到的：</p><ul><li>method_array_t methods;</li><li>property_array_t properties;</li><li>protocol_array_t protocols;</li></ul><p>有何关联？有何不同呢？带着这些疑问，继续往下分析。<br></p><p>首先，用一张图总结一下Class的结构：<br></p><img src="/runtime-2-class%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/class.png" class=""><br><p>这个图可以理解成稳定状态下，Class的内部结构。但事实上，在程序启动和初始化过程中，Class并不是这样的结构。<br></p><p>原因在于，由于Runtime特性，OC类的方法、属性、协议都是可以动态添加的。比如Category的实现原理。<br></p><blockquote><p>那么，Class在不同状态下的结构是什么样的呢？</p></blockquote><p>1、最开始的时候，Class是没有读写部分的，只有只读部分，也就是ro = (const class_ro_t *)cls-&gt;data();</p><img src="/runtime-2-class%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/rw1.png" class=""><br><p>2、接下来，才会分配空间给读写信息，也就是rw，然后通过rw-&gt;ro = ro;将class_rw_t自身的ro指针指向真正的ro信息。</p><img src="/runtime-2-class%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/rw2.png" class=""><br><p>3、通过cls-&gt;setData(rw);将cls-&gt;data()进行修改，并最终通过FAST_DATA_MASK作用指向rw。</p><img src="/runtime-2-class%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/rw3.png" class=""><br><p>回到我们上面的问题：</p><blockquote><p>class_ro_t和class_rw_t中都有方法列表，它们有什么区别呢？</p></blockquote>        <h3 id="二、class-ro-t"   >          <a href="#二、class-ro-t" class="heading-link"><i class="fas fa-link"></i></a>二、class_ro_t</h3>      <p>实际上，class_ro_t代表Class的只读信息，也就是Class本身的固有信息，再直接一点就是是写在它的@interface和@end之间的方法，属性，等信息，当然最重要的作用还是存放类的成员变量信息ivars，而且是被const修饰说明是不可修改的，这也就是为什么Runtime无法动态增加成员变量，底层结构决定的。我个人将这部分理解成OC的静态信息。<br></p><p>class_ro_t中的method_list_t * baseMethodList;//方法列表，是一个一维数组，里面装的就是这个Class本身的方法。</p><img src="/runtime-2-class%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/class_ro_t.png" class=""><br>        <h3 id="三、class-rw-t"   >          <a href="#三、class-rw-t" class="heading-link"><i class="fas fa-link"></i></a>三、class_rw_t</h3>      <p>在有了class_rw_t之后，便会进行category的处理，将Class本身的方法列表和category里面的方法列表先后放到class_rw_t的method_array_t methods里面，Class自身的方法列表会被最先放入其中，并且置于列表的尾部，category方法列表的加入顺序等同与category文件参与编译的顺序(可在XCode中Build Phase中查看)。<br></p><p>因此，method_array_t methods;是一个二维数组，如下图：</p><img src="/runtime-2-class%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/class_rw_t.png" class=""><br>        <h3 id="四、method-t"   >          <a href="#四、method-t" class="heading-link"><i class="fas fa-link"></i></a>四、method_t</h3>      <p>上面我们剖析了class_rw_t、class_ro_t这两个重要部分的结构，并且主要关注了其中的方法列表部分，而从上面的分析，可发现里面最基本也是重要的单位是method_t，这个结构体包含了描述一个方法所需要的各种信息。下面，就对它进行一次彻底的扫描。<br>首先看一下源码里面对它的定义</p><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> method_t &#123;</span><br><span class="line">    SEL name;           <span class="comment">// 方法名</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *types;  <span class="comment">// 函数类型编码</span></span><br><span class="line">    IMP imp;            <span class="comment">// 函数实现</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure><p><strong>IMP imp</strong><br><br>指向函数的指针（也就是方法/函数实现的地址)，它也是在objc.h 里面被定义的：typedef id _Nullable (*IMP)(id _Nonnull, SEL _Nonnull, …);<br></p><p><strong>SEL name</strong><br><br>我们都知到SEL是方法选择器，可以理解成方法的名字，但是它到底是什么鬼？其实，他是在objc.h 里面被定义的：typedef struct objc_selector *SEL;，它就是一个指针类型，指向了结构体类型struct objc_selector，很遗憾苹果没有对其开源，但是请看下面的代码<br></p><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>,<span class="keyword">@selector</span>(test));</span><br><span class="line">&#125;</span><br><span class="line">-(<span class="keyword">void</span>)test &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印：</span></span><br><span class="line">TestDemo[<span class="number">14522</span>:<span class="number">434952</span>] test</span><br></pre></td></tr></table></div></figure><p>从结果看，利用test方法的SEL指针进行打印，输出了test字符串，说明结构体struct objc_selector内部包含了一个char *的成员变量，并且应该是该结构体的第一个成员。因此我们可以用字符串来理解SEL，它主要的作用就是用来表示方法的名字。它与字符串之间可通过如下方法转换：</p><ul><li>可以通过@selector()和sel_registerName()将字符串转换成SEL；</li><li>可以通过sel_getName()和NSStringFromSelector()将SEL转换成字符串；</li><li>不同类中的相同名字的方法，所对应的SEL是相同的，也就是说对于XXX方法来说，它们的SEL都指向内存里同一个struct objc_selector结构体对象，不论有多少个类里面定义了该XXX方法；</li></ul><p>const char *types<br><br>函数类型编码（包括返回值类型、参数类型），iOS提供了一个@encode指令，可以将具体的类型表示成字符串编码，也就是通过字符串来表示类型。主要目的是为了方便运行时，将函数的返回值和参数的类型通过字符串来描述并且存储。请看如下代码示例：</p><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>,<span class="keyword">@encode</span>(<span class="keyword">int</span>));</span><br><span class="line"> <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>,<span class="keyword">@encode</span>(<span class="keyword">float</span>));</span><br><span class="line"> <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>,<span class="keyword">@encode</span>(<span class="keyword">int</span> *));</span><br><span class="line"> <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>,<span class="keyword">@encode</span>(<span class="keyword">id</span>));</span><br><span class="line"> <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>,<span class="keyword">@encode</span>(<span class="keyword">void</span>));</span><br><span class="line"> <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>,<span class="keyword">@encode</span>(SEL));</span><br><span class="line"> <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>,<span class="keyword">@encode</span>(<span class="keyword">float</span> *));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印如下：</span></span><br><span class="line">TestDemo[<span class="number">14620</span>:<span class="number">442479</span>] i</span><br><span class="line">TestDemo[<span class="number">14620</span>:<span class="number">442479</span>] f</span><br><span class="line">TestDemo[<span class="number">14620</span>:<span class="number">442479</span>] ^i</span><br><span class="line">TestDemo[<span class="number">14620</span>:<span class="number">442479</span>] @</span><br><span class="line">TestDemo[<span class="number">14620</span>:<span class="number">442479</span>] v</span><br><span class="line">TestDemo[<span class="number">14620</span>:<span class="number">442479</span>] :</span><br><span class="line">TestDemo[<span class="number">14620</span>:<span class="number">442479</span>] ^f</span><br></pre></td></tr></table></div></figure><p>从上面的打印可以看出各种不同的类型所对应的字符串表达。OC的方法的类型也是按照这个方法来表示的，只不过是把方法里面的返回值和参数的类型组合起来表示。<br></p><p>例如<code>- (int)test:(int)age height:(float)height</code>，我们知道OC方法对应的底层函数前两个是默认参数id self 和SEL cmd，那么刚才的方法从左到右，返回值和参数的类型分别为int-&gt;id-&gt;SEL-&gt;int-&gt;float，转换成类型编码，就是i-@-:-i-f，而最终系统是这样表示的i24@0:8i16f20，你应该会好奇，里面怎么多了一些数字，其实它们是用来描述函数的参数的长度和位置的的，从左到右可以这么解读：</p><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">i —— 函数的返回值类型为int</span><br><span class="line">24 —— 参数所占的总长度（24字节）</span><br><span class="line">@ —— 第一个参数id</span><br><span class="line">0 —— 第一个参数在内存中的起始偏移量（0字节，也就是从第0个字节开始算起）</span><br><span class="line">: —— 第二个参数SEL</span><br><span class="line">8 —— 第二个参数在内存中的起始偏移量（8字节，也就是从第8个字节开始算起,因此上面的id参数占之前的8个字节）</span><br><span class="line">i —— 第三个参数int</span><br><span class="line">16 —— 第三个参数在内存中的起始偏移量（16字节，也就是从第16个字节开始算起，因此上面的SEL参数占用了之前的8个字节）</span><br><span class="line">f —— 第四个参数float</span><br><span class="line">20 —— 第四个参数在内存中的起始偏移量（20字节，也就是从第20个字节开始算起，因此上面的int参数占用了前面的4个字节，而总长度为24，因此最后的4个字节是给float参数用的）</span><br></pre></td></tr></table></div></figure><p>如此一来，对于任意的OC方法，它的method_t里面的types字符串的值都可以依照上面的过程推导出来了。你在苹果官方文档搜索Type Encoding就可以找到更具体的介绍，里面有所有参数类型对应的字符串表达对照表。</p><img src="/runtime-2-class%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/encoding.png" class=""><br><p>根据上面的研究，method_t里面的三个成员变量就提供了我们对于一个OC方法所需要的所有信息，关于method_t的解读就暂到这里。</p><hr><p>[相关参考]<br/></p><ol><li><span class="exturl"><a class="exturl__link"   href="https://blog.csdn.net/u013480070/article/details/100155849" >Runtime笔记（二）—— Class结构的深入分析</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> </li></ol>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;/runtime-2-class%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/%E9%87%8D%E6%8B%BEiOS.jpg&quot; class=&quot;&quot;&gt;

&lt;blockquote&gt;
&lt;p&gt;关键词：RunTime&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="重拾iOS" scheme="https://jack110530.github.io/categories/%E9%87%8D%E6%8B%BEiOS/"/>
    
    
    <category term="runtime" scheme="https://jack110530.github.io/tags/runtime/"/>
    
  </entry>
  
  <entry>
    <title>RunTime(1)-OC对象的本质</title>
    <link href="https://jack110530.github.io/runtime-1-oc%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9C%AC%E8%B4%A8/"/>
    <id>https://jack110530.github.io/runtime-1-oc%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9C%AC%E8%B4%A8/</id>
    <published>2020-10-28T03:40:43.000Z</published>
    <updated>2020-11-10T07:26:27.693Z</updated>
    
    <content type="html"><![CDATA[<img src="/runtime-1-oc%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9C%AC%E8%B4%A8/%E9%87%8D%E6%8B%BEiOS.jpg" class=""><blockquote><p>关键词：RunTime</p></blockquote><a id="more"></a><p>RunTime系列文章:<br></p><ul><li><a href="https://jack110530.github.io/runtime-1-oc%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9C%AC%E8%B4%A8/">RunTime(1)-OC对象的本质</a></li><li><a href="https://jack110530.github.io/runtime-2-class%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/">RunTime(2)-Class结构分析</a></li><li><a href="https://jack110530.github.io/runtime-3-%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/">RunTime(3)-消息机制</a></li><li><a href="https://jack110530.github.io/runtime-cache%E6%96%B9%E6%B3%95%E7%BC%93%E5%AD%98/">RunTime(4)-Cache方法缓存</a></li><li><a href="https://jack110530.github.io/runtime-5-super%E7%9A%84%E6%9C%AC%E8%B4%A8/">RunTime(5)-super的本质</a></li><li><a href="https://jack110530.github.io/runtime-6-%E5%AE%9E%E9%99%85%E8%BF%90%E7%94%A8/">RunTime(6)-实际运用</a></li><li><a href="https://jack110530.github.io/runtime-7-%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%80/">RunTime(7)-面试题一</a></li><li><a href="https://jack110530.github.io/runtime-8-%E9%9D%A2%E8%AF%95%E9%A2%98%E4%BA%8C/">RunTime(8)-面试题二</a></li></ul>        <h3 id="前言"   >          <a href="#前言" class="heading-link"><i class="fas fa-link"></i></a>前言</h3>      <ol><li>OC对象的本质是什么？</li><li>对象的isa指针指向哪里？</li><li>一个NSObject对象占用多少内存？</li></ol>        <h3 id="一、RunTime-简介"   >          <a href="#一、RunTime-简介" class="heading-link"><i class="fas fa-link"></i></a>一、RunTime 简介</h3>      <p>首先，OC是一种动态性比较强的语言，它是对C语言进行了扩展，并集成了smalltalk的动态语言特性，能够让程序在运行时做更多的事情。<br></p><p>Runtime顾名思义，运行时。是由C和C++、汇编实现的一套API，是OC面向对象和动态机制的基石。<br></p>        <h3 id="二、OC对象的本质"   >          <a href="#二、OC对象的本质" class="heading-link"><i class="fas fa-link"></i></a>二、OC对象的本质</h3>      <p>我们知道任何高级语言写出来的程序想要在手机/电脑中正常运行，就必须先转化为机器语言，因为设备只认识机器语言。<br></p><p>那么，我们日常写的OC代码，最终是怎么在设备中正常运行的呢？<br></p><p>可以简单的理解为：</p><blockquote><p>Objective-C  ➡️  C/C++  ➡️  汇编语言  ➡️  机器语言</p></blockquote><p>所以Objective-C的面向对象都是基于C/C++的数据结构实现的，OC对象内部可以容纳不同数据类型的数据，因此可以推断OC对象的底层数据结构就是<strong>结构体</strong>。<br></p><p>既然如此，我们可以利用LLVM编译器前端clang中-rewrite-objc将我们的OC代码转为C/C++实现，来研究OC对象的本质。<br></p><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -rewrite-objc main.m -o main.cpp</span><br></pre></td></tr></table></div></figure><p>由于不同平台支持的代码肯定是不一样的，目前我们关注点是iOS开发，建议在将OC代码转成C/C++代码指定平台：<br></p><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -sdk:指定sdk</span></span><br><span class="line"><span class="comment">// -arch:指定机器cpu架构（模拟器-i386、32bit、64bit-arm64 ）</span></span><br><span class="line"><span class="comment">// 如果需要链接其他框架，使用-framework参数，比如-framework UIKit</span></span><br><span class="line">xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc &lt;OC源文件&gt; -o &lt;输出的cpp文件&gt;</span><br></pre></td></tr></table></div></figure><p>通过生成的C/C++代码，我们编写的OC对象NSObject的底层实现为:</p><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class;</span><br><span class="line"><span class="comment">// NSObject的底层实现</span></span><br><span class="line"><span class="keyword">struct</span> <span class="built_in">NSObject_IMPL</span> &#123;</span><br><span class="line">    Class isa;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>        <h3 id="三、isa详解"   >          <a href="#三、isa详解" class="heading-link"><i class="fas fa-link"></i></a>三、isa详解</h3>      <p>开发中，常用的对象有三类：</p><ul><li>实例对象（instance）</li><li>类对象（class）</li><li>元类对象（meta-class）</li></ul><p>不管是哪种类型的对象，其本质都是objc_object结构体，内部都有一个isa指针。<br></p><p>在早期的Runtime里面，isa指针直接指向class/meta-class对象的地址，isa就是一个普通的指针。<br></p><p>后来，苹果从ARM64位架构开始，对isa进行了优化，将其定义成一个<strong>共用体</strong>（union）结构，结合 <strong>位域</strong> 的概念以及 位运算 的方式来存储更多类相关信息。isa指针需要通过与一个叫ISA_MASK的值（掩码）进行二进制&amp;运算，才能得到真实的class/meta-class对象的地址。<br></p><p>首先从源码角度，对比一下变化isa优化前后的变化。<br></p><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_object &#123;</span><br><span class="line">Class isa;</span><br><span class="line">&#125; *<span class="keyword">id</span>;</span><br></pre></td></tr></table></div></figure><p>上面是64位之前，objc_object的定义如上，isa直接指向objc_class。<br></p><p>再看看优化后objc_object的定义:<br></p><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_object &#123;</span><br><span class="line">private:</span><br><span class="line">    isa_t isa;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line"><span class="comment">// ....</span></span><br></pre></td></tr></table></div></figure><p>arm64开始，isa的类型变成了isa_t，这是什么鬼？这个就是接下来讨论的重点，先看一下它的源码。<br></p><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> isa_t </span><br><span class="line">&#123;</span><br><span class="line">    isa_t() &#123; &#125;</span><br><span class="line">    isa_t(uintptr_t value) : bits(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    Class cls;</span><br><span class="line">    uintptr_t bits;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_PACKED_ISA</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> __arm64__</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MASK        0x0000000ffffffff8ULL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MAGIC_MASK  0x000003f000000001ULL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MAGIC_VALUE 0x000001a000000001ULL</span></span><br><span class="line">    <span class="keyword">struct</span> &#123;</span><br><span class="line">        uintptr_t nonpointer        : <span class="number">1</span>;</span><br><span class="line">        uintptr_t has_assoc         : <span class="number">1</span>;</span><br><span class="line">        uintptr_t has_cxx_dtor      : <span class="number">1</span>;</span><br><span class="line">        uintptr_t shiftcls          : <span class="number">33</span>; <span class="comment">// MACH_VM_MAX_ADDRESS 0x1000000000</span></span><br><span class="line">        uintptr_t magic             : <span class="number">6</span>;</span><br><span class="line">        uintptr_t weakly_referenced : <span class="number">1</span>;</span><br><span class="line">        uintptr_t deallocating      : <span class="number">1</span>;</span><br><span class="line">        uintptr_t has_sidetable_rc  : <span class="number">1</span>;</span><br><span class="line">        uintptr_t extra_rc          : <span class="number">19</span>;</span><br><span class="line"><span class="meta">#       <span class="meta-keyword">define</span> RC_ONE   (1ULL&lt;&lt;45)</span></span><br><span class="line"><span class="meta">#       <span class="meta-keyword">define</span> RC_HALF  (1ULL&lt;&lt;18)</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">elif</span> __x86_64__</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MASK        0x00007ffffffffff8ULL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MAGIC_MASK  0x001f800000000001ULL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MAGIC_VALUE 0x001d800000000001ULL</span></span><br><span class="line">    <span class="keyword">struct</span> &#123;</span><br><span class="line">        uintptr_t nonpointer        : <span class="number">1</span>;</span><br><span class="line">        uintptr_t has_assoc         : <span class="number">1</span>;</span><br><span class="line">        uintptr_t has_cxx_dtor      : <span class="number">1</span>;</span><br><span class="line">        uintptr_t shiftcls          : <span class="number">44</span>; <span class="comment">// MACH_VM_MAX_ADDRESS 0x7fffffe00000</span></span><br><span class="line">        uintptr_t magic             : <span class="number">6</span>;</span><br><span class="line">        uintptr_t weakly_referenced : <span class="number">1</span>;</span><br><span class="line">        uintptr_t deallocating      : <span class="number">1</span>;</span><br><span class="line">        uintptr_t has_sidetable_rc  : <span class="number">1</span>;</span><br><span class="line">        uintptr_t extra_rc          : <span class="number">8</span>;</span><br><span class="line"><span class="meta">#       <span class="meta-keyword">define</span> RC_ONE   (1ULL&lt;&lt;56)</span></span><br><span class="line"><span class="meta">#       <span class="meta-keyword">define</span> RC_HALF  (1ULL&lt;&lt;7)</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">error</span> unknown architecture for packed isa</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// SUPPORT_PACKED_ISA</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_INDEXED_ISA</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span>  __ARM_ARCH_7K__ &gt;= 2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_INDEX_IS_NPI      1</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_INDEX_MASK        0x0001FFFC</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_INDEX_SHIFT       2</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_INDEX_BITS        15</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_INDEX_COUNT       (1 &lt;&lt; ISA_INDEX_BITS)</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_INDEX_MAGIC_MASK  0x001E0001</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_INDEX_MAGIC_VALUE 0x001C0001</span></span><br><span class="line">    <span class="keyword">struct</span> &#123;</span><br><span class="line">        uintptr_t nonpointer        : <span class="number">1</span>;</span><br><span class="line">        uintptr_t has_assoc         : <span class="number">1</span>;</span><br><span class="line">        uintptr_t indexcls          : <span class="number">15</span>;</span><br><span class="line">        uintptr_t magic             : <span class="number">4</span>;</span><br><span class="line">        uintptr_t has_cxx_dtor      : <span class="number">1</span>;</span><br><span class="line">        uintptr_t weakly_referenced : <span class="number">1</span>;</span><br><span class="line">        uintptr_t deallocating      : <span class="number">1</span>;</span><br><span class="line">        uintptr_t has_sidetable_rc  : <span class="number">1</span>;</span><br><span class="line">        uintptr_t extra_rc          : <span class="number">7</span>;</span><br><span class="line"><span class="meta">#       <span class="meta-keyword">define</span> RC_ONE   (1ULL&lt;&lt;25)</span></span><br><span class="line"><span class="meta">#       <span class="meta-keyword">define</span> RC_HALF  (1ULL&lt;&lt;6)</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">error</span> unknown architecture for indexed isa</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// SUPPORT_INDEXED_ISA</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></div></figure><p>通过位运算和位域以及联合体技术，更加充分的利用了isa的内存空间，将对象的真正的地址存放在了isa内存的其中33位上面，其余的31位被用来存放对象相关的其他信息。下面是isa其他位上的作用说明：<br></p><ul><li><strong>nonpointer</strong> <ul><li>0，代表普通指针，存储着class、meta-class对象的内存地址；</li><li>1，代表优化过，使用位域存储更多信息；</li></ul></li><li><strong>has_assoc</strong> 是否设置过关联对象，如果没有，施放时会速度更快；</li><li><strong>has_cxx_dtor</strong> 是否有C++的稀构函数，如果没有，施放时会更快；</li><li><strong>shiftcls</strong> 这个部分存储的是真正的Class、Meta-Class对象的内存地址信息，因此要通过 isa &amp; ISA_MASK才能取出这里33位的值，得到对象的真正地址；</li><li><strong>magic</strong> 用于在调试的时候分辨对象是否完成了初始化；</li><li><strong>weekly_referenced</strong> 是否被弱饮用指针指向过，如果没有，释放时会更快；</li><li><strong>extra_rc</strong> 里面存储的值是 引用计数值-1；</li><li><strong>deallocating</strong> 对象是否正在被释放；</li><li><strong>has_sidtable_rc</strong> 引用计数器是否过大无法存储在isa中，若果是，这里就为1，引用计数就会被存储在一个叫SideTable的类的属性中。</li></ul><p><strong>补充：</strong><br><br>为什么上面的<strong>has_assoc</strong>、<strong>has_cxx_dtor</strong>、<strong>weekly_referenced</strong>会影响对象释放的速度呢？objc源码里面有答案：对象在释放的时候，会调用void *objc_destructInstance(id obj)方法：<br></p><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* objc_destructInstance</span></span><br><span class="line"><span class="comment">* Destroys an instance without freeing memory. </span></span><br><span class="line"><span class="comment">* Calls C++ destructors.</span></span><br><span class="line"><span class="comment">* Calls ARC ivar cleanup.</span></span><br><span class="line"><span class="comment">* Removes associative references.</span></span><br><span class="line"><span class="comment">* Returns `obj`. Does nothing if `obj` is nil.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="keyword">void</span> *objc_destructInstance(<span class="keyword">id</span> obj) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj) &#123;</span><br><span class="line">        <span class="comment">// Read all of the flags at once for performance.</span></span><br><span class="line">        <span class="keyword">bool</span> cxx = obj-&gt;hasCxxDtor();</span><br><span class="line">        <span class="keyword">bool</span> assoc = obj-&gt;hasAssociatedObjects();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This order is important.</span></span><br><span class="line">        <span class="keyword">if</span> (cxx) object_cxxDestruct(obj);</span><br><span class="line">        <span class="keyword">if</span> (assoc) _object_remove_assocations(obj);</span><br><span class="line">        obj-&gt;clearDeallocating();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>从源码的注释以及实现逻辑，很容易看出，程序会</p><ol><li>根据obj-&gt;hasCxxDtor()来决定是否调用object_cxxDestruct(obj)进行C++析构，</li><li>根据obj-&gt;hasAssociatedObjects()来决定是否调用_object_remove_assocations(obj)进行关联对象引用的移除。</li></ol><p>在obj-&gt;clearDeallocating();里面</p><p>isa.weakly_referenced和isa.has_sidetable_rc会决定是否进行weak_clear_no_lock(&amp;table.weak_table, (id)this);和table.refcnts.erase(this);操作。<br></p><p>因此isa中上述的这几个值会影响到对象释放的速度。<br></p><blockquote><p>那么，实例对象，类对象和元类对象之间有什么联系吗？</p></blockquote><img src="/runtime-1-oc%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9C%AC%E8%B4%A8/isa.png" class=""><p>isa指针：<br></p><ul><li>实例对象的isa指向类对象；</li><li>类对象的isa指向元类对象；</li><li>元类对象的isa指向基类的元类对象；</li><li>基类元类对象的isa指针指向它自己；</li></ul><p>superclass指针：<br></p><ul><li>类对象的superclass指向其父类类对象；</li><li>如果没有父类，superclass指针为nil；</li><li>元类对象的superclass指向其父类元类对象；</li><li>基类的元类对象的superclass指向基类的类对象；</li></ul>        <h3 id="四、对象的内存大小"   >          <a href="#四、对象的内存大小" class="heading-link"><i class="fas fa-link"></i></a>四、对象的内存大小</h3>      <figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;malloc/malloc.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="built_in">NSObject</span> *obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line">        <span class="comment">// 获得NSObject类的实例对象的成员变量所占用的大小：8</span></span><br><span class="line">        size_t size1 = class_getInstanceSize([<span class="built_in">NSObject</span> <span class="keyword">class</span>]);</span><br><span class="line">        <span class="comment">// 获取一个指针所指向内存空间的大小：16</span></span><br><span class="line">        size_t size2 =  malloc_size((__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)(obj));</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%zu, %zu&quot;</span>, size1, size2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印：8，16</span></span><br></pre></td></tr></table></div></figure><p><strong>总结：</strong><br></p><blockquote><p>class_getInstanceSize&amp;malloc_size的区别?</p></blockquote><ul><li>class_getInstanceSize:获取一个objc类的实例的实际大小，这个大小可以理解为创建这个实例对象至少需要的空间（系统实际为这个对象分配的空间可能会比这个大，这是出于系统内存对齐的原因）。</li><li>malloc_size:得到一个指针所指向的内存空间的大小。我们的OC对象就是一个指针，利用这个函数，我们可以得到该对象所占用的内存大小，也就是系统为这个对象（指针）所指向对象所实际分配的内存大小。<br>sizeof()：获取一个类型或者变量所占用的存储空间，这是一个运算符。</li></ul><p>所以，[NSObject alloc]之后，系统为其分配了16个字节的内存，最终obj对象（也就是struct NSObject_IMPL结构体），实际使用了其中的8个字节内存，（也就是其内部的那个isa指针所用的8个字节，这里我们是在64位系统为前提下来说的）</p>        <h3 id="面试题"   >          <a href="#面试题" class="heading-link"><i class="fas fa-link"></i></a>面试题</h3>      <hr><p>1、OC对象的本质是什么？<br><br>答：<br><br>在开发中常见的对象有三种：</p><ul><li>实例对象（instance）</li><li>类对象（class）</li><li>元类对象（meta-class）<br>不管是哪种类型的对象，其本质都是objc_object结构体，内部都有一个isa指针。</li></ul><hr><p>2、对象的isa指针指向哪里？<br><br>答：<br></p><ul><li>instance对象的isa指针指向class对象</li><li>class对象的isa指针指向meta-class对象</li><li>meta-class对象的isa指针指向基类（也就是NSObject）的meta-class对象</li></ul><hr><p>3、一个NSObject对象占用多少内存？<br><br>答：<br><br>在64位系统中，[NSObject alloc]之后，系统为其分配了16个字节的内存，但是实际使用了其中的8个字节内存，也就是isa指针所用的8个字节。</p><hr><p>4、以下代码输出什么？<br></p><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">BOOL</span> re1 = [(<span class="keyword">id</span>)[<span class="built_in">NSObject</span> <span class="keyword">class</span>] isKindOfClass:[<span class="built_in">NSObject</span> <span class="keyword">class</span>]];</span><br><span class="line"><span class="built_in">BOOL</span> re2 = [(<span class="keyword">id</span>)[<span class="built_in">NSObject</span> <span class="keyword">class</span>] isMemberOfClass:[<span class="built_in">NSObject</span> <span class="keyword">class</span>]];</span><br><span class="line"><span class="built_in">BOOL</span> re3 = [(<span class="keyword">id</span>)[SFPerson <span class="keyword">class</span>] isKindOfClass:[SFPerson <span class="keyword">class</span>]];</span><br><span class="line"><span class="built_in">BOOL</span> re4 = [(<span class="keyword">id</span>)[SFPerson <span class="keyword">class</span>] isMemberOfClass:[SFPerson <span class="keyword">class</span>]];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%hhd%hhd%hhd%hhd&quot;</span>,re1,re2,re3,re4);</span><br><span class="line"></span><br><span class="line"><span class="built_in">BOOL</span> re5 = [(<span class="keyword">id</span>)[<span class="built_in">NSObject</span> alloc] isKindOfClass:[<span class="built_in">NSObject</span> <span class="keyword">class</span>]];</span><br><span class="line"><span class="built_in">BOOL</span> re6 = [(<span class="keyword">id</span>)[<span class="built_in">NSObject</span> alloc] isMemberOfClass:[<span class="built_in">NSObject</span> <span class="keyword">class</span>]];</span><br><span class="line"><span class="built_in">BOOL</span> re7 = [(<span class="keyword">id</span>)[SFPerson alloc] isKindOfClass:[SFPerson <span class="keyword">class</span>]];</span><br><span class="line"><span class="built_in">BOOL</span> re8 = [(<span class="keyword">id</span>)[SFPerson alloc] isMemberOfClass:[SFPerson <span class="keyword">class</span>]];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%hhd%hhd%hhd%hhd&quot;</span>,re5,re6,re7,re8);</span><br></pre></td></tr></table></div></figure><p>答：输出为：1000，1111<br><br>首先要知道isKindOfClass 与 isMemberOfClass 的区别：<br></p><ul><li>isKindOfClass来确定一个对象是否是一个类的成员，或者是派生自该类的成员;</li><li>isMemberOfClass只能确定一个对象是否是当前类的成员;</li></ul><p>再根据isa和superclass的关系图即可得出答案。<br></p><img src="/runtime-1-oc%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9C%AC%E8%B4%A8/isa.png" class=""><br><p>想了解更详细的内容请点击：<a href="https://jack110530.github.io/iskindofclass%E4%B8%8Eismemberofclass%E7%9A%84%E5%8C%BA%E5%88%AB/">isKindOfClass与isMemberOfClass的区别</a><br></p>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;/runtime-1-oc%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9C%AC%E8%B4%A8/%E9%87%8D%E6%8B%BEiOS.jpg&quot; class=&quot;&quot;&gt;

&lt;blockquote&gt;
&lt;p&gt;关键词：RunTime&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="重拾iOS" scheme="https://jack110530.github.io/categories/%E9%87%8D%E6%8B%BEiOS/"/>
    
    
    <category term="runtime" scheme="https://jack110530.github.io/tags/runtime/"/>
    
  </entry>
  
  <entry>
    <title>Crash防护(4)-NSTimer</title>
    <link href="https://jack110530.github.io/crash%E9%98%B2%E6%8A%A4-4-nstimer/"/>
    <id>https://jack110530.github.io/crash%E9%98%B2%E6%8A%A4-4-nstimer/</id>
    <published>2020-10-27T05:44:15.000Z</published>
    <updated>2020-10-28T03:07:35.595Z</updated>
    
    <content type="html"><![CDATA[<img src="/crash%E9%98%B2%E6%8A%A4-4-nstimer/%E9%87%8D%E6%8B%BEiOS.jpg" class=""><br><blockquote><p>关键词：NSTimer、Runloop、循环引用、NSProxy</p></blockquote><a id="more"></a><p>Crash防护系列文章:<br></p><ul><li><a href="https://jack110530.github.io/crash%E9%98%B2%E6%8A%A4-1-unrecognized-selector/">Crash防护(1)-Unrecognized Selector</a></li><li><a href="https://jack110530.github.io/crash%E9%98%B2%E6%8A%A4-2-kvo/">Crash防护(2)-KVO</a></li><li><a href="https://jack110530.github.io/crash%E9%98%B2%E6%8A%A4-3-kvc/">Crash防护(3)-KVC</a></li><li><a href="https://jack110530.github.io/crash%E9%98%B2%E6%8A%A4-4-nstimer/">Crash防护(4)-NSTimer</a></li></ul>        <h3 id="前言"   >          <a href="#前言" class="heading-link"><i class="fas fa-link"></i></a>前言</h3>      <ol><li>开发中又遇到NSTimer相关的问题吗，是怎么解决的？</li><li>NSTimer循环引用方案</li></ol>        <h3 id="NSTimer-Crash-的产生原因"   >          <a href="#NSTimer-Crash-的产生原因" class="heading-link"><i class="fas fa-link"></i></a>NSTimer Crash 的产生原因</h3>      <p>在程序开发过程中，大家会经常使用定时任务，但使用NSTimer的 scheduledTimerWithTimeInterval:target:selector:userInfo:repeats:接口做重复性的定时任务时存在一个问题：NSTimer会强引用target实例，所以需要在合适的时机invalidate定时器，否则就会由于定时器timer强引用target的关系导致target不能被释放，造成内存泄露，甚至在定时任务触发时导致crash。crash的展现形式和具体的target执行的selector有关。<br></p><p>与此同时，如果NSTimer是无限重复的执行一个任务的话，也有可能导致target的selector一直被重复调用且处于无效状态，对app的CPU，内存等性能方面均是没有必要的浪费。<br></p><p><strong>代码示例</strong>：<br></p><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&quot;TimerCrashTestVC.h&quot;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">TimerCrashTestVC</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSTimer</span> *timer;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">TimerCrashTestVC</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="keyword">self</span>.timer = [<span class="built_in">NSTimer</span> timerWithTimeInterval:<span class="number">1</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(timerEvent) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line">    [[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:<span class="keyword">self</span>.timer forMode:<span class="built_in">NSRunLoopCommonModes</span>];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)timerEvent&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;定时器事件&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></div></figure><p>在ViewController中，点击按钮push到TimerCrashTestVC。<br></p><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TimerCrashTestVC *vc = [[TimerCrashTestVC alloc]init];</span><br><span class="line">[<span class="keyword">self</span>.navigationController pushViewController:vc animated:<span class="literal">YES</span>];</span><br></pre></td></tr></table></div></figure><p>控制台打印定时器事件:<br></p><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2020</span><span class="number">-10</span><span class="number">-21</span> <span class="number">10</span>:<span class="number">16</span>:<span class="number">37.877364</span>+<span class="number">0800</span> TestDemo[<span class="number">39003</span>:<span class="number">883014</span>] 定时器事件</span><br><span class="line"><span class="number">2020</span><span class="number">-10</span><span class="number">-21</span> <span class="number">10</span>:<span class="number">16</span>:<span class="number">38.876337</span>+<span class="number">0800</span> TestDemo[<span class="number">39003</span>:<span class="number">883014</span>] 定时器事件</span><br><span class="line"><span class="number">2020</span><span class="number">-10</span><span class="number">-21</span> <span class="number">10</span>:<span class="number">16</span>:<span class="number">39.877408</span>+<span class="number">0800</span> TestDemo[<span class="number">39003</span>:<span class="number">883014</span>] 定时器事件</span><br><span class="line">...</span><br></pre></td></tr></table></div></figure><p>此时，若pop，按我们想象的来说，TimerCrashTestVC应该dealloc 并且NSTimer也应该停止。<br><br>但是，当我们pop时，事实却与我们想象的不一样，打印如下：<br></p><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2020</span><span class="number">-10</span><span class="number">-21</span> <span class="number">10</span>:<span class="number">16</span>:<span class="number">40.877086</span>+<span class="number">0800</span> TestDemo[<span class="number">39003</span>:<span class="number">883014</span>] 定时器事件</span><br><span class="line"><span class="number">2020</span><span class="number">-10</span><span class="number">-21</span> <span class="number">10</span>:<span class="number">16</span>:<span class="number">41.877532</span>+<span class="number">0800</span> TestDemo[<span class="number">39003</span>:<span class="number">883014</span>] 定时器事件</span><br><span class="line"><span class="number">2020</span><span class="number">-10</span><span class="number">-21</span> <span class="number">10</span>:<span class="number">16</span>:<span class="number">42.877496</span>+<span class="number">0800</span> TestDemo[<span class="number">39003</span>:<span class="number">883014</span>] 定时器事件</span><br><span class="line">...</span><br></pre></td></tr></table></div></figure><p>TimerCrashTestVC并没有dealloc，并且NSTimer也没有停止！！！<br></p><p>有人说，需要在dealloc中将NSTImer invalidate。比如：<br></p><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">    [<span class="keyword">self</span>.timer invalidate];</span><br><span class="line">    <span class="keyword">self</span>.timer = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>不幸的是，dealloc方法将永远不会被调用。因为timer的引用，TimerCrashTestVC对象的引用计数永远不会降到0，dealloc方法也就不会被调用，timer也一直在执行事件。<br></p><p>其实，在实际开发过程中很容易出现这种错误。<br></p><p>所以，很有必要设计出一种方案，可以有效的防护NSTimer的滥用问题。</p>        <h3 id="NSTimer-Crash-防护方案"   >          <a href="#NSTimer-Crash-防护方案" class="heading-link"><i class="fas fa-link"></i></a>NSTimer Crash 防护方案</h3>      <p>苹果官方文档中：<br></p><blockquote><p>This method is the only way to remove a timer from an NSRunLoop object. The NSRunLoop object removes its strong reference to the timer, either just before the invalidate method returns or at some later point.<br>If it was configured with target and user info objects, the receiver removes its strong references to those objects as well.<br>You must send this message from the thread on which the timer was installed. If you send this message from another thread, the input source associated with the timer may not be removed from its run loop, which could prevent the thread from exiting properly.</p></blockquote><p>可以看到，当一个timer被schedule的时候，timer会持有target对象，NSRunLoop对象会持有timer。当invalidate被调用时，NSRunLoop对象会释放对timer的持有，timer会释放对target的持有。除此之外，我们没有途径可以释放timer对target的持有。所以解决内存泄露就必须撤销timer，若不撤销，target对象将永远无法释放。<br></p><p>上面的分析可见，NSTimer所产生的问题的主要原因是因为其没有再一个合适的时机invalidate，同时还有NSTimer对target的强引用导致的内存泄漏问题。<br></p><p>那么解决NSTimer的问题的关键点在于以下两点：<br></p><ol><li>STimer对其target是否可以不强引用；</li><li>是否找到一个合适的时机，在确定NSTimer已经失效的情况下，让NSTimer自动invalidate；</li></ol><p>针对第一点，可以使用NSProxy消息转发实现。<br><br>在NSTimer和target之间加入一层proxy，proxy主要做为一个桥接层，负责NSTimer和target之间的通信。<br><br>让NSProxy作为NSTimer的target，NSTimer强引用着proxy，同时proxy弱引用真正的target，并把所有的消息转发到真正的target上。这样就解决了循环引用的问题了。<br></p><p>针对第二点，也可以使用中间层，在执行定时器的方法selector前判断NSTimer是否已经失效。<br></p><p>结合第一点和第二点总结，有如下代码：<br><br>首先，子类化一个NSProxy用于做消息转发。<br></p><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SFProxy</span> : <span class="title">NSProxy</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="built_in">NSObject</span> *target;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithTarget:(<span class="keyword">id</span>)target;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)proxyWithTarget:(<span class="keyword">id</span>)target;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// .m</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SFProxy</span></span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithTarget:(<span class="keyword">id</span>)target &#123;</span><br><span class="line">    _target = target;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)proxyWithTarget:(<span class="keyword">id</span>)target &#123;</span><br><span class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span> alloc] initWithTarget:target];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息转发</span></span><br><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.target &amp;&amp; [<span class="keyword">self</span>.target respondsToSelector:aSelector]) &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="keyword">self</span>.target methodSignatureForSelector:aSelector];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> methodSignatureForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation&#123;</span><br><span class="line">    SEL aSelector = [anInvocation selector];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.target &amp;&amp; [<span class="keyword">self</span>.target respondsToSelector:aSelector]) &#123;</span><br><span class="line">        [anInvocation invokeWithTarget:<span class="keyword">self</span>.target];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [<span class="keyword">super</span> forwardInvocation:anInvocation];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></div></figure><p>然后，再子类化SFProxy，用于接收aTarget的aSelector，在执行前判断timer是否应该invalidate。<br></p><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SFTimerProxy</span> : <span class="title">SFProxy</span></span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithTarget:(<span class="keyword">id</span>)target aSelector:(SEL)aSelector;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)proxyWithTarget:(<span class="keyword">id</span>)target aSelector:(SEL)aSelector;</span><br><span class="line">- (<span class="keyword">void</span>)fireProxyTimer:(<span class="built_in">NSTimer</span> *)timer;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// .m</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SFTimerProxy</span></span></span><br><span class="line">&#123;</span><br><span class="line">    SEL _aSelector;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithTarget:(<span class="keyword">id</span>)target aSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> initWithTarget:target];</span><br><span class="line">    _aSelector = aSelector;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)proxyWithTarget:(<span class="keyword">id</span>)target aSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span> alloc] initWithTarget:target aSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)fireProxyTimer:(<span class="built_in">NSTimer</span> *)timer &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.target) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span>.target respondsToSelector:_aSelector]) &#123;</span><br><span class="line">            [<span class="keyword">self</span>.target performSelector:_aSelector withObject:timer];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        [timer invalidate];</span><br><span class="line">        timer = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span><span class="class"><span class="keyword">@implementation</span> <span class="title">SFTimerProxy</span></span></span><br><span class="line">&#123;</span><br><span class="line">    SEL _aSelector;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithTarget:(<span class="keyword">id</span>)target aSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> initWithTarget:target];</span><br><span class="line">    _aSelector = aSelector;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)proxyWithTarget:(<span class="keyword">id</span>)target aSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span> alloc] initWithTarget:target aSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)fireProxyTimer:(<span class="built_in">NSTimer</span> *)timer &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.target) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span>.target respondsToSelector:_aSelector]) &#123;</span><br><span class="line">            [<span class="keyword">self</span>.target performSelector:_aSelector withObject:timer];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        [timer invalidate];</span><br><span class="line">        timer = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></div></figure><p>第三步，新建一个分类NSTimer+TimerCrash。<br></p><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&quot;NSTimer+TimerCrash.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;NSObject+MethodSwizzling.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;SFCrachInspector.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;SFTimerProxy.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSTimer</span> (<span class="title">TimerCrash</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 交换timerWithTimeInterval:target:selector:userInfo:repeats:方法</span></span><br><span class="line">        [<span class="built_in">NSObject</span> sf_swizzlingClassMethod:<span class="keyword">@selector</span>(timerWithTimeInterval:target:selector:userInfo:repeats:) swizzledMethod:<span class="keyword">@selector</span>(sf_timerWithTimeInterval:target:selector:userInfo:repeats:) withClass:[<span class="built_in">NSTimer</span> <span class="keyword">class</span>]];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 交换scheduledTimerWithTimeInterval:target:selector:userInfo:repeats:方法</span></span><br><span class="line">        [<span class="built_in">NSObject</span> sf_swizzlingClassMethod:<span class="keyword">@selector</span>(scheduledTimerWithTimeInterval:target:selector:userInfo:repeats:) swizzledMethod:<span class="keyword">@selector</span>(sf_scheduledTimerWithTimeInterval:target:selector:userInfo:repeats:) withClass:[<span class="built_in">NSTimer</span> <span class="keyword">class</span>]];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSTimer</span> *)sf_timerWithTimeInterval:(<span class="built_in">NSTimeInterval</span>)ti target:(<span class="keyword">id</span>)aTarget selector:(SEL)aSelector userInfo:(<span class="keyword">nullable</span> <span class="keyword">id</span>)userInfo repeats:(<span class="built_in">BOOL</span>)yesOrNo &#123;</span><br><span class="line">    SFTimerProxy *proxy = [SFTimerProxy proxyWithTarget:aTarget aSelector:aSelector];</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> sf_timerWithTimeInterval:ti target:proxy selector:<span class="keyword">@selector</span>(fireProxyTimer:) userInfo:userInfo repeats:yesOrNo];</span><br><span class="line">&#125;</span><br><span class="line">+ (<span class="built_in">NSTimer</span> *)sf_scheduledTimerWithTimeInterval:(<span class="built_in">NSTimeInterval</span>)ti target:(<span class="keyword">id</span>)aTarget selector:(SEL)aSelector userInfo:(<span class="keyword">nullable</span> <span class="keyword">id</span>)userInfo repeats:(<span class="built_in">BOOL</span>)yesOrNo &#123;</span><br><span class="line">    SFTimerProxy *proxy = [SFTimerProxy proxyWithTarget:aTarget aSelector:aSelector];</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> sf_scheduledTimerWithTimeInterval:ti target:proxy selector:<span class="keyword">@selector</span>(fireProxyTimer:) userInfo:userInfo repeats:yesOrNo];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></div></figure><p>至此，NSTimer的循环引用问题和NSTimer的invalidate时机问题就解决了。<br></p><p>重新运行后，push后pop，打印如下：<br></p><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2020</span><span class="number">-10</span><span class="number">-21</span> <span class="number">10</span>:<span class="number">41</span>:<span class="number">18.160033</span>+<span class="number">0800</span> TestDemo[<span class="number">39207</span>:<span class="number">898748</span>] 定时器事件</span><br><span class="line"><span class="number">2020</span><span class="number">-10</span><span class="number">-21</span> <span class="number">10</span>:<span class="number">41</span>:<span class="number">19.160044</span>+<span class="number">0800</span> TestDemo[<span class="number">39207</span>:<span class="number">898748</span>] 定时器事件</span><br><span class="line"><span class="number">2020</span><span class="number">-10</span><span class="number">-21</span> <span class="number">10</span>:<span class="number">41</span>:<span class="number">20.160049</span>+<span class="number">0800</span> TestDemo[<span class="number">39207</span>:<span class="number">898748</span>] 定时器事件</span><br><span class="line"><span class="number">2020</span><span class="number">-10</span><span class="number">-21</span> <span class="number">10</span>:<span class="number">41</span>:<span class="number">21.100760</span>+<span class="number">0800</span> TestDemo[<span class="number">39207</span>:<span class="number">898748</span>] -[TimerCrashTestVC dealloc]</span><br></pre></td></tr></table></div></figure><p>此时，我们不需要在dealloc中写NSTImer invalidate方法，TimerCrashTestVC也成功dealloc，NSTimer也invalidate了。<br></p><hr><p>[代码链接]<br/><br>GitHub：<span class="exturl"><a class="exturl__link"   href="https://github.com/jack110530/SFCrash" >https://github.com/jack110530/SFCrash</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><hr><p>[相关参考]<br/></p><ol><li><span class="exturl"><a class="exturl__link"   href="https://www.jianshu.com/p/f63395599633" >网易iOS App运行时Crash自动防护实践</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li></ol>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;/crash%E9%98%B2%E6%8A%A4-4-nstimer/%E9%87%8D%E6%8B%BEiOS.jpg&quot; class=&quot;&quot;&gt;
&lt;br&gt;

&lt;blockquote&gt;
&lt;p&gt;关键词：NSTimer、Runloop、循环引用、NSProxy&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Crash防护(3)-KVC</title>
    <link href="https://jack110530.github.io/crash%E9%98%B2%E6%8A%A4-3-kvc/"/>
    <id>https://jack110530.github.io/crash%E9%98%B2%E6%8A%A4-3-kvc/</id>
    <published>2020-10-27T04:52:18.000Z</published>
    <updated>2020-10-28T03:07:35.596Z</updated>
    
    <content type="html"><![CDATA[<img src="/crash%E9%98%B2%E6%8A%A4-3-kvc/%E9%87%8D%E6%8B%BEiOS.jpg" class=""><br><blockquote><p>关键词：KVC、Runtime</p></blockquote><a id="more"></a><p>Crash防护系列文章:<br></p><ul><li><a href="https://jack110530.github.io/crash%E9%98%B2%E6%8A%A4-1-unrecognized-selector/">Crash防护(1)-Unrecognized Selector</a></li><li><a href="https://jack110530.github.io/crash%E9%98%B2%E6%8A%A4-2-kvo/">Crash防护(2)-KVO</a></li><li><a href="https://jack110530.github.io/crash%E9%98%B2%E6%8A%A4-3-kvc/">Crash防护(3)-KVC</a></li><li><a href="https://jack110530.github.io/crash%E9%98%B2%E6%8A%A4-4-nstimer/">Crash防护(4)-NSTimer</a></li></ul>        <h3 id="前言"   >          <a href="#前言" class="heading-link"><i class="fas fa-link"></i></a>前言</h3>      <ol><li>日常开发中有没有遇到过因为KVC而奔溃的问题？</li></ol>        <h3 id="KVC-Crash-的产生原因"   >          <a href="#KVC-Crash-的产生原因" class="heading-link"><i class="fas fa-link"></i></a>KVC Crash 的产生原因</h3>      <p>KVC 日常使用造成崩溃的原因通常有以下几个：</p><ol><li>key 不是对象的属性，造成崩溃。</li><li>keyPath 不正确，造成崩溃。</li><li>key 为 nil，造成崩溃。</li><li>value 为 nil，为非对象设值，造成崩溃。</li></ol>        <h3 id="KVC-Crash-防护方案"   >          <a href="#KVC-Crash-防护方案" class="heading-link"><i class="fas fa-link"></i></a>KVC Crash 防护方案</h3>              <h4 id="1、思路"   >          <a href="#1、思路" class="heading-link"><i class="fas fa-link"></i></a>1、思路</h4>      <p>理解了KVC的设值取值原理的基础上，我们知道：<br></p><ul><li>setValue:forKey: 执行失败会调用 setValue: forUndefinedKey: 方法，并引发崩溃。</li><li>valueForKey: 执行失败会调用 valueForUndefinedKey: 方法，并引发崩溃。</li></ul><p>所以，为了进行 KVC Crash 防护，我们就需要重写 setValue: forUndefinedKey: 方法和 valueForUndefinedKey: 方法。重写这两个方法之后，就可以防护 <strong>1. key 不是对象的属性</strong> 和 <strong>2. keyPath 不正确 这两种崩溃情况了</strong>。<br></p><p>那么 <strong>3. key 为 nil，造成崩溃</strong> 的情况，该怎么防护呢？<br><br>我们可以利用 Method Swizzling 方法，在 NSObject 的分类中将 setValue:forKey: 和 sf_setValue:forKey: 进行方法交换。然后在自定义的方法中，添加对 key 为 nil 这种类型的判断。<br></p><p>还有最后一种 <strong>4. value 为 nil，为非对象设值，造成崩溃</strong> 的情况。<br><br>在 NSKeyValueCoding.h 文件中，有一个 setNilValueForKey: 方法。上边的官方注释给了我们答案。<br><br>在调用 setValue:forKey: 方法时，系统如果查找到名为 set<Key>: 方法的时候，会去检测 value 的参数类型，如果参数类型为 NSNmber 的标量类型或者是 NSValue 的结构类型，但是 value 为 nil 时，会自动调用 setNilValueForKey: 方法。这个方法的默认实现会引发崩溃。<br><br>所以为了防止这种情况导致的崩溃，我们可以通过重写 setNilValueForKey: 来解决。</p>        <h4 id="2、代码"   >          <a href="#2、代码" class="heading-link"><i class="fas fa-link"></i></a>2、代码</h4>      <p>新建分类NSObject+KvoCrash<br></p><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">KvcCrash</span>)</span></span><br><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        <span class="comment">// 交换setValue:forKey:方法(实例方法和对象方法)</span></span><br><span class="line">        [<span class="built_in">NSObject</span> sf_swizzlingInstanceMethod:<span class="keyword">@selector</span>(setValue:forKey:) swizzledMethod:<span class="keyword">@selector</span>(sf_setValue:forKey:) withClass:[<span class="built_in">NSObject</span> <span class="keyword">class</span>]];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)sf_setValue:(<span class="keyword">id</span>)value forKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="built_in">BOOL</span> isOpen = [SFCrachInspector checkIsOpenWithOption:SFCrashInspectorOptionKVC];</span><br><span class="line">    <span class="keyword">if</span> (isOpen) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!key) &#123;</span><br><span class="line">            <span class="built_in">NSString</span> *msg = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;【KVC】[&lt;%@ %p&gt; setValue:forKey:]: attempt to set a value for a nil key. &quot;</span>,<span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> <span class="keyword">class</span>]),<span class="keyword">self</span>];</span><br><span class="line">            [SFCrachInspector log:msg];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span> sf_setValue:value forKey:key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setNilValueForKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="built_in">BOOL</span> isOpen = [SFCrachInspector  checkIsOpenWithOption:SFCrashInspectorOptionKVC];</span><br><span class="line">    <span class="keyword">if</span> (isOpen) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *msg = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;【KVC】[&lt;%@ %p&gt; setNilValueForKey]: could not set nil as the value for the key %@.&quot;</span>,<span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> <span class="keyword">class</span>]),<span class="keyword">self</span>,key];</span><br><span class="line">        [SFCrachInspector log:msg];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setValue:(<span class="keyword">id</span>)value forUndefinedKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="built_in">BOOL</span> isOpen = [SFCrachInspector checkIsOpenWithOption:SFCrashInspectorOptionKVC];</span><br><span class="line">    <span class="keyword">if</span> (isOpen) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *msg = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;【KVC】[&lt;%@ %p&gt; setValue:forUndefinedKey:]: this class is not key value coding-compliant for the key: %@,value:%@&#x27;.&quot;</span>,<span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> <span class="keyword">class</span>]),<span class="keyword">self</span>,key,value];</span><br><span class="line">        [SFCrachInspector log:msg];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>)valueForUndefinedKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="built_in">BOOL</span> isOpen = [SFCrachInspector checkIsOpenWithOption:SFCrashInspectorOptionKVC];</span><br><span class="line">    <span class="keyword">if</span> (isOpen) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *msg = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;【KVC】[&lt;%@ %p&gt; valueForUndefinedKey:]: this class is not key value coding-compliant for the key: %@.&quot;</span>,<span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> <span class="keyword">class</span>]),<span class="keyword">self</span>,key];</span><br><span class="line">        [SFCrachInspector log:msg];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></div></figure><hr><p>[代码链接]<br/><br>GitHub：<span class="exturl"><a class="exturl__link"   href="https://github.com/jack110530/SFCrash" >https://github.com/jack110530/SFCrash</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><hr><p>[相关参考]<br/></p><ol><li><span class="exturl"><a class="exturl__link"   href="https://juejin.im/post/6844903934662803464" >iOS 开发：『Crash 防护系统』（三）KVC 防护</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> </li><li><span class="exturl"><a class="exturl__link"   href="https://www.jianshu.com/p/f63395599633" >网易iOS App运行时Crash自动防护实践</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li></ol>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;/crash%E9%98%B2%E6%8A%A4-3-kvc/%E9%87%8D%E6%8B%BEiOS.jpg&quot; class=&quot;&quot;&gt;
&lt;br&gt;

&lt;blockquote&gt;
&lt;p&gt;关键词：KVC、Runtime&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Crash防护(2)-KVO</title>
    <link href="https://jack110530.github.io/crash%E9%98%B2%E6%8A%A4-2-kvo/"/>
    <id>https://jack110530.github.io/crash%E9%98%B2%E6%8A%A4-2-kvo/</id>
    <published>2020-10-27T04:41:33.000Z</published>
    <updated>2020-10-28T03:07:35.595Z</updated>
    
    <content type="html"><![CDATA[<img src="/crash%E9%98%B2%E6%8A%A4-2-kvo/%E9%87%8D%E6%8B%BEiOS.jpg" class=""><br><blockquote><p>关键词：KVO、HashMap、Swizzling</p></blockquote><a id="more"></a><p>Crash防护系列文章:<br></p><ul><li><a href="https://jack110530.github.io/crash%E9%98%B2%E6%8A%A4-1-unrecognized-selector/">Crash防护(1)-Unrecognized Selector</a></li><li><a href="https://jack110530.github.io/crash%E9%98%B2%E6%8A%A4-2-kvo/">Crash防护(2)-KVO</a></li><li><a href="https://jack110530.github.io/crash%E9%98%B2%E6%8A%A4-3-kvc/">Crash防护(3)-KVC</a></li><li><a href="https://jack110530.github.io/crash%E9%98%B2%E6%8A%A4-4-nstimer/">Crash防护(4)-NSTimer</a></li></ul>        <h3 id="前言"   >          <a href="#前言" class="heading-link"><i class="fas fa-link"></i></a>前言</h3>      <ol><li>开发中KVO用的多吗，有没有遇到过因为KVO引发的bug？</li><li>针对KVO crash防护，怎么做？</li></ol>        <h3 id="KVO造成崩溃的原因"   >          <a href="#KVO造成崩溃的原因" class="heading-link"><i class="fas fa-link"></i></a>KVO造成崩溃的原因</h3>      <ol><li>KVO 添加次数和移除次数不匹配：<ul><li>移除了未注册的观察者，导致崩溃。</li><li>重复移除多次，移除次数多于添加次数，导致崩溃。</li><li>重复添加多次，虽然不会崩溃，但是发生改变时，也同时会被观察多次。</li></ul></li><li>被观察者提前被释放，被观察者在 dealloc 时仍然注册着 KVO，导致崩溃。 例如：被观察者是局部变量的情况（iOS 10 及之前会崩溃）。</li><li>添加了观察者，但未实现 observeValueForKeyPath:ofObject:change:context: 方法，导致崩溃。</li><li>添加或者移除时 keypath == nil，导致崩溃。</li></ol>        <h3 id="KVO-Crash防护方案"   >          <a href="#KVO-Crash防护方案" class="heading-link"><i class="fas fa-link"></i></a>KVO Crash防护方案</h3>      <p>为了避免上面提到的使用 KVO 造成崩溃的问题，于是出现了很多关于 KVO 的第三方库，比如最出名的就是 FaceBook 开源的第三方库 <span class="exturl"><a class="exturl__link"   href="https://github.com/facebook/KVOController" >facebook / KVOController</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>。<br></p><p>FBKVOController 对 KVO 机制进行了额外的一层封装，框架不但可以自动帮我们移除观察者，还提供了 block 或者 selector 的方式供我们进行观察处理。不可否认的是，FBKVOController 为我们的开发提供了很大的便利性。但是相对而言，这种方式对项目代码的侵入性比较大，必须依靠编码规范来强制约束团队人员使用这种方式。<br></p><p>那么有没有一种对项目代码侵入性小，同时还能有效防护 KVO 崩溃的防护机制呢？<br>具体可以参考一下 iOS 开发：『Crash 防护系统』（二）KVO 防护 这篇文章。<br></p><p>但是，查阅YSC-Avoid-Crash和BayMaxProtector 源码后，发现还存在些问题，所以在“前人”的基础上添加了自己的改进代码：<br><br>本来是把源码中的一些问题写了下来，发现似乎有些不妥，就删掉了。想详细了解的朋友可以私信我。</p><hr><p>[代码链接]<br/><br>GitHub：<span class="exturl"><a class="exturl__link"   href="https://github.com/jack110530/SFCrash" >https://github.com/jack110530/SFCrash</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><hr><p>[相关参考]<br/></p><ol><li><span class="exturl"><a class="exturl__link"   href="https://juejin.im/post/6844903927469588488" >iOS 开发：『Crash 防护系统』（二）KVO 防护</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> </li><li><span class="exturl"><a class="exturl__link"   href="https://www.jianshu.com/p/f63395599633" >网易iOS App运行时Crash自动防护实践</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li></ol>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;/crash%E9%98%B2%E6%8A%A4-2-kvo/%E9%87%8D%E6%8B%BEiOS.jpg&quot; class=&quot;&quot;&gt;
&lt;br&gt;

&lt;blockquote&gt;
&lt;p&gt;关键词：KVO、HashMap、Swizzling&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="重拾iOS" scheme="https://jack110530.github.io/categories/%E9%87%8D%E6%8B%BEiOS/"/>
    
    
    <category term="crash" scheme="https://jack110530.github.io/tags/crash/"/>
    
  </entry>
  
  <entry>
    <title>Crash防护(1)-Unrecognized Selector</title>
    <link href="https://jack110530.github.io/crash%E9%98%B2%E6%8A%A4-1-unrecognized-selector/"/>
    <id>https://jack110530.github.io/crash%E9%98%B2%E6%8A%A4-1-unrecognized-selector/</id>
    <published>2020-10-27T03:33:52.000Z</published>
    <updated>2020-12-14T07:37:38.639Z</updated>
    
    <content type="html"><![CDATA[<img src="/crash%E9%98%B2%E6%8A%A4-1-unrecognized-selector/%E9%87%8D%E6%8B%BEiOS.jpg" class=""><br><blockquote><p>关键词：Unrecognized Selector、Runtime、Swizzling</p></blockquote><a id="more"></a><p>Crash防护系列文章:<br></p><ul><li><a href="https://jack110530.github.io/crash%E9%98%B2%E6%8A%A4-1-unrecognized-selector/">Crash防护(1)-Unrecognized Selector</a></li><li><a href="https://jack110530.github.io/crash%E9%98%B2%E6%8A%A4-2-kvo/">Crash防护(2)-KVO</a></li><li><a href="https://jack110530.github.io/crash%E9%98%B2%E6%8A%A4-3-kvc/">Crash防护(3)-KVC</a></li><li><a href="https://jack110530.github.io/crash%E9%98%B2%E6%8A%A4-4-nstimer/">Crash防护(4)-NSTimer</a></li></ul>        <h3 id="前言"   >          <a href="#前言" class="heading-link"><i class="fas fa-link"></i></a>前言</h3>      <p>APP 的崩溃问题，一直以来都是开发过程中重中之重的问题。日常开发阶段的崩溃，发现后还能够立即处理。但是一旦发布上架的版本出现问题，就需要紧急加班修复 BUG，再更新上架新版本了。在这个过程中， 说不定会因为崩溃而导致关键业务中断、用户存留率下降、品牌口碑变差、生命周期价值下降等，最终导致流失用户，影响到公司的发展。<br></p><p>当然，避免崩溃问题的最好办法就是不产生崩溃。在开发的过程中就要尽可能地保证程序的健壮性。但是，人又不是机器，不可能不犯错。不可能存在没有 BUG 的程序。但是如果能够利用一些语言机制和系统方法，设计一套防护系统，使之能够有效的降低 APP 的崩溃率，那么不仅 APP 的稳定性得到了保障，而且最重要的是可以减少不必要的加班。<br></p><p><strong>【代码示例】</strong><br><br>如果被调用的对象方法没有实现，那么程序在运行中调用该方法时，就会因为找不到对应的方法实现，从而导致 APP 崩溃。比如下面这样的代码：<br></p><p>首先，在Person类中，声明了一个testInstanceFunc对象方法和一个testClassFunc类方法，但是却没有给出实现代码（IMP）</p><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line">- (<span class="keyword">void</span>)testInstanceFunc;</span><br><span class="line">+ (<span class="keyword">void</span>)testClassFunc;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// .m</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></div></figure><p>然后，在ViewController中：</p><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试对象方法</span></span><br><span class="line">Person *p = [[Person alloc]init];</span><br><span class="line">[p testInstanceFunc];</span><br><span class="line"><span class="comment">// 测试类方法</span></span><br><span class="line">[Person testClassFunc];</span><br></pre></td></tr></table></div></figure><p>运行后，会发现崩溃了。分别报错：</p><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试对象方法</span></span><br><span class="line">TestDemo[<span class="number">11056</span>:<span class="number">518162</span>] -[Person testInstanceFunc]: unrecognized selector sent to instance <span class="number">0x600000c74340</span></span><br><span class="line"><span class="comment">// 测试类方法</span></span><br><span class="line">TestDemo[<span class="number">11082</span>:<span class="number">519535</span>] +[Person testClassFunc]: unrecognized selector sent to <span class="keyword">class</span> <span class="number">0x108897670</span></span><br></pre></td></tr></table></div></figure><p>那么，像这种 unrecognized selector 的奔溃问题怎么去避免呢？至少项目上线后，在正式环境中不发生崩溃吧。</p>        <h3 id="一、Runtime预备知识"   >          <a href="#一、Runtime预备知识" class="heading-link"><i class="fas fa-link"></i></a>一、Runtime预备知识</h3>      <p>首先，我们要知道方法调用的本质是什么。<br></p><p>在OC中，方法调用的本质就是消息发送objc_msgSend。给对象发送消息，先会经过方法查找，找到了则执行方法实现。若没有找到则会进入消息转发阶段。若消息转发阶段也没有方法实现，则发生崩溃。<br></p><p>其中，在消息转发中三大步骤：动态方法解析、备用接收者、完整的消息转发。通过这三大步骤，可以让我们在程序找不到调用方法崩溃之前，拦截方法调用。<br></p><ul><li><strong>动态方法解析</strong>：Objective-C 运行时会调用 +resolveInstanceMethod: 或者 +resolveClassMethod:，让你有机会提供一个函数实现。我们可以通过重写这两个方法，添加其他函数实现，并返回 YES， 那运行时系统就会重新启动一次消息发送的过程。若返回 NO 或者没有添加其他函数实现，则进入下一步。</li><li><strong>备用接收者</strong>：如果当前对象实现了 forwardingTargetForSelector:，Runtime 就会调用这个方法，允许我们将消息的接受者转发给其他对象。如果这一步方法返回 nil，则进入下一步。</li><li><strong>完整的消息转发</strong>：Runtime 系统利用 methodSignatureForSelector: 方法获取函数的参数和返回值类型。<br>如果 methodSignatureForSelector: 返回了一个 NSMethodSignature 对象（函数签名），Runtime 系统就会创建一个 NSInvocation 对象，并通过 forwardInvocation: 消息通知当前对象，给予此次消息发送最后一次寻找 IMP 的机会。<br>如果 methodSignatureForSelector: 返回 nil。则 Runtime 系统会发出 doesNotRecognizeSelector: 消息，程序也就崩溃了。</li></ul><img src="/crash%E9%98%B2%E6%8A%A4-1-unrecognized-selector/%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91.jpg" class="">        <h3 id="二、Crash防护方案"   >          <a href="#二、Crash防护方案" class="heading-link"><i class="fas fa-link"></i></a>二、Crash防护方案</h3>              <h4 id="1、思路"   >          <a href="#1、思路" class="heading-link"><i class="fas fa-link"></i></a>1、思路</h4>      <p>Objective-C 语言是一门动态语言，我们可以利用 Objective-C 语言的 Runtime 运行时机制，对需要 Hook 的类添加 Category（分类），在各个分类的 +(void)load; 中通过 Method Swizzling 拦截容易造成崩溃的系统方法，将系统原有方法与添加的防护方法的 selector（方法选择器） 与 IMP（函数实现指针）进行对调。然后在替换方法中添加防护操作，从而达到避免以及修复崩溃的目的。<br></p><p>这里我们选择第二步（备用接收者）来进行拦截。因为 -forwardingTargetForSelector 方法可以将消息转发给一个对象，开销较小，并且被重写的概率较低，适合重写。<br></p>        <h4 id="2、代码"   >          <a href="#2、代码" class="heading-link"><i class="fas fa-link"></i></a>2、代码</h4>              <h5 id="1，给NSObject新建个Category用于方法交换（NSObject-MethodSwizzling）"   >          <a href="#1，给NSObject新建个Category用于方法交换（NSObject-MethodSwizzling）" class="heading-link"><i class="fas fa-link"></i></a>1，给NSObject新建个Category用于方法交换（NSObject+MethodSwizzling）</h5>      <figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&quot;NSObject+MethodSwizzling.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">MethodSwizzling</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)sf_swizzlingClassMethod:(SEL)originalSel swizzledMethod:(SEL)swizzledMethod withClass:(Class)targetClass &#123;</span><br><span class="line">    swizzlingMethod(targetClass, <span class="literal">YES</span>, originalSel, swizzledMethod);</span><br><span class="line">&#125;</span><br><span class="line">+ (<span class="keyword">void</span>)sf_swizzlingInstanceMethod:(SEL)originalSel swizzledMethod:(SEL)swizzledMethod withClass:(Class)targetClass &#123;</span><br><span class="line">    swizzlingMethod(targetClass, <span class="literal">NO</span>, originalSel, swizzledMethod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 交换类方法</span></span><br><span class="line"><span class="comment">/// @param class 类/元类</span></span><br><span class="line"><span class="comment">/// @param originalSel 原方法</span></span><br><span class="line"><span class="comment">/// @param swizzledSel 交换方法</span></span><br><span class="line"><span class="keyword">void</span> swizzlingMethod(Class <span class="keyword">class</span>, <span class="built_in">BOOL</span> isMetaClass, SEL originalSel, SEL swizzledSel) &#123;</span><br><span class="line">    Method originalMethod;</span><br><span class="line">    Method swizzledMethod;</span><br><span class="line">    <span class="keyword">if</span> (isMetaClass) &#123;</span><br><span class="line">        originalMethod = class_getClassMethod(<span class="keyword">class</span>, originalSel);</span><br><span class="line">        swizzledMethod = class_getClassMethod(<span class="keyword">class</span>, swizzledSel);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        originalMethod = class_getInstanceMethod(<span class="keyword">class</span>, originalSel);</span><br><span class="line">        swizzledMethod = class_getInstanceMethod(<span class="keyword">class</span>, swizzledSel);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!originalMethod || !swizzledMethod) &#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="built_in">BOOL</span> didAddMethod = class_addMethod(<span class="keyword">class</span>,</span><br><span class="line">                                         originalSel,</span><br><span class="line">                                         method_getImplementation(swizzledMethod),</span><br><span class="line">                                         method_getTypeEncoding(swizzledMethod));</span><br><span class="line">    <span class="keyword">if</span> (didAddMethod) &#123;</span><br><span class="line">        class_replaceMethod(<span class="keyword">class</span>,</span><br><span class="line">                            swizzledSel,</span><br><span class="line">                            method_getImplementation(originalMethod),</span><br><span class="line">                            method_getTypeEncoding(originalMethod));</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></div></figure>        <h5 id="2、给NSObject新建个Category用于Crash防护（NSObject-UnrecognizedSelectorCrash）"   >          <a href="#2、给NSObject新建个Category用于Crash防护（NSObject-UnrecognizedSelectorCrash）" class="heading-link"><i class="fas fa-link"></i></a>2、给NSObject新建个Category用于Crash防护（NSObject+UnrecognizedSelectorCrash）</h5>      <figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&quot;NSObject+UnrecognizedSelectorCrash.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;NSObject+MethodSwizzling.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">UnrecognizedSelectorCrash</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG</span></span><br><span class="line">        </span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        <span class="comment">// 交换forwardingTargetForSelector:方法(实例方法和对象方法)</span></span><br><span class="line">        [<span class="built_in">NSObject</span> sf_swizzlingInstanceMethod:<span class="keyword">@selector</span>(forwardingTargetForSelector:) swizzledMethod:<span class="keyword">@selector</span>(sf_forwardingTargetForSelector:) withClass:[<span class="built_in">NSObject</span> <span class="keyword">class</span>]];</span><br><span class="line">        [<span class="built_in">NSObject</span> sf_swizzlingClassMethod:<span class="keyword">@selector</span>(forwardingTargetForSelector:) swizzledMethod:<span class="keyword">@selector</span>(sf_forwardingTargetForSelector:) withClass:[<span class="built_in">NSObject</span> <span class="keyword">class</span>]];</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)sf_forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="comment">// 1，判断当前类有没有重写forwardingTargetForSelector:方法</span></span><br><span class="line">    SEL forwarding_sel = <span class="keyword">@selector</span>(forwardingTargetForSelector:);</span><br><span class="line">    <span class="built_in">BOOL</span> override_forwarding = checkMethodOverride([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="literal">NO</span>, forwarding_sel);</span><br><span class="line">    <span class="keyword">if</span> (!override_forwarding) &#123;</span><br><span class="line">        <span class="comment">// 没有重写「备用接受者」</span></span><br><span class="line">        <span class="comment">// 2，判断当前类有没有重写methodSignatureForSelector:方法</span></span><br><span class="line">        SEL methodSignature_sel = <span class="keyword">@selector</span>(methodSignatureForSelector:);</span><br><span class="line">        <span class="built_in">BOOL</span> override_methodSignature = checkMethodOverride([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="literal">NO</span>, methodSignature_sel);</span><br><span class="line">        <span class="keyword">if</span> (!override_methodSignature) &#123;</span><br><span class="line">            <span class="comment">// 没有重写「方法签名」</span></span><br><span class="line">            <span class="comment">// 3，把消息转发到当前动态生成类的实例对象上</span></span><br><span class="line">            <span class="built_in">NSString</span> *className = <span class="string">@&quot;SFCrachInspector&quot;</span>;</span><br><span class="line">            Class cls = <span class="built_in">NSClassFromString</span>(className);</span><br><span class="line">            <span class="comment">// 如果类不存在 动态创建一个类</span></span><br><span class="line">            <span class="keyword">if</span> (!cls) &#123;</span><br><span class="line">                Class superClsss = [<span class="built_in">NSObject</span> <span class="keyword">class</span>];</span><br><span class="line">                cls = objc_allocateClassPair(superClsss, className.UTF8String, <span class="number">0</span>);</span><br><span class="line">                <span class="comment">// 注册类</span></span><br><span class="line">                objc_registerClassPair(cls);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果类没有对应的方法，则动态添加一个</span></span><br><span class="line">            <span class="keyword">if</span> (!class_getInstanceMethod(<span class="built_in">NSClassFromString</span>(className), aSelector)) &#123;</span><br><span class="line">                class_addMethod(cls, aSelector, (IMP)crash, <span class="string">&quot;@@:@&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 打印日志</span></span><br><span class="line">            printCrachMessage(<span class="keyword">self</span>, <span class="literal">NO</span>, aSelector);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> [[cls alloc] init];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> sf_forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line">+ (<span class="keyword">id</span>)sf_forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="comment">// 1，判断当前类有没有重写forwardingTargetForSelector:方法</span></span><br><span class="line">    SEL forwarding_sel = <span class="keyword">@selector</span>(forwardingTargetForSelector:);</span><br><span class="line">    <span class="built_in">BOOL</span> override_forwarding = checkMethodOverride([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="literal">YES</span>, forwarding_sel);</span><br><span class="line">    <span class="keyword">if</span> (!override_forwarding) &#123;</span><br><span class="line">        <span class="comment">// 没有重写「备用接受者」</span></span><br><span class="line">        <span class="comment">// 2，判断当前类有没有重写methodSignatureForSelector:方法</span></span><br><span class="line">        SEL methodSignature_sel = <span class="keyword">@selector</span>(methodSignatureForSelector:);</span><br><span class="line">        <span class="built_in">BOOL</span> override_methodSignature = checkMethodOverride([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="literal">YES</span>, methodSignature_sel);</span><br><span class="line">        <span class="keyword">if</span> (!override_methodSignature) &#123;</span><br><span class="line">            <span class="comment">// 没有重写「方法签名」</span></span><br><span class="line">            <span class="comment">// 3，把消息转发到当前动态生成类的实例对象上</span></span><br><span class="line">            <span class="built_in">NSString</span> *className = <span class="string">@&quot;SFCrachInspector&quot;</span>;</span><br><span class="line">            Class cls = <span class="built_in">NSClassFromString</span>(className);</span><br><span class="line">            <span class="comment">// 如果类不存在 动态创建一个类</span></span><br><span class="line">            <span class="keyword">if</span> (!cls) &#123;</span><br><span class="line">                Class superClsss = [<span class="built_in">NSObject</span> <span class="keyword">class</span>];</span><br><span class="line">                cls = objc_allocateClassPair(superClsss, className.UTF8String, <span class="number">0</span>);</span><br><span class="line">                <span class="comment">// 注册类</span></span><br><span class="line">                objc_registerClassPair(cls);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果类没有对应的方法，则动态添加一个</span></span><br><span class="line">            <span class="keyword">if</span> (!class_getInstanceMethod(<span class="built_in">NSClassFromString</span>(className), aSelector)) &#123;</span><br><span class="line">                class_addMethod(cls, aSelector, (IMP)crash, <span class="string">&quot;@@:@&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 打印日志</span></span><br><span class="line">            printCrachMessage(<span class="keyword">self</span>, <span class="literal">YES</span>, aSelector);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> [[cls alloc] init];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> sf_forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 判断方法是否重写过</span></span><br><span class="line"><span class="comment">/// @param class 类</span></span><br><span class="line"><span class="comment">/// @param isMetaClass 是否元类</span></span><br><span class="line"><span class="comment">/// @param aSelector 方法</span></span><br><span class="line"><span class="built_in">BOOL</span> checkMethodOverride(Class <span class="keyword">class</span>, <span class="built_in">BOOL</span> isMetaClass, SEL aSelector) &#123;</span><br><span class="line">    Method root_method;</span><br><span class="line">    Method current_method;</span><br><span class="line">    <span class="keyword">if</span> (isMetaClass) &#123;</span><br><span class="line">        root_method = class_getClassMethod([<span class="built_in">NSObject</span> <span class="keyword">class</span>], aSelector);</span><br><span class="line">        current_method = class_getClassMethod(<span class="keyword">class</span>, aSelector);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        root_method = class_getInstanceMethod([<span class="built_in">NSObject</span> <span class="keyword">class</span>], aSelector);</span><br><span class="line">        current_method = class_getInstanceMethod(<span class="keyword">class</span>, aSelector);</span><br><span class="line">    &#125;</span><br><span class="line">    IMP root_imp = method_getImplementation(root_method);</span><br><span class="line">    IMP current_imp = method_getImplementation(current_method);</span><br><span class="line">    <span class="keyword">return</span> root_imp != current_imp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态添加的方法实现</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> crash(<span class="keyword">id</span> slf, SEL selector) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 打印Crash日志</span></span><br><span class="line"><span class="comment">/// @param obj 对象（实例对象/类对象）</span></span><br><span class="line"><span class="comment">/// @param isMetaClass 是否元类</span></span><br><span class="line"><span class="comment">/// @param aSelector 方法</span></span><br><span class="line"><span class="keyword">void</span> printCrachMessage(<span class="keyword">id</span> obj, <span class="built_in">BOOL</span> isMetaClass, SEL aSelector) &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *errClassName = <span class="built_in">NSStringFromClass</span>([obj <span class="keyword">class</span>]);</span><br><span class="line">    <span class="built_in">NSString</span> *errSel = <span class="built_in">NSStringFromSelector</span>(aSelector);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;\n-------------------------SFCrash-------------------------\n Crash Message:\n %@[%@ %@]: unrecognized selector sent to %@ %p  \n---------------------------END---------------------------\n ***&quot;</span>,isMetaClass?<span class="string">@&quot;+&quot;</span>:<span class="string">@&quot;-&quot;</span>, errClassName, errSel, isMetaClass?<span class="string">@&quot;class&quot;</span>:<span class="string">@&quot;instance&quot;</span>, obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></div></figure><hr><p>[代码链接]<br/><br>GitHub：<span class="exturl"><a class="exturl__link"   href="https://github.com/jack110530/SFCrash" >https://github.com/jack110530/SFCrash</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><hr><p>[相关参考]<br/></p><ol><li><span class="exturl"><a class="exturl__link"   href="https://juejin.im/post/6844903922667094023" >iOS 开发：『Crash 防护系统』（一）Unrecognized Selector</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> </li><li><span class="exturl"><a class="exturl__link"   href="https://www.jianshu.com/p/f63395599633" >网易iOS App运行时Crash自动防护实践</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li></ol>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;/crash%E9%98%B2%E6%8A%A4-1-unrecognized-selector/%E9%87%8D%E6%8B%BEiOS.jpg&quot; class=&quot;&quot;&gt;
&lt;br&gt;

&lt;blockquote&gt;
&lt;p&gt;关键词：Unrecognized Selector、Runtime、Swizzling&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="重拾iOS" scheme="https://jack110530.github.io/categories/%E9%87%8D%E6%8B%BEiOS/"/>
    
    
    <category term="crash" scheme="https://jack110530.github.io/tags/crash/"/>
    
  </entry>
  
  <entry>
    <title>NSTimer和界面滑动冲突</title>
    <link href="https://jack110530.github.io/nstimer%E5%92%8C%E7%95%8C%E9%9D%A2%E6%BB%91%E5%8A%A8%E5%86%B2%E7%AA%81/"/>
    <id>https://jack110530.github.io/nstimer%E5%92%8C%E7%95%8C%E9%9D%A2%E6%BB%91%E5%8A%A8%E5%86%B2%E7%AA%81/</id>
    <published>2020-10-27T01:46:20.000Z</published>
    <updated>2020-10-27T02:08:47.259Z</updated>
    
    <content type="html"><![CDATA[<img src="/nstimer%E5%92%8C%E7%95%8C%E9%9D%A2%E6%BB%91%E5%8A%A8%E5%86%B2%E7%AA%81/%E9%87%8D%E6%8B%BEiOS.jpg" class=""><br><blockquote><p>关键词：NSTimer、CADisplayLink、GCD、RunLoop、多线程</p></blockquote><a id="more"></a>        <h3 id="前言"   >          <a href="#前言" class="heading-link"><i class="fas fa-link"></i></a>前言</h3>      <ol><li>在滑动页面上的列表时，NSTimer会暂停，为什么？该如何解决？</li></ol>        <h3 id="一、原因"   >          <a href="#一、原因" class="heading-link"><i class="fas fa-link"></i></a>一、原因</h3>      <p>原因在于滑动时当前线程的runloop切换了mode用于列表滑动，导致timer暂停。<br></p><p>runloop中的mode主要用来指定事件在runloop中的优先级，有以下几种：</p><ul><li>Default（NSDefaultRunLoopMode）：默认，一般情况下使用；</li><li>Connection（NSConnectionReplyMode）：一般系统用来处理NSConnection相关事件，开发者一般用不到；</li><li>Modal（NSModalPanelRunLoopMode）：处理modal panels事件；</li><li>Event Tracking（NSEventTrackingRunLoopMode）：用于处理拖拽和用户交互的模式。</li><li>Common（NSRunloopCommonModes）：模式合集。默认包括Default，Modal，Event Tracking三大模式，可以处理几乎所有事件。</li></ul><p>回到题中的情境。滑动列表时，runloop的mode由原来的Default模式切换到了Event Tracking模式，timer原来好好的运行在Default模式中，被关闭后自然就停止工作了。</p><p><strong>注意：</strong><br><br>在NSTimer的初始化方法中，以scheduled开头的方法，timer默认已经添加到了当前RunLoop中（以default mode形式添加）</p>        <h3 id="二、解决方案"   >          <a href="#二、解决方案" class="heading-link"><i class="fas fa-link"></i></a>二、解决方案</h3>              <h4 id="1、将timer加入到NSRunloopCommonModes中"   >          <a href="#1、将timer加入到NSRunloopCommonModes中" class="heading-link"><i class="fas fa-link"></i></a>1、将timer加入到NSRunloopCommonModes中</h4>      <figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class="built_in">NSRunLoopCommonModes</span>];</span><br></pre></td></tr></table></div></figure>        <h4 id="2、将timer放到另一个线程中，然后开启另一个线程的runloop，这样可以保证与主线程互不干扰"   >          <a href="#2、将timer放到另一个线程中，然后开启另一个线程的runloop，这样可以保证与主线程互不干扰" class="heading-link"><i class="fas fa-link"></i></a>2、将timer放到另一个线程中，然后开启另一个线程的runloop，这样可以保证与主线程互不干扰</h4>      <figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">    timer = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">1</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(repeat:) userInfo:<span class="literal">nil</span> repeats:<span class="literal">true</span>];</span><br><span class="line">    [[<span class="built_in">NSRunLoop</span> currentRunLoop] run];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></div></figure>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;/nstimer%E5%92%8C%E7%95%8C%E9%9D%A2%E6%BB%91%E5%8A%A8%E5%86%B2%E7%AA%81/%E9%87%8D%E6%8B%BEiOS.jpg&quot; class=&quot;&quot;&gt;
&lt;br&gt;

&lt;blockquote&gt;
&lt;p&gt;关键词：NSTimer、CADisplayLink、GCD、RunLoop、多线程&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="重拾iOS" scheme="https://jack110530.github.io/categories/%E9%87%8D%E6%8B%BEiOS/"/>
    
    
    <category term="timer" scheme="https://jack110530.github.io/tags/timer/"/>
    
  </entry>
  
  <entry>
    <title>定时器</title>
    <link href="https://jack110530.github.io/%E5%AE%9A%E6%97%B6%E5%99%A8/"/>
    <id>https://jack110530.github.io/%E5%AE%9A%E6%97%B6%E5%99%A8/</id>
    <published>2020-10-24T03:47:55.000Z</published>
    <updated>2020-10-27T03:54:53.920Z</updated>
    
    <content type="html"><![CDATA[<img src="/%E5%AE%9A%E6%97%B6%E5%99%A8/%E9%87%8D%E6%8B%BEiOS.jpg" class=""><br><blockquote><p>关键词：NSTimer、CADisplayLink、GCD、RunLoop</p></blockquote><a id="more"></a>        <h3 id="前言"   >          <a href="#前言" class="heading-link"><i class="fas fa-link"></i></a>前言</h3>      <ol><li>开发中常用的定时器有哪些，优缺点是什么？</li><li>定时器的循环引用问题怎么解决？</li><li>CADisplayLink、NSTimer是否准时？</li></ol>        <h3 id="一、NSTimer和CADisplayLink"   >          <a href="#一、NSTimer和CADisplayLink" class="heading-link"><i class="fas fa-link"></i></a>一、NSTimer和CADisplayLink</h3>              <h4 id="1、NSTimer"   >          <a href="#1、NSTimer" class="heading-link"><i class="fas fa-link"></i></a>1、NSTimer</h4>      <p>常用api有：</p><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSTimer</span> *)timerWithTimeInterval:(<span class="built_in">NSTimeInterval</span>)ti invocation:(<span class="built_in">NSInvocation</span> *)invocation repeats:(<span class="built_in">BOOL</span>)yesOrNo;</span><br><span class="line">+ (<span class="built_in">NSTimer</span> *)scheduledTimerWithTimeInterval:(<span class="built_in">NSTimeInterval</span>)ti invocation:(<span class="built_in">NSInvocation</span> *)invocation repeats:(<span class="built_in">BOOL</span>)yesOrNo;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSTimer</span> *)timerWithTimeInterval:(<span class="built_in">NSTimeInterval</span>)ti target:(<span class="keyword">id</span>)aTarget selector:(SEL)aSelector userInfo:(<span class="keyword">nullable</span> <span class="keyword">id</span>)userInfo repeats:(<span class="built_in">BOOL</span>)yesOrNo;</span><br><span class="line">+ (<span class="built_in">NSTimer</span> *)scheduledTimerWithTimeInterval:(<span class="built_in">NSTimeInterval</span>)ti target:(<span class="keyword">id</span>)aTarget selector:(SEL)aSelector userInfo:(<span class="keyword">nullable</span> <span class="keyword">id</span>)userInfo repeats:(<span class="built_in">BOOL</span>)yesOrNo;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/// Creates and returns a new NSTimer object initialized with the specified block object. This timer needs to be scheduled on a run loop (via -[NSRunLoop addTimer:]) before it will fire.</span></span><br><span class="line"><span class="comment">/// - parameter:  timeInterval  The number of seconds between firings of the timer. If seconds is less than or equal to 0.0, this method chooses the nonnegative value of 0.1 milliseconds instead</span></span><br><span class="line"><span class="comment">/// - parameter:  repeats  If YES, the timer will repeatedly reschedule itself until invalidated. If NO, the timer will be invalidated after it fires.</span></span><br><span class="line"><span class="comment">/// - parameter:  block  The execution body of the timer; the timer itself is passed as the parameter to this block when executed to aid in avoiding cyclical references</span></span><br><span class="line">+ (<span class="built_in">NSTimer</span> *)timerWithTimeInterval:(<span class="built_in">NSTimeInterval</span>)interval repeats:(<span class="built_in">BOOL</span>)repeats block:(<span class="keyword">void</span> (^)(<span class="built_in">NSTimer</span> *timer))block API_AVAILABLE(macosx(<span class="number">10.12</span>), ios(<span class="number">10.0</span>), watchos(<span class="number">3.0</span>), tvos(<span class="number">10.0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Creates and returns a new NSTimer object initialized with the specified block object and schedules it on the current run loop in the default mode.</span></span><br><span class="line"><span class="comment">/// - parameter:  ti    The number of seconds between firings of the timer. If seconds is less than or equal to 0.0, this method chooses the nonnegative value of 0.1 milliseconds instead</span></span><br><span class="line"><span class="comment">/// - parameter:  repeats  If YES, the timer will repeatedly reschedule itself until invalidated. If NO, the timer will be invalidated after it fires.</span></span><br><span class="line"><span class="comment">/// - parameter:  block  The execution body of the timer; the timer itself is passed as the parameter to this block when executed to aid in avoiding cyclical references</span></span><br><span class="line">+ (<span class="built_in">NSTimer</span> *)scheduledTimerWithTimeInterval:(<span class="built_in">NSTimeInterval</span>)interval repeats:(<span class="built_in">BOOL</span>)repeats block:(<span class="keyword">void</span> (^)(<span class="built_in">NSTimer</span> *timer))block API_AVAILABLE(macosx(<span class="number">10.12</span>), ios(<span class="number">10.0</span>), watchos(<span class="number">3.0</span>), tvos(<span class="number">10.0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Initializes a new NSTimer object using the block as the main body of execution for the timer. This timer needs to be scheduled on a run loop (via -[NSRunLoop addTimer:]) before it will fire.</span></span><br><span class="line"><span class="comment">/// - parameter:  fireDate   The time at which the timer should first fire.</span></span><br><span class="line"><span class="comment">/// - parameter:  interval  The number of seconds between firings of the timer. If seconds is less than or equal to 0.0, this method chooses the nonnegative value of 0.1 milliseconds instead</span></span><br><span class="line"><span class="comment">/// - parameter:  repeats  If YES, the timer will repeatedly reschedule itself until invalidated. If NO, the timer will be invalidated after it fires.</span></span><br><span class="line"><span class="comment">/// - parameter:  block  The execution body of the timer; the timer itself is passed as the parameter to this block when executed to aid in avoiding cyclical references</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithFireDate:(<span class="built_in">NSDate</span> *)date interval:(<span class="built_in">NSTimeInterval</span>)interval repeats:(<span class="built_in">BOOL</span>)repeats block:(<span class="keyword">void</span> (^)(<span class="built_in">NSTimer</span> *timer))block API_AVAILABLE(macosx(<span class="number">10.12</span>), ios(<span class="number">10.0</span>), watchos(<span class="number">3.0</span>), tvos(<span class="number">10.0</span>));</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithFireDate:(<span class="built_in">NSDate</span> *)date interval:(<span class="built_in">NSTimeInterval</span>)ti target:(<span class="keyword">id</span>)t selector:(SEL)s userInfo:(<span class="keyword">nullable</span> <span class="keyword">id</span>)ui repeats:(<span class="built_in">BOOL</span>)rep <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)fire;</span><br></pre></td></tr></table></div></figure><p>在NSTimer的初始化方法中，以scheduled开头的方法，timer默认已经添加到了当前RunLoop中（以default mode形式添加）<br/></p>        <h4 id="2、CADisplayLink"   >          <a href="#2、CADisplayLink" class="heading-link"><i class="fas fa-link"></i></a>2、CADisplayLink</h4>      <p>常用api有：</p><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Create a new display link object for the main display. It will</span></span><br><span class="line"><span class="comment"> * invoke the method called &#x27;sel&#x27; on &#x27;target&#x27;, the method has the</span></span><br><span class="line"><span class="comment"> * signature &#x27;(void)selector:(CADisplayLink *)sender&#x27;. */</span></span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">CADisplayLink</span> *)displayLinkWithTarget:(<span class="keyword">id</span>)target selector:(SEL)sel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Adds the receiver to the given run-loop and mode. Unless paused, it</span></span><br><span class="line"><span class="comment"> * will fire every vsync until removed. Each object may only be added</span></span><br><span class="line"><span class="comment"> * to a single run-loop, but it may be added in multiple modes at once.</span></span><br><span class="line"><span class="comment"> * While added to a run-loop it will implicitly be retained. */</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)addToRunLoop:(<span class="built_in">NSRunLoop</span> *)runloop forMode:(<span class="built_in">NSRunLoopMode</span>)mode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Removes the receiver from the given mode of the runloop. This will</span></span><br><span class="line"><span class="comment"> * implicitly release it when removed from the last mode it has been</span></span><br><span class="line"><span class="comment"> * registered for. */</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)removeFromRunLoop:(<span class="built_in">NSRunLoop</span> *)runloop forMode:(<span class="built_in">NSRunLoopMode</span>)mode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Removes the object from all runloop modes (releasing the receiver if</span></span><br><span class="line"><span class="comment"> * it has been implicitly retained) and releases the &#x27;target&#x27; object. */</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)invalidate;</span><br></pre></td></tr></table></div></figure>        <h3 id="二、定时器循环引用问题的解决方案"   >          <a href="#二、定时器循环引用问题的解决方案" class="heading-link"><i class="fas fa-link"></i></a>二、定时器循环引用问题的解决方案</h3>              <h4 id="1、使用block方式初始化NSTimer；"   >          <a href="#1、使用block方式初始化NSTimer；" class="heading-link"><i class="fas fa-link"></i></a>1、使用block方式初始化NSTimer；</h4>              <h4 id="2、使用中间层WeakContainer；"   >          <a href="#2、使用中间层WeakContainer；" class="heading-link"><i class="fas fa-link"></i></a>2、使用中间层WeakContainer；</h4>      <p>代码示例：<br/><br>新建SFWeakContainer类<br></p><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SFWeakContainer</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithTarget:(<span class="built_in">NSObject</span> *)target;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)containerWithTarget:(<span class="built_in">NSObject</span> *)target;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// .m</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SFWeakContainer</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="built_in">NSObject</span> *target;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SFWeakContainer</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithTarget:(<span class="built_in">NSObject</span> *)target &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        <span class="keyword">self</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)containerWithTarget:(<span class="built_in">NSObject</span> *)target &#123;</span><br><span class="line">    SFWeakContainer *container = [[SFWeakContainer alloc]initWithTarget:target];</span><br><span class="line">    <span class="keyword">return</span> container;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 备用接受者</span></span><br><span class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.target &amp;&amp; [<span class="keyword">self</span>.target respondsToSelector:aSelector]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.target;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="keyword">super</span> forwardingTargetForSelector:aSelector];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></div></figure><p>测试：</p><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="keyword">self</span>.view.backgroundColor = [<span class="built_in">UIColor</span> whiteColor];</span><br><span class="line">    SFWeakContainer *weakContainer = [SFWeakContainer containerWithTarget:<span class="keyword">self</span>];</span><br><span class="line">    <span class="keyword">self</span>.timer = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">1</span> target:weakContainer selector:<span class="keyword">@selector</span>(timerEvent:) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)timerEvent:(<span class="built_in">NSTimer</span> *)timer &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;定时器事件&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    [<span class="keyword">self</span>.timer invalidate];</span><br><span class="line">    <span class="keyword">self</span>.timer = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h4 id="3、NSProxy消息转发；"   >          <a href="#3、NSProxy消息转发；" class="heading-link"><i class="fas fa-link"></i></a>3、NSProxy消息转发；</h4>      <p>代码示例：<br/><br>新建SFProxy<br/></p><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SFProxy</span> : <span class="title">NSProxy</span></span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithTarget:(<span class="keyword">id</span>)target;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)proxyWithTarget:(<span class="keyword">id</span>)target;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// .m</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SFProxy</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="built_in">NSObject</span> *target;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SFProxy</span></span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithTarget:(<span class="keyword">id</span>)target &#123;</span><br><span class="line">    _target = target;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)proxyWithTarget:(<span class="keyword">id</span>)target &#123;</span><br><span class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span> alloc] initWithTarget:target];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息转发</span></span><br><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.target &amp;&amp; [<span class="keyword">self</span>.target respondsToSelector:aSelector]) &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="keyword">self</span>.target methodSignatureForSelector:aSelector];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> methodSignatureForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation&#123;</span><br><span class="line">    SEL aSelector = [anInvocation selector];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.target &amp;&amp; [<span class="keyword">self</span>.target respondsToSelector:aSelector]) &#123;</span><br><span class="line">        [anInvocation invokeWithTarget:<span class="keyword">self</span>.target];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [<span class="keyword">super</span> forwardInvocation:anInvocation];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></div></figure><p>测试：</p><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="keyword">self</span>.view.backgroundColor = [<span class="built_in">UIColor</span> whiteColor];</span><br><span class="line">    SFProxy *proxy = [SFProxy proxyWithTarget:<span class="keyword">self</span>];</span><br><span class="line">    <span class="keyword">self</span>.timer = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">1</span> target:proxy selector:<span class="keyword">@selector</span>(timerEvent:) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)timerEvent:(<span class="built_in">NSTimer</span> *)timer &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;定时器事件&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    [<span class="keyword">self</span>.timer invalidate];</span><br><span class="line">    <span class="keyword">self</span>.timer = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>具体怎么做，根据个人喜好选择，我这里有一个写好的方案：<a href="">Crash防护(4)-NSTimer</a></p>        <h3 id="三、CADisplayLink、NSTimer是否准时？"   >          <a href="#三、CADisplayLink、NSTimer是否准时？" class="heading-link"><i class="fas fa-link"></i></a>三、CADisplayLink、NSTimer是否准时？</h3>      <p>CADisplayLink、NSTimer底层都是靠RunLoop来实现的，也就是可以把它们理解成RunLoop所需要处理的事件。我们知道RunLoop可以拿来刷新UI，处理定时器（CADisplayLink、NSTimer），处理点击滑动事件等非常多的事情。这里，就需要来了解一下RunLoop是如何触发NSTimer任务的。RunLoop每循环一圈，都会处理一定的事件，会消耗一定的时间，但是具体耗时多少这个是无法确定的。<br/></p><p>假如你开启一个timer，隔1秒触发定时器事件，RunLoop会开始累计每一圈循环的用时，当时间累计够1秒，就会触发定时器事件。你有兴趣的话，是可以在RunLoop的源码里面找到时间累加相关代码的。可以借助下图来加深理解:<br/></p><img src="/%E5%AE%9A%E6%97%B6%E5%99%A8/runloop1.png" class=""><p>如果RunLoop在某一圈任务过于繁重，就可能出现如下情况</p><img src="/%E5%AE%9A%E6%97%B6%E5%99%A8/runloop2.png" class=""><p>所以CADisplayLink、NSTimer是无法保证准时性的。</p>        <h3 id="四、GCD-Timer"   >          <a href="#四、GCD-Timer" class="heading-link"><i class="fas fa-link"></i></a>四、GCD Timer</h3>              <h4 id="1、GCD-Timer-的简单使用"   >          <a href="#1、GCD-Timer-的简单使用" class="heading-link"><i class="fas fa-link"></i></a>1、GCD Timer 的简单使用</h4>      <figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) dispatch_source_t timer;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">// 初始化定时器</span></span><br><span class="line">    <span class="keyword">self</span>.timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="number">0</span>, <span class="number">0</span>, dispatch_get_main_queue());</span><br><span class="line">    <span class="comment">// 间隔时间</span></span><br><span class="line">    uint64_t intervalTime = <span class="number">1.0</span>;</span><br><span class="line">    <span class="comment">//误差时间</span></span><br><span class="line">    uint64_t leewayTime = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 延迟时间</span></span><br><span class="line">    uint64_t delayTime = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 开始时间</span></span><br><span class="line">    dispatch_time_t startTime = dispatch_time(DISPATCH_TIME_NOW, delayTime*<span class="built_in">NSEC_PER_SEC</span>);</span><br><span class="line">    <span class="comment">// 设置定时器时间</span></span><br><span class="line">    dispatch_source_set_timer(<span class="keyword">self</span>.timer, startTime, intervalTime * <span class="built_in">NSEC_PER_SEC</span>, leewayTime * <span class="built_in">NSEC_PER_SEC</span>);</span><br><span class="line">    <span class="comment">// 设置定时器回调事件</span></span><br><span class="line">    dispatch_source_set_event_handler(<span class="keyword">self</span>.timer, ^&#123;</span><br><span class="line">        <span class="comment">// 定时器事件代码</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;GCD定时器事件&quot;</span>);</span><br><span class="line">        <span class="comment">// 如果定时器不需要重复，可以在这里取消定时器</span></span><br><span class="line">        dispatch_source_cancel(<span class="keyword">self</span>.timer);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 运行定时器</span></span><br><span class="line">    dispatch_resume(<span class="keyword">self</span>.timer);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h4 id="2、GCD-Timer-的封装"   >          <a href="#2、GCD-Timer-的封装" class="heading-link"><i class="fas fa-link"></i></a>2、GCD Timer 的封装</h4>      <p>代码如下：<br/></p><figure class="highlight objc"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&quot;SFGcdTimer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SFGcdTimer</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) dispatch_source_t timer;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">dispatch_queue_t</span> queue;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 提问：苹果为什么要把NSTimer中的target设计成强引用关系，既然他会导致循环引用问题，为什么苹果不直接将NSTimer的target设计成弱引用关系？</span></span><br><span class="line"><span class="comment"> * 所以这里保留跟NSTimer类似的设计</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSObject</span> *target;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">retain</span>) <span class="keyword">id</span> userInfo;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSTimeInterval</span> timeInterval;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SFGcdTimer</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: target方式</span></span><br><span class="line"><span class="comment">/// 初始化方法（target）</span></span><br><span class="line"><span class="comment">/// @param interval 时间间隔</span></span><br><span class="line"><span class="comment">/// @param delay 延迟时间</span></span><br><span class="line"><span class="comment">/// @param aTarget 执行对象</span></span><br><span class="line"><span class="comment">/// @param aSelector 执行方法</span></span><br><span class="line"><span class="comment">/// @param userInfo 附带信息</span></span><br><span class="line"><span class="comment">/// @param repeats 是否重复</span></span><br><span class="line">+ (SFGcdTimer *)timerWithTimeInterval:(<span class="built_in">NSTimeInterval</span>)interval delay:(<span class="built_in">NSTimeInterval</span>)delay target:(<span class="keyword">id</span>)aTarget selector:(SEL)aSelector userInfo:(<span class="keyword">nullable</span> <span class="keyword">id</span>)userInfo repeats:(<span class="built_in">BOOL</span>)repeats  &#123;</span><br><span class="line">    SFGcdTimer *timer = [[SFGcdTimer alloc] initWithTimeInterval:interval delay:delay target:aTarget selector:aSelector userInfo:userInfo repeats:repeats queue:<span class="literal">nil</span>];</span><br><span class="line">    <span class="keyword">return</span> timer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 初始化方法（target）</span></span><br><span class="line"><span class="comment">/// @param interval 时间间隔</span></span><br><span class="line"><span class="comment">/// @param delay 延迟时间</span></span><br><span class="line"><span class="comment">/// @param aTarget 执行对象</span></span><br><span class="line"><span class="comment">/// @param aSelector 执行方法</span></span><br><span class="line"><span class="comment">/// @param userInfo 附带信息</span></span><br><span class="line"><span class="comment">/// @param repeats 是否重复</span></span><br><span class="line"><span class="comment">/// @param queue 指定队列（默认主队列）</span></span><br><span class="line">+ (SFGcdTimer *)timerWithTimeInterval:(<span class="built_in">NSTimeInterval</span>)interval delay:(<span class="built_in">NSTimeInterval</span>)delay target:(<span class="keyword">id</span>)aTarget selector:(SEL)aSelector userInfo:(<span class="keyword">nullable</span> <span class="keyword">id</span>)userInfo repeats:(<span class="built_in">BOOL</span>)repeats queue:(<span class="built_in">dispatch_queue_t</span>)queue &#123;</span><br><span class="line">    SFGcdTimer *timer = [[SFGcdTimer alloc] initWithTimeInterval:interval delay:delay target:aTarget selector:aSelector userInfo:userInfo repeats:repeats queue:queue];</span><br><span class="line">    <span class="keyword">return</span> timer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 初始化方法（target）</span></span><br><span class="line"><span class="comment">/// @param interval 时间间隔</span></span><br><span class="line"><span class="comment">/// @param delay 延迟时间</span></span><br><span class="line"><span class="comment">/// @param aTarget 执行对象</span></span><br><span class="line"><span class="comment">/// @param aSelector 执行方法</span></span><br><span class="line"><span class="comment">/// @param userInfo 附带信息</span></span><br><span class="line"><span class="comment">/// @param repeats 是否重复</span></span><br><span class="line"><span class="comment">/// @param queue 指定队列（默认主队列）</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithTimeInterval:(<span class="built_in">NSTimeInterval</span>)interval delay:(<span class="built_in">NSTimeInterval</span>)delay target:(<span class="keyword">id</span>)aTarget selector:(SEL)aSelector userInfo:(<span class="keyword">nullable</span> <span class="keyword">id</span>)userInfo repeats:(<span class="built_in">BOOL</span>)repeats queue:(<span class="built_in">dispatch_queue_t</span>)queue &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        <span class="keyword">self</span>.timeInterval = interval;</span><br><span class="line">        <span class="keyword">self</span>.queue = queue;</span><br><span class="line">        <span class="keyword">self</span>.target = aTarget;</span><br><span class="line">        <span class="keyword">self</span>.userInfo = userInfo;</span><br><span class="line">        <span class="keyword">self</span>.timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">self</span>.queue);</span><br><span class="line">        dispatch_source_set_timer(<span class="keyword">self</span>.timer,</span><br><span class="line">                                  dispatch_time(DISPATCH_TIME_NOW, delay * <span class="built_in">NSEC_PER_SEC</span>), <span class="comment">// 开始时间</span></span><br><span class="line">                                  interval * <span class="built_in">NSEC_PER_SEC</span>, <span class="comment">// 间隔</span></span><br><span class="line">                                  <span class="number">0</span> <span class="comment">// 误差</span></span><br><span class="line">                                  );</span><br><span class="line">        dispatch_source_set_event_handler(<span class="keyword">self</span>.timer, ^&#123;</span><br><span class="line">            <span class="keyword">if</span> ([<span class="keyword">self</span>.target respondsToSelector:aSelector]) &#123;</span><br><span class="line">                [<span class="keyword">self</span>.target performSelector:aSelector withObject:<span class="keyword">self</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!repeats) &#123;</span><br><span class="line">                [<span class="keyword">self</span> invalidate];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: block方式</span></span><br><span class="line"><span class="comment">/// 初始化方法（block）</span></span><br><span class="line"><span class="comment">/// @param interval 时间间隔</span></span><br><span class="line"><span class="comment">/// @param delay 延迟时间</span></span><br><span class="line"><span class="comment">/// @param repeats 是否重复</span></span><br><span class="line"><span class="comment">/// @param block 执行block</span></span><br><span class="line">+ (SFGcdTimer *)timerWithTimeInterval:(<span class="built_in">NSTimeInterval</span>)interval delay:(<span class="built_in">NSTimeInterval</span>)delay repeats:(<span class="built_in">BOOL</span>)repeats block:(<span class="keyword">void</span> (^)(SFGcdTimer *timer))block &#123;</span><br><span class="line">    SFGcdTimer *timer = [[SFGcdTimer alloc]initWithTimeInterval:interval delay:delay repeats:repeats block:block queue:<span class="literal">nil</span>];</span><br><span class="line">    <span class="keyword">return</span> timer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 初始化方法（block）</span></span><br><span class="line"><span class="comment">/// @param interval 时间间隔</span></span><br><span class="line"><span class="comment">/// @param delay 延迟时间</span></span><br><span class="line"><span class="comment">/// @param repeats 是否重复</span></span><br><span class="line"><span class="comment">/// @param block 执行block</span></span><br><span class="line"><span class="comment">/// @param queue 执行队列（默认主队列）</span></span><br><span class="line">+ (SFGcdTimer *)timerWithTimeInterval:(<span class="built_in">NSTimeInterval</span>)interval delay:(<span class="built_in">NSTimeInterval</span>)delay repeats:(<span class="built_in">BOOL</span>)repeats block:(<span class="keyword">void</span> (^)(SFGcdTimer *timer))block queue:(<span class="built_in">dispatch_queue_t</span>)queue &#123;</span><br><span class="line">    SFGcdTimer *timer = [[SFGcdTimer alloc]initWithTimeInterval:interval delay:delay repeats:repeats block:block queue:queue];</span><br><span class="line">    <span class="keyword">return</span> timer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 初始化方法（block）</span></span><br><span class="line"><span class="comment">/// @param interval 时间间隔</span></span><br><span class="line"><span class="comment">/// @param delay 延迟时间</span></span><br><span class="line"><span class="comment">/// @param repeats 是否重复</span></span><br><span class="line"><span class="comment">/// @param block 执行block</span></span><br><span class="line"><span class="comment">/// @param queue 执行队列（默认主队列）</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithTimeInterval:(<span class="built_in">NSTimeInterval</span>)interval delay:(<span class="built_in">NSTimeInterval</span>)delay repeats:(<span class="built_in">BOOL</span>)repeats block:(<span class="keyword">void</span> (^)(SFGcdTimer *timer))block queue:(<span class="built_in">dispatch_queue_t</span>)queue &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        <span class="keyword">self</span>.timeInterval = interval;</span><br><span class="line">        <span class="keyword">self</span>.queue = queue;</span><br><span class="line">        <span class="keyword">self</span>.timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">self</span>.queue);</span><br><span class="line">        dispatch_source_set_timer(<span class="keyword">self</span>.timer,</span><br><span class="line">                                  dispatch_time(DISPATCH_TIME_NOW, delay * <span class="built_in">NSEC_PER_SEC</span>), <span class="comment">// 开始时间</span></span><br><span class="line">                                  interval * <span class="built_in">NSEC_PER_SEC</span>, <span class="comment">// 间隔</span></span><br><span class="line">                                  <span class="number">0</span> <span class="comment">// 误差</span></span><br><span class="line">                                  );</span><br><span class="line">        dispatch_source_set_event_handler(<span class="keyword">self</span>.timer, ^&#123;</span><br><span class="line">            <span class="keyword">if</span> (block) &#123;</span><br><span class="line">                block(<span class="keyword">self</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!repeats) &#123;</span><br><span class="line">                [<span class="keyword">self</span> invalidate];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 开启</span></span><br><span class="line">- (<span class="keyword">void</span>)fire &#123;</span><br><span class="line">    dispatch_resume(<span class="keyword">self</span>.timer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 暂停</span></span><br><span class="line">- (<span class="keyword">void</span>)pause &#123;</span><br><span class="line">    dispatch_suspend(<span class="keyword">self</span>.timer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 销毁</span></span><br><span class="line">- (<span class="keyword">void</span>)invalidate &#123;</span><br><span class="line">    dispatch_source_cancel(<span class="keyword">self</span>.timer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - lazy load</span></span><br><span class="line"><span class="comment">// 默认主队列</span></span><br><span class="line">- (<span class="built_in">dispatch_queue_t</span>)queue &#123;</span><br><span class="line">    <span class="keyword">if</span> (!_queue) &#123;</span><br><span class="line">        _queue = dispatch_get_main_queue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _queue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></div></figure><hr><p>[代码链接]<br/><br>GitHub：<span class="exturl"><a class="exturl__link"   href="https://github.com/jack110530/SFCrash" >https://github.com/jack110530/SFCrash</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><hr><p>[相关参考]<br/></p><ol><li><span class="exturl"><a class="exturl__link"   href="https://juejin.im/post/6844904033824538638" >比较一下iOS中的三种定时器</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> </li><li><span class="exturl"><a class="exturl__link"   href="https://blog.csdn.net/u013480070/article/details/100154694" >内存管理——定时器问题</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li></ol><p>[相关思考]<br/></p><ol><li>NSTimer和线程的关系</li><li>苹果为什么要把NSTimer中的target设计成强引用关系，既然他会导致循环引用问题，为什么苹果不直接将NSTimer的target设计成弱引用关系？</li></ol>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;/%E5%AE%9A%E6%97%B6%E5%99%A8/%E9%87%8D%E6%8B%BEiOS.jpg&quot; class=&quot;&quot;&gt;
&lt;br&gt;

&lt;blockquote&gt;
&lt;p&gt;关键词：NSTimer、CADisplayLink、GCD、RunLoop&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="重拾iOS" scheme="https://jack110530.github.io/categories/%E9%87%8D%E6%8B%BEiOS/"/>
    
    
    <category term="timer" scheme="https://jack110530.github.io/tags/timer/"/>
    
  </entry>
  
</feed>
